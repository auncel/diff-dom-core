window.Diff =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../common/exceptions/ElementNotExistError.ts":
/*!****************************************************!*\
  !*** ../common/exceptions/ElementNotExistError.ts ***!
  \****************************************************/
/*! exports provided: ElementNotExistError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementNotExistError\", function() { return ElementNotExistError; });\nclass ElementNotExistError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'ElementNotExistError';\n    }\n}\n\n\n//# sourceURL=webpack://window.Diff/../common/exceptions/ElementNotExistError.ts?");

/***/ }),

/***/ "../common/exceptions/index.ts":
/*!*************************************!*\
  !*** ../common/exceptions/index.ts ***!
  \*************************************/
/*! exports provided: ElementNotExistError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ElementNotExistError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ElementNotExistError */ \"../common/exceptions/ElementNotExistError.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ElementNotExistError\", function() { return _ElementNotExistError__WEBPACK_IMPORTED_MODULE_0__[\"ElementNotExistError\"]; });\n\n\n\n\n//# sourceURL=webpack://window.Diff/../common/exceptions/index.ts?");

/***/ }),

/***/ "../common/types/domCore.ts":
/*!**********************************!*\
  !*** ../common/types/domCore.ts ***!
  \**********************************/
/*! exports provided: STRICT_MODE, LOOSE_MODE, NodeType, DiffType, DistinctionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STRICT_MODE\", function() { return STRICT_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOOSE_MODE\", function() { return LOOSE_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeType\", function() { return NodeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiffType\", function() { return DiffType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DistinctionType\", function() { return DistinctionType; });\nconst STRICT_MODE = 0;\nconst LOOSE_MODE = 1;\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n    NodeType[NodeType[\"ATTRIBUTE_NODE\"] = 2] = \"ATTRIBUTE_NODE\";\n    NodeType[NodeType[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n    NodeType[NodeType[\"CDATA_SECTION_NODE\"] = 4] = \"CDATA_SECTION_NODE\";\n    NodeType[NodeType[\"ENTITY_REFERENCE_NODE\"] = 5] = \"ENTITY_REFERENCE_NODE\";\n    NodeType[NodeType[\"PROCESSING_INSTRUCTION_NODE\"] = 6] = \"PROCESSING_INSTRUCTION_NODE\";\n    NodeType[NodeType[\"ENTITY_NODE\"] = 7] = \"ENTITY_NODE\";\n    NodeType[NodeType[\"COMMENT_NODE\"] = 8] = \"COMMENT_NODE\";\n    NodeType[NodeType[\"DOCUMENT_NODE\"] = 9] = \"DOCUMENT_NODE\";\n    NodeType[NodeType[\"DOCUMENT_TYPE_NODE\"] = 10] = \"DOCUMENT_TYPE_NODE\";\n    NodeType[NodeType[\"DOCUMENT_FRAGMENT_NODE\"] = 11] = \"DOCUMENT_FRAGMENT_NODE\";\n    NodeType[NodeType[\"NOTATION_NODE\"] = 12] = \"NOTATION_NODE\";\n})(NodeType || (NodeType = {}));\nvar DiffType;\n(function (DiffType) {\n    DiffType[DiffType[\"None\"] = 0] = \"None\";\n    DiffType[DiffType[\"NodeType\"] = 1] = \"NodeType\";\n    DiffType[DiffType[\"Tag\"] = 2] = \"Tag\";\n    DiffType[DiffType[\"Id\"] = 4] = \"Id\";\n    DiffType[DiffType[\"ClassName\"] = 8] = \"ClassName\";\n    DiffType[DiffType[\"Attr\"] = 16] = \"Attr\";\n    DiffType[DiffType[\"DataSet\"] = 32] = \"DataSet\";\n    DiffType[DiffType[\"Style\"] = 64] = \"Style\";\n    DiffType[DiffType[\"Rect\"] = 128] = \"Rect\";\n    DiffType[DiffType[\"Text\"] = 256] = \"Text\";\n})(DiffType || (DiffType = {}));\nvar DistinctionType;\n(function (DistinctionType) {\n    DistinctionType[DistinctionType[\"MISSING\"] = 0] = \"MISSING\";\n    DistinctionType[DistinctionType[\"EXTRA\"] = 1] = \"EXTRA\";\n    DistinctionType[DistinctionType[\"INEQUAL\"] = 2] = \"INEQUAL\";\n    DistinctionType[DistinctionType[\"EQUALITY\"] = 3] = \"EQUALITY\";\n})(DistinctionType || (DistinctionType = {}));\n\n\n//# sourceURL=webpack://window.Diff/../common/types/domCore.ts?");

/***/ }),

/***/ "./lib/CSSTree/parseCSS.ts":
/*!*********************************!*\
  !*** ./lib/CSSTree/parseCSS.ts ***!
  \*********************************/
/*! exports provided: parseCSS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseCSS\", function() { return parseCSS; });\n/* harmony import */ var _RenderTree_CSSShorthandProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../RenderTree/CSSShorthandProperties */ \"./lib/RenderTree/CSSShorthandProperties.ts\");\n\nconst CSSTree = __webpack_require__(/*! ../../node_modules/css-tree/dist/csstree.js */ \"./node_modules/css-tree/dist/csstree.js\");\nfunction parseCSS(text) {\n    const ast = CSSTree.parse(text);\n    const selectorMap = new Map();\n    CSSTree.walk(ast, function astVisitor(node) {\n        if (node.type === 'Rule') {\n            const { prelude, block } = node;\n            const properties = new Set();\n            block.children.forEach((declaration) => {\n                if (declaration.type === 'Declaration') {\n                    if (_RenderTree_CSSShorthandProperties__WEBPACK_IMPORTED_MODULE_0__[\"default\"][declaration.property]) {\n                        _RenderTree_CSSShorthandProperties__WEBPACK_IMPORTED_MODULE_0__[\"default\"][declaration.property].forEach((property) => {\n                            properties.add(property);\n                        });\n                    }\n                    else {\n                        properties.add(declaration.property);\n                    }\n                }\n            });\n            if (prelude.type === 'SelectorList') {\n                function getSelectorStr(prelude) {\n                    const result = [];\n                    prelude.children.forEach((selector) => {\n                        if (selector.type === 'Selector') {\n                            const { children } = selector;\n                            const selectors = [];\n                            children.forEach((s) => {\n                                switch (s.type) {\n                                    case 'TypeSelector':\n                                        selectors.push(s.name);\n                                        break;\n                                    case 'ClassSelector':\n                                        selectors.push(`.${s.name}`);\n                                        break;\n                                    case 'IdSelector':\n                                        selectors.push(`#${s.name}`);\n                                        break;\n                                    case 'WhiteSpace':\n                                        selectors.push(s.value);\n                                        break;\n                                    case 'AttributeSelector': {\n                                        let AttrSelector = `[${s.name.name}`;\n                                        if (s.matcher) {\n                                            AttrSelector += s.matcher;\n                                        }\n                                        if (s.value && s.value.type === 'String' && s.value.value) {\n                                            AttrSelector += s.value.value;\n                                        }\n                                        AttrSelector += ']';\n                                        selectors.push(AttrSelector);\n                                        break;\n                                    }\n                                    case 'PseudoClassSelector':\n                                        if (s.children) {\n                                            const nestSelectors = [];\n                                            s.children.forEach((cssNode) => {\n                                                if (cssNode.type === 'SelectorList') {\n                                                    const nestSelector = getSelectorStr(cssNode);\n                                                    nestSelectors.push(nestSelector.join(', '));\n                                                }\n                                                else if (cssNode.type === 'Nth') {\n                                                    const { nth } = cssNode;\n                                                    if (nth.type === 'AnPlusB') {\n                                                        if (typeof nth.a === 'string') {\n                                                            nestSelectors.push(`${nth.a}n`);\n                                                        }\n                                                        if (typeof nth.b === 'string') {\n                                                            const b = Number(nth.b);\n                                                            nestSelectors.push(String(b > 0 ? `+${nth.b}` : nth.b));\n                                                        }\n                                                    }\n                                                    nestSelectors.push();\n                                                }\n                                            });\n                                            selectors.push(`:${s.name}(${nestSelectors.join('')})`);\n                                        }\n                                        else {\n                                            selectors.push(`:${s.name}`);\n                                        }\n                                        break;\n                                    case 'PseudoElementSelector':\n                                        selectors.push(`::${s.name}`);\n                                        break;\n                                    case 'Combinator':\n                                        selectors.push(` ${s.name} `);\n                                        break;\n                                    default:\n                                        selectors.push('');\n                                }\n                            });\n                            result.push(selectors.join(''));\n                        }\n                    });\n                    return result;\n                }\n                const selectors = getSelectorStr(prelude);\n                selectors.forEach(selector => selectorMap.set(selector, properties));\n            }\n        }\n    });\n    return selectorMap;\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/CSSTree/parseCSS.ts?");

/***/ }),

/***/ "./lib/RenderTree/CSSShorthandProperties.ts":
/*!**************************************************!*\
  !*** ./lib/RenderTree/CSSShorthandProperties.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    animation: [\n        'animation-delay',\n        'animation-direction',\n        'animation-duration',\n        'animation-fill-mode',\n        'animation-iteration-count',\n        'animation-name',\n        'animation-play-state',\n        'animation-timing-function',\n    ],\n    background: [\n        'background-attachment',\n        'background-blend-mode',\n        'background-clip',\n        'background-color',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n    ],\n    border: [\n        'border-collapse',\n        'border-color',\n        'border-end-end-radius',\n        'border-end-start-radius',\n        'border-radius',\n        'border-spacing',\n        'border-start-end-radius',\n        'border-start-start-radius',\n        'border-style',\n        'border-width',\n    ],\n    'border-block': [\n        'border-block-color',\n        'border-block-style',\n        'border-block-width',\n    ],\n    'border-block-end': [\n        'border-block-end-color',\n        'border-block-end-style',\n        'border-block-end-width',\n    ],\n    'border-block-start': [\n        'border-block-start-color',\n        'border-block-start-style',\n        'border-block-start-width',\n    ],\n    'border-bottom': [\n        'border-bottom-color',\n        'border-bottom-left-radius',\n        'border-bottom-right-radius',\n        'border-bottom-style',\n        'border-bottom-width',\n    ],\n    'border-image': [\n        'border-image-outset',\n        'border-image-repeat',\n        'border-image-slice',\n        'border-image-source',\n        'border-image-width',\n    ],\n    'border-inline': [\n        'border-inline-color',\n        'border-inline-style',\n        'border-inline-width',\n    ],\n    'border-inline-end': [\n        'border-inline-end-color',\n        'border-inline-end-style',\n        'border-inline-end-width',\n    ],\n    'border-inline-start': [\n        'border-inline-start-color',\n        'border-inline-start-style',\n        'border-inline-start-width',\n    ],\n    'border-left': [\n        'border-left-color',\n        'border-left-style',\n        'border-left-width',\n    ],\n    'border-right': [\n        'border-right-color',\n        'border-right-style',\n        'border-right-width',\n    ],\n    'border-top': [\n        'border-top-color',\n        'border-top-left-radius',\n        'border-top-right-radius',\n        'border-top-style',\n        'border-top-width',\n    ],\n    'column-rule': [\n        'column-rule-color',\n        'column-rule-style',\n        'column-rule-width',\n    ],\n    flex: [\n        'flex-basis',\n        'flex-direction',\n        'flex-flow',\n        'flex-grow',\n        'flex-shrink',\n        'flex-wrap',\n    ],\n    font: [\n        'font-family',\n        'font-feature-settings',\n        'font-kerning',\n        'font-language-override',\n        'font-optical-sizing',\n        'font-stretch',\n        'font-style',\n        'font-synthesis',\n        'font-weight',\n    ],\n    'font-variant': [\n        'font-variant-alternates',\n        'font-variant-caps',\n        'font-variant-east-asian',\n        'font-variant-ligatures',\n        'font-variant-numeric',\n        'font-variant-position',\n    ],\n    grid: [\n        'grid-area',\n        'grid-auto-columns',\n        'grid-auto-flow',\n        'grid-auto-rows',\n    ],\n    'grid-column': [\n        'grid-column-end',\n        'grid-column-start',\n    ],\n    'grid-row': [\n        'grid-row-end',\n        'grid-row-start',\n    ],\n    'grid-template': [\n        'grid-template-areas',\n        'grid-template-columns',\n        'grid-template-rows',\n    ],\n    'inset-block': [\n        'inset-block-end',\n        'inset-block-start',\n    ],\n    'inset-inline': [\n        'inset-inline-end',\n        'inset-inline-start',\n    ],\n    'list-style': [\n        'list-style-image',\n        'list-style-position',\n        'list-style-type',\n    ],\n    margin: [\n        'margin-bottom',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n    ],\n    'margin-block': [\n        'margin-block-end',\n        'margin-block-start',\n    ],\n    'margin-inline': [\n        'margin-inline-end',\n        'margin-inline-start',\n    ],\n    mask: [\n        'mask-clip',\n        'mask-composite',\n        'mask-image',\n        'mask-mode',\n        'mask-origin',\n        'mask-position',\n        'mask-repeat',\n        'mask-size',\n        'mask-type',\n    ],\n    outline: [\n        'outline-color',\n        'outline-offset',\n        'outline-style',\n        'outline-width',\n    ],\n    overflow: [\n        'overflow-wrap',\n        'overflow-x',\n        'overflow-y',\n    ],\n    padding: [\n        'padding-bottom',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n    ],\n    'padding-block': [\n        'padding-block-end',\n        'padding-block-start',\n    ],\n    'padding-inline': [\n        'padding-inline-end',\n        'padding-inline-start',\n    ],\n    'scroll-margin': [\n        'scroll-margin-bottom',\n        'scroll-margin-left',\n        'scroll-margin-right',\n        'scroll-margin-top',\n    ],\n    'scroll-margin-block': [\n        'scroll-margin-block-end',\n        'scroll-margin-block-start',\n    ],\n    'scroll-margin-inline': [\n        'scroll-margin-inline-end',\n        'scroll-margin-inline-start',\n    ],\n    'scroll-padding': [\n        'scroll-padding-bottom',\n        'scroll-padding-left',\n        'scroll-padding-right',\n        'scroll-padding-top',\n    ],\n    'scroll-padding-block': [\n        'scroll-padding-block-end',\n        'scroll-padding-block-start',\n    ],\n    'scroll-padding-inline': [\n        'scroll-padding-inline-end',\n        'scroll-padding-inline-start',\n    ],\n    'text-decoration': [\n        'text-decoration-color',\n        'text-decoration-line',\n        'text-decoration-style',\n    ],\n    'text-emphasis': [\n        'text-emphasis-color',\n        'text-emphasis-position',\n        'text-emphasis-style',\n    ],\n    transform: [\n        'transform-box',\n        'transform-origin',\n        'transform-style',\n    ],\n    transition: [\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function',\n    ],\n});\n\n\n//# sourceURL=webpack://window.Diff/./lib/RenderTree/CSSShorthandProperties.ts?");

/***/ }),

/***/ "./lib/RenderTree/appendUuid.ts":
/*!**************************************!*\
  !*** ./lib/RenderTree/appendUuid.ts ***!
  \**************************************/
/*! exports provided: appendUuid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"appendUuid\", function() { return appendUuid; });\n/* harmony import */ var _getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCSSPropertyValues */ \"./lib/RenderTree/getCSSPropertyValues.ts\");\n\nfunction getLastOrderNumber(uuid) {\n    return Number(uuid.substring(uuid.lastIndexOf('_') + 1));\n}\nfunction appendUuid(doc) {\n    const treeWalker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, {\n        acceptNode() {\n            return NodeFilter.FILTER_ACCEPT;\n        },\n    }, false);\n    doc.body.setAttribute(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"], 'uuid_0');\n    while (treeWalker.nextNode()) {\n        const current = treeWalker.currentNode;\n        const parent = current.parentNode;\n        const parentUuid = parent.getAttribute(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"]);\n        const firstChild = parent.firstElementChild;\n        if (current.isEqualNode(firstChild)) {\n            current.setAttribute(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"], `${parentUuid}_0`);\n        }\n        else {\n            const prevSibling = current.previousElementSibling;\n            const prevSiblingUuid = prevSibling.getAttribute(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"]);\n            current.setAttribute(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"], `${parentUuid}_${getLastOrderNumber(prevSiblingUuid) + 1}`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/RenderTree/appendUuid.ts?");

/***/ }),

/***/ "./lib/RenderTree/generateRenderTree.ts":
/*!**********************************************!*\
  !*** ./lib/RenderTree/generateRenderTree.ts ***!
  \**********************************************/
/*! exports provided: generateRenderTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateRenderTree\", function() { return generateRenderTree; });\n/* harmony import */ var _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @surpass/common/types/domCore */ \"../common/types/domCore.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ \"./lib/utils.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./lib/RenderTree/utils.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ \"./lib/config.ts\");\n\n\n\n\nfunction depthFirstTraversal(domNode, renderNode, coordinate, config) {\n    if (domNode.nodeType === _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].ELEMENT_NODE) {\n        renderNode.id = domNode.id;\n        const tagName = renderNode.tagName = domNode.tagName;\n        renderNode.className = domNode.className;\n        renderNode.nodeType = _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].ELEMENT_NODE;\n        renderNode.uuid = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getUuid\"])(domNode);\n        renderNode.attr = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getAttrs\"])(domNode);\n        renderNode.style = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getStyle\"])(domNode);\n        renderNode.rect = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getRect\"])(domNode, coordinate);\n        if (!config.noChildElement.includes(tagName)) {\n            const children = domNode.childNodes;\n            renderNode.children = [];\n            let x = coordinate.x;\n            if (typeof renderNode.rect.top !== 'undefined') {\n                x = renderNode.rect.top;\n            }\n            let y = coordinate.y;\n            if (typeof renderNode.rect.left !== 'undefined') {\n                y = renderNode.rect.left;\n            }\n            const nextCoordinate = { x, y };\n            for (let i = 0; i < children.length; i++) {\n                const childNode = children[i];\n                if (childNode.nodeType === _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].TEXT_NODE) {\n                    const text = childNode.nodeValue.trim();\n                    if (text) {\n                        const textChild = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"createTextNode\"])(text);\n                        renderNode.children.push(textChild);\n                    }\n                }\n                else {\n                    const renderChild = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"createEmptyNode\"])(tagName);\n                    renderNode.children.push(renderChild);\n                    depthFirstTraversal(childNode, renderChild, nextCoordinate, config);\n                }\n            }\n        }\n    }\n    else if (domNode.nodeType === _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].TEXT_NODE) {\n        renderNode.nodeType = _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].TEXT_NODE;\n        renderNode.text = domNode.nodeValue;\n    }\n}\nfunction generateRenderTree(body, config = {}) {\n    const root = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"createEmptyNode\"])();\n    Object(_config__WEBPACK_IMPORTED_MODULE_3__[\"mergeWithDefaultConfig\"])(config);\n    depthFirstTraversal(body, root, { x: 0, y: 0 }, config);\n    return root;\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/RenderTree/generateRenderTree.ts?");

/***/ }),

/***/ "./lib/RenderTree/getCSSPropertyValues.ts":
/*!************************************************!*\
  !*** ./lib/RenderTree/getCSSPropertyValues.ts ***!
  \************************************************/
/*! exports provided: UUID_ATTR, computeElementStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UUID_ATTR\", function() { return UUID_ATTR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeElementStyle\", function() { return computeElementStyle; });\n/* harmony import */ var _surpass_common_exceptions_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @surpass/common/exceptions/index */ \"../common/exceptions/index.ts\");\n/* harmony import */ var _CSSTree_parseCSS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CSSTree/parseCSS */ \"./lib/CSSTree/parseCSS.ts\");\n/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../const */ \"./lib/const.ts\");\n\n\n\nconst UUID_ATTR = '__uuid__';\nfunction computeElementStyle(document) {\n    const elementStyleCache = new Map();\n    const $userStyle = document.getElementById(_const__WEBPACK_IMPORTED_MODULE_2__[\"USER_STYLE_ID\"]);\n    if ($userStyle === null) {\n        throw new _surpass_common_exceptions_index__WEBPACK_IMPORTED_MODULE_0__[\"ElementNotExistError\"](`should have style#${_const__WEBPACK_IMPORTED_MODULE_2__[\"USER_STYLE_ID\"]}`);\n    }\n    const stylesheet = $userStyle.innerHTML;\n    const selectorMap = Object(_CSSTree_parseCSS__WEBPACK_IMPORTED_MODULE_1__[\"parseCSS\"])(stylesheet);\n    for (const [selector, properties] of selectorMap) {\n        const $elementList = document.querySelectorAll(selector);\n        $elementList.forEach(($element) => {\n            const elementUuid = $element.getAttribute(UUID_ATTR);\n            let propertyMap = null;\n            if (elementStyleCache.has(elementUuid)) {\n                propertyMap = elementStyleCache.get(elementUuid);\n            }\n            else {\n                propertyMap = new Map();\n                elementStyleCache.set(elementUuid, propertyMap);\n            }\n            const elementStyle = window.getComputedStyle($element);\n            properties.forEach((property) => {\n                const propertyValue = elementStyle[property];\n                propertyMap.set(property, propertyValue);\n            });\n        });\n    }\n    return elementStyleCache;\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/RenderTree/getCSSPropertyValues.ts?");

/***/ }),

/***/ "./lib/RenderTree/index.ts":
/*!*********************************!*\
  !*** ./lib/RenderTree/index.ts ***!
  \*********************************/
/*! exports provided: generateTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateTree\", function() { return generateTree; });\n/* harmony import */ var _appendUuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appendUuid */ \"./lib/RenderTree/appendUuid.ts\");\n/* harmony import */ var _generateRenderTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateRenderTree */ \"./lib/RenderTree/generateRenderTree.ts\");\n/* harmony import */ var _getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getCSSPropertyValues */ \"./lib/RenderTree/getCSSPropertyValues.ts\");\n\n\n\nfunction generateTree() {\n    const doc = document;\n    Object(_appendUuid__WEBPACK_IMPORTED_MODULE_0__[\"appendUuid\"])(doc);\n    window.elementPropertyMap = Object(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_2__[\"computeElementStyle\"])(document);\n    const body = document.body;\n    const renderTree = Object(_generateRenderTree__WEBPACK_IMPORTED_MODULE_1__[\"generateRenderTree\"])(body);\n    return renderTree;\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/RenderTree/index.ts?");

/***/ }),

/***/ "./lib/RenderTree/utils.ts":
/*!*********************************!*\
  !*** ./lib/RenderTree/utils.ts ***!
  \*********************************/
/*! exports provided: getUuid, getStyle, getAttrs, getRect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUuid\", function() { return getUuid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStyle\", function() { return getStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAttrs\", function() { return getAttrs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRect\", function() { return getRect; });\n/* harmony import */ var _getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCSSPropertyValues */ \"./lib/RenderTree/getCSSPropertyValues.ts\");\n\nfunction getUuid(node) {\n    return node.getAttribute(_getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"]);\n}\nconst defaultMap = new Map();\nfunction getStyle(node) {\n    let styleObj = {};\n    const uuid = getUuid(node);\n    if (uuid) {\n        styleObj = Object.fromEntries(window.elementPropertyMap.get(uuid) || defaultMap);\n    }\n    return styleObj;\n}\nconst ignoreAttrs = ['class', 'id', 'style', _getCSSPropertyValues__WEBPACK_IMPORTED_MODULE_0__[\"UUID_ATTR\"]];\nconst datasetReg = /^data-.+/;\nfunction getAttrs(node) {\n    const attrObj = {};\n    const attrs = node.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        const nodeName = attr.nodeName;\n        if (!ignoreAttrs.includes(nodeName) && !datasetReg.test(nodeName)) {\n            attrObj[nodeName] = attr.nodeValue;\n        }\n    }\n    return attrObj;\n}\nfunction getRect(node, coordinate) {\n    const rect = node.getBoundingClientRect();\n    const { left, top, width, height } = rect;\n    return {\n        x: left,\n        y: top,\n        left: left - coordinate.x,\n        top: top - coordinate.y,\n        width,\n        height,\n    };\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/RenderTree/utils.ts?");

/***/ }),

/***/ "./lib/config.ts":
/*!***********************!*\
  !*** ./lib/config.ts ***!
  \***********************/
/*! exports provided: generateRenderTreeOptions, mergeWithDefaultConfig, strictlyEqualOption */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateRenderTreeOptions\", function() { return generateRenderTreeOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeWithDefaultConfig\", function() { return mergeWithDefaultConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"strictlyEqualOption\", function() { return strictlyEqualOption; });\nconst generateRenderTreeOptions = {\n    ignoreElement: [\n        'script', 'style',\n    ],\n    CSSPropertWhiteList: [],\n    CSSPropertBlackList: [\n        'transform', 'animation',\n    ],\n    tagBlackList: [\n        'noscript', 'font', 'frameset', 'iframe', 'frame', 'canvas',\n    ],\n    tagWhiteList: [],\n    noChildElement: [\n        'img', 'canvas', 'input', 'textarea', 'audio',\n        'video', 'hr', 'embed', 'object', 'progress',\n    ],\n};\nfunction mergeWithDefaultConfig(config) {\n    Object.keys(generateRenderTreeOptions).forEach((option) => {\n        if (typeof config[option] !== 'undefined') {\n            if (Array.isArray(generateRenderTreeOptions[option])) {\n                config[option] = [...generateRenderTreeOptions[option], ...config[option]];\n            }\n        }\n        else {\n            config[option] = generateRenderTreeOptions[option];\n        }\n    });\n    return config;\n}\nconst strictlyEqualOption = {\n    attrs: {\n        isStrictlyEqual: true,\n    },\n    isTagStrictlyEqaul: true,\n    isIdStrictlyEqual: true,\n    isClassStrictlyEqual: true,\n    style: {\n        display: true,\n        boxSizing: true,\n        color: true,\n        backgroundColor: true,\n        zIndex: true,\n    },\n    rectTolerance: 0,\n};\n\n\n//# sourceURL=webpack://window.Diff/./lib/config.ts?");

/***/ }),

/***/ "./lib/const.ts":
/*!**********************!*\
  !*** ./lib/const.ts ***!
  \**********************/
/*! exports provided: USER_STYLE_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"USER_STYLE_ID\", function() { return USER_STYLE_ID; });\nconst USER_STYLE_ID = 'userStyle';\n\n\n//# sourceURL=webpack://window.Diff/./lib/const.ts?");

/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/*! exports provided: generateRenderTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RenderTree_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderTree/index */ \"./lib/RenderTree/index.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"generateRenderTree\", function() { return _RenderTree_index__WEBPACK_IMPORTED_MODULE_0__[\"generateTree\"]; });\n\n\n\n\n//# sourceURL=webpack://window.Diff/./lib/index.ts?");

/***/ }),

/***/ "./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/*! exports provided: createEmptyNode, createTextNode, isElement, createHTMLTpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEmptyNode\", function() { return createEmptyNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextNode\", function() { return createTextNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isElement\", function() { return isElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createHTMLTpl\", function() { return createHTMLTpl; });\n/* harmony import */ var _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @surpass/common/types/domCore */ \"../common/types/domCore.ts\");\n/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const */ \"./lib/const.ts\");\n\n\nfunction createEmptyNode(tagName = 'div') {\n    return {\n        attr: {},\n        rect: { top: 0, left: 0, width: 0, height: 0, y: 0, x: 0 },\n        tagName,\n        nodeType: _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].ELEMENT_NODE,\n        style: {},\n    };\n}\nfunction createTextNode(text = '') {\n    return {\n        text,\n        nodeType: _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].TEXT_NODE,\n    };\n}\nfunction isElement(elem) {\n    return elem.nodeType === _surpass_common_types_domCore__WEBPACK_IMPORTED_MODULE_0__[\"NodeType\"].ELEMENT_NODE;\n}\nfunction createHTMLTpl(fragment, stylesheet) {\n    return [\n        '<!DOCTYPE html>',\n        '<html lang=\"en\">',\n        '<head>',\n        '  <meta charset=\"UTF-8\">',\n        '  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">',\n        '  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">',\n        '  <title>Document</title>',\n        '  <link href=\"https://cdn.bootcss.com/normalize/8.0.1/normalize.min.css\" rel=\"stylesheet\">',\n        `  <style id=\"${_const__WEBPACK_IMPORTED_MODULE_1__[\"USER_STYLE_ID\"]}\">`,\n        `    ${stylesheet}`,\n        '  </style>',\n        '</head>',\n        '<body>',\n        `    ${fragment}`,\n        '</body>',\n        '</html>'\n    ].join('\\n');\n}\n\n\n//# sourceURL=webpack://window.Diff/./lib/utils.ts?");

/***/ }),

/***/ "./node_modules/css-tree/dist/csstree.js":
/*!***********************************************!*\
  !*** ./node_modules/css-tree/dist/csstree.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? module.exports = factory() :\n    undefined;\n}(this, function () { 'use strict';\n\n    //\n    //                              list\n    //                            ┌──────┐\n    //             ┌──────────────┼─head │\n    //             │              │ tail─┼──────────────┐\n    //             │              └──────┘              │\n    //             ▼                                    ▼\n    //            item        item        item        item\n    //          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐\n    //  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │\n    //          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null\n    //          ├──────┤    ├──────┤    ├──────┤    ├──────┤\n    //          │ data │    │ data │    │ data │    │ data │\n    //          └──────┘    └──────┘    └──────┘    └──────┘\n    //\n\n    function createItem(data) {\n        return {\n            prev: null,\n            next: null,\n            data: data\n        };\n    }\n\n    function allocateCursor(node, prev, next) {\n        var cursor;\n\n        if (cursors !== null) {\n            cursor = cursors;\n            cursors = cursors.cursor;\n            cursor.prev = prev;\n            cursor.next = next;\n            cursor.cursor = node.cursor;\n        } else {\n            cursor = {\n                prev: prev,\n                next: next,\n                cursor: node.cursor\n            };\n        }\n\n        node.cursor = cursor;\n\n        return cursor;\n    }\n\n    function releaseCursor(node) {\n        var cursor = node.cursor;\n\n        node.cursor = cursor.cursor;\n        cursor.prev = null;\n        cursor.next = null;\n        cursor.cursor = cursors;\n        cursors = cursor;\n    }\n\n    var cursors = null;\n    var List = function() {\n        this.cursor = null;\n        this.head = null;\n        this.tail = null;\n    };\n\n    List.createItem = createItem;\n    List.prototype.createItem = createItem;\n\n    List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {\n        var cursor = this.cursor;\n\n        while (cursor !== null) {\n            if (cursor.prev === prevOld) {\n                cursor.prev = prevNew;\n            }\n\n            if (cursor.next === nextOld) {\n                cursor.next = nextNew;\n            }\n\n            cursor = cursor.cursor;\n        }\n    };\n\n    List.prototype.getSize = function() {\n        var size = 0;\n        var cursor = this.head;\n\n        while (cursor) {\n            size++;\n            cursor = cursor.next;\n        }\n\n        return size;\n    };\n\n    List.prototype.fromArray = function(array) {\n        var cursor = null;\n\n        this.head = null;\n\n        for (var i = 0; i < array.length; i++) {\n            var item = createItem(array[i]);\n\n            if (cursor !== null) {\n                cursor.next = item;\n            } else {\n                this.head = item;\n            }\n\n            item.prev = cursor;\n            cursor = item;\n        }\n\n        this.tail = cursor;\n\n        return this;\n    };\n\n    List.prototype.toArray = function() {\n        var cursor = this.head;\n        var result = [];\n\n        while (cursor) {\n            result.push(cursor.data);\n            cursor = cursor.next;\n        }\n\n        return result;\n    };\n\n    List.prototype.toJSON = List.prototype.toArray;\n\n    List.prototype.isEmpty = function() {\n        return this.head === null;\n    };\n\n    List.prototype.first = function() {\n        return this.head && this.head.data;\n    };\n\n    List.prototype.last = function() {\n        return this.tail && this.tail.data;\n    };\n\n    List.prototype.each = function(fn, context) {\n        var item;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        // push cursor\n        var cursor = allocateCursor(this, null, this.head);\n\n        while (cursor.next !== null) {\n            item = cursor.next;\n            cursor.next = item.next;\n\n            fn.call(context, item.data, item, this);\n        }\n\n        // pop cursor\n        releaseCursor(this);\n    };\n\n    List.prototype.forEach = List.prototype.each;\n\n    List.prototype.eachRight = function(fn, context) {\n        var item;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        // push cursor\n        var cursor = allocateCursor(this, this.tail, null);\n\n        while (cursor.prev !== null) {\n            item = cursor.prev;\n            cursor.prev = item.prev;\n\n            fn.call(context, item.data, item, this);\n        }\n\n        // pop cursor\n        releaseCursor(this);\n    };\n\n    List.prototype.forEachRight = List.prototype.eachRight;\n\n    List.prototype.nextUntil = function(start, fn, context) {\n        if (start === null) {\n            return;\n        }\n\n        var item;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        // push cursor\n        var cursor = allocateCursor(this, null, start);\n\n        while (cursor.next !== null) {\n            item = cursor.next;\n            cursor.next = item.next;\n\n            if (fn.call(context, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        releaseCursor(this);\n    };\n\n    List.prototype.prevUntil = function(start, fn, context) {\n        if (start === null) {\n            return;\n        }\n\n        var item;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        // push cursor\n        var cursor = allocateCursor(this, start, null);\n\n        while (cursor.prev !== null) {\n            item = cursor.prev;\n            cursor.prev = item.prev;\n\n            if (fn.call(context, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        releaseCursor(this);\n    };\n\n    List.prototype.some = function(fn, context) {\n        var cursor = this.head;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        while (cursor !== null) {\n            if (fn.call(context, cursor.data, cursor, this)) {\n                return true;\n            }\n\n            cursor = cursor.next;\n        }\n\n        return false;\n    };\n\n    List.prototype.map = function(fn, context) {\n        var result = new List();\n        var cursor = this.head;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        while (cursor !== null) {\n            result.appendData(fn.call(context, cursor.data, cursor, this));\n            cursor = cursor.next;\n        }\n\n        return result;\n    };\n\n    List.prototype.filter = function(fn, context) {\n        var result = new List();\n        var cursor = this.head;\n\n        if (context === undefined) {\n            context = this;\n        }\n\n        while (cursor !== null) {\n            if (fn.call(context, cursor.data, cursor, this)) {\n                result.appendData(cursor.data);\n            }\n            cursor = cursor.next;\n        }\n\n        return result;\n    };\n\n    List.prototype.clear = function() {\n        this.head = null;\n        this.tail = null;\n    };\n\n    List.prototype.copy = function() {\n        var result = new List();\n        var cursor = this.head;\n\n        while (cursor !== null) {\n            result.insert(createItem(cursor.data));\n            cursor = cursor.next;\n        }\n\n        return result;\n    };\n\n    List.prototype.prepend = function(item) {\n        //      head\n        //    ^\n        // item\n        this.updateCursors(null, item, this.head, item);\n\n        // insert to the beginning of the list\n        if (this.head !== null) {\n            // new item <- first item\n            this.head.prev = item;\n\n            // new item -> first item\n            item.next = this.head;\n        } else {\n            // if list has no head, then it also has no tail\n            // in this case tail points to the new item\n            this.tail = item;\n        }\n\n        // head always points to new item\n        this.head = item;\n\n        return this;\n    };\n\n    List.prototype.prependData = function(data) {\n        return this.prepend(createItem(data));\n    };\n\n    List.prototype.append = function(item) {\n        return this.insert(item);\n    };\n\n    List.prototype.appendData = function(data) {\n        return this.insert(createItem(data));\n    };\n\n    List.prototype.insert = function(item, before) {\n        if (before !== undefined && before !== null) {\n            // prev   before\n            //      ^\n            //     item\n            this.updateCursors(before.prev, item, before, item);\n\n            if (before.prev === null) {\n                // insert to the beginning of list\n                if (this.head !== before) {\n                    throw new Error('before doesn\\'t belong to list');\n                }\n\n                // since head points to before therefore list doesn't empty\n                // no need to check tail\n                this.head = item;\n                before.prev = item;\n                item.next = before;\n\n                this.updateCursors(null, item);\n            } else {\n\n                // insert between two items\n                before.prev.next = item;\n                item.prev = before.prev;\n\n                before.prev = item;\n                item.next = before;\n            }\n        } else {\n            // tail\n            //      ^\n            //      item\n            this.updateCursors(this.tail, item, null, item);\n\n            // insert to the ending of the list\n            if (this.tail !== null) {\n                // last item -> new item\n                this.tail.next = item;\n\n                // last item <- new item\n                item.prev = this.tail;\n            } else {\n                // if list has no tail, then it also has no head\n                // in this case head points to new item\n                this.head = item;\n            }\n\n            // tail always points to new item\n            this.tail = item;\n        }\n\n        return this;\n    };\n\n    List.prototype.insertData = function(data, before) {\n        return this.insert(createItem(data), before);\n    };\n\n    List.prototype.remove = function(item) {\n        //      item\n        //       ^\n        // prev     next\n        this.updateCursors(item, item.prev, item, item.next);\n\n        if (item.prev !== null) {\n            item.prev.next = item.next;\n        } else {\n            if (this.head !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.head = item.next;\n        }\n\n        if (item.next !== null) {\n            item.next.prev = item.prev;\n        } else {\n            if (this.tail !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.tail = item.prev;\n        }\n\n        item.prev = null;\n        item.next = null;\n\n        return item;\n    };\n\n    List.prototype.push = function(data) {\n        this.insert(createItem(data));\n    };\n\n    List.prototype.pop = function() {\n        if (this.tail !== null) {\n            return this.remove(this.tail);\n        }\n    };\n\n    List.prototype.unshift = function(data) {\n        this.prepend(createItem(data));\n    };\n\n    List.prototype.shift = function() {\n        if (this.head !== null) {\n            return this.remove(this.head);\n        }\n    };\n\n    List.prototype.prependList = function(list) {\n        return this.insertList(list, this.head);\n    };\n\n    List.prototype.appendList = function(list) {\n        return this.insertList(list);\n    };\n\n    List.prototype.insertList = function(list, before) {\n        // ignore empty lists\n        if (list.head === null) {\n            return this;\n        }\n\n        if (before !== undefined && before !== null) {\n            this.updateCursors(before.prev, list.tail, before, list.head);\n\n            // insert in the middle of dist list\n            if (before.prev !== null) {\n                // before.prev <-> list.head\n                before.prev.next = list.head;\n                list.head.prev = before.prev;\n            } else {\n                this.head = list.head;\n            }\n\n            before.prev = list.tail;\n            list.tail.next = before;\n        } else {\n            this.updateCursors(this.tail, list.tail, null, list.head);\n\n            // insert to end of the list\n            if (this.tail !== null) {\n                // if destination list has a tail, then it also has a head,\n                // but head doesn't change\n\n                // dest tail -> source head\n                this.tail.next = list.head;\n\n                // dest tail <- source head\n                list.head.prev = this.tail;\n            } else {\n                // if list has no a tail, then it also has no a head\n                // in this case points head to new item\n                this.head = list.head;\n            }\n\n            // tail always start point to new item\n            this.tail = list.tail;\n        }\n\n        list.head = null;\n        list.tail = null;\n\n        return this;\n    };\n\n    List.prototype.replace = function(oldItem, newItemOrList) {\n        if ('head' in newItemOrList) {\n            this.insertList(newItemOrList, oldItem);\n        } else {\n            this.insert(newItemOrList, oldItem);\n        }\n\n        this.remove(oldItem);\n    };\n\n    var List_1 = List;\n\n    var createCustomError = function createCustomError(name, message) {\n        // use Object.create(), because some VMs prevent setting line/column otherwise\n        // (iOS Safari 10 even throws an exception)\n        var error = Object.create(SyntaxError.prototype);\n        var errorStack = new Error();\n\n        error.name = name;\n        error.message = message;\n\n        Object.defineProperty(error, 'stack', {\n            get: function() {\n                return (errorStack.stack || '').replace(/^(.+\\n){1,3}/, name + ': ' + message + '\\n');\n            }\n        });\n\n        return error;\n    };\n\n    var MAX_LINE_LENGTH = 100;\n    var OFFSET_CORRECTION = 60;\n    var TAB_REPLACEMENT = '    ';\n\n    function sourceFragment(error, extraLines) {\n        function processLines(start, end) {\n            return lines.slice(start, end).map(function(line, idx) {\n                var num = String(start + idx + 1);\n\n                while (num.length < maxNumLength) {\n                    num = ' ' + num;\n                }\n\n                return num + ' |' + line;\n            }).join('\\n');\n        }\n\n        var lines = error.source.split(/\\r\\n?|\\n|\\f/);\n        var line = error.line;\n        var column = error.column;\n        var startLine = Math.max(1, line - extraLines) - 1;\n        var endLine = Math.min(line + extraLines, lines.length + 1);\n        var maxNumLength = Math.max(4, String(endLine).length) + 1;\n        var cutLeft = 0;\n\n        // column correction according to replaced tab before column\n        column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n        if (column > MAX_LINE_LENGTH) {\n            cutLeft = column - OFFSET_CORRECTION + 3;\n            column = OFFSET_CORRECTION - 2;\n        }\n\n        for (var i = startLine; i <= endLine; i++) {\n            if (i >= 0 && i < lines.length) {\n                lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n                lines[i] =\n                    (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n                    lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n                    (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n            }\n        }\n\n        return [\n            processLines(startLine, line),\n            new Array(column + maxNumLength + 2).join('-') + '^',\n            processLines(line, endLine)\n        ].filter(Boolean).join('\\n');\n    }\n\n    var SyntaxError$1 = function(message, source, offset, line, column) {\n        var error = createCustomError('SyntaxError', message);\n\n        error.source = source;\n        error.offset = offset;\n        error.line = line;\n        error.column = column;\n\n        error.sourceFragment = function(extraLines) {\n            return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);\n        };\n        Object.defineProperty(error, 'formattedMessage', {\n            get: function() {\n                return (\n                    'Parse error: ' + error.message + '\\n' +\n                    sourceFragment(error, 2)\n                );\n            }\n        });\n\n        // for backward capability\n        error.parseError = {\n            offset: offset,\n            line: line,\n            column: column\n        };\n\n        return error;\n    };\n\n    var _SyntaxError = SyntaxError$1;\n\n    // CSS Syntax Module Level 3\n    // https://www.w3.org/TR/css-syntax-3/\n    var TYPE = {\n        EOF: 0,                 // <EOF-token>\n        Ident: 1,               // <ident-token>\n        Function: 2,            // <function-token>\n        AtKeyword: 3,           // <at-keyword-token>\n        Hash: 4,                // <hash-token>\n        String: 5,              // <string-token>\n        BadString: 6,           // <bad-string-token>\n        Url: 7,                 // <url-token>\n        BadUrl: 8,              // <bad-url-token>\n        Delim: 9,               // <delim-token>\n        Number: 10,             // <number-token>\n        Percentage: 11,         // <percentage-token>\n        Dimension: 12,          // <dimension-token>\n        WhiteSpace: 13,         // <whitespace-token>\n        CDO: 14,                // <CDO-token>\n        CDC: 15,                // <CDC-token>\n        Colon: 16,              // <colon-token>     :\n        Semicolon: 17,          // <semicolon-token> ;\n        Comma: 18,              // <comma-token>     ,\n        LeftSquareBracket: 19,  // <[-token>\n        RightSquareBracket: 20, // <]-token>\n        LeftParenthesis: 21,    // <(-token>\n        RightParenthesis: 22,   // <)-token>\n        LeftCurlyBracket: 23,   // <{-token>\n        RightCurlyBracket: 24,  // <}-token>\n        Comment: 25\n    };\n\n    var NAME = Object.keys(TYPE).reduce(function(result, key) {\n        result[TYPE[key]] = key;\n        return result;\n    }, {});\n\n    var _const = {\n        TYPE: TYPE,\n        NAME: NAME\n    };\n\n    var EOF = 0;\n\n    // https://drafts.csswg.org/css-syntax-3/\n    // § 4.2. Definitions\n\n    // digit\n    // A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\n    function isDigit(code) {\n        return code >= 0x0030 && code <= 0x0039;\n    }\n\n    // hex digit\n    // A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n    // or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\n    function isHexDigit(code) {\n        return (\n            isDigit(code) || // 0 .. 9\n            (code >= 0x0041 && code <= 0x0046) || // A .. F\n            (code >= 0x0061 && code <= 0x0066)    // a .. f\n        );\n    }\n\n    // uppercase letter\n    // A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\n    function isUppercaseLetter(code) {\n        return code >= 0x0041 && code <= 0x005A;\n    }\n\n    // lowercase letter\n    // A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\n    function isLowercaseLetter(code) {\n        return code >= 0x0061 && code <= 0x007A;\n    }\n\n    // letter\n    // An uppercase letter or a lowercase letter.\n    function isLetter(code) {\n        return isUppercaseLetter(code) || isLowercaseLetter(code);\n    }\n\n    // non-ASCII code point\n    // A code point with a value equal to or greater than U+0080 <control>.\n    function isNonAscii(code) {\n        return code >= 0x0080;\n    }\n\n    // name-start code point\n    // A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n    function isNameStart(code) {\n        return isLetter(code) || isNonAscii(code) || code === 0x005F;\n    }\n\n    // name code point\n    // A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\n    function isName(code) {\n        return isNameStart(code) || isDigit(code) || code === 0x002D;\n    }\n\n    // non-printable code point\n    // A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n    // or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\n    function isNonPrintable(code) {\n        return (\n            (code >= 0x0000 && code <= 0x0008) ||\n            (code === 0x000B) ||\n            (code >= 0x000E && code <= 0x001F) ||\n            (code === 0x007F)\n        );\n    }\n\n    // newline\n    // U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n    // as they are converted to U+000A LINE FEED during preprocessing.\n    // TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\n    function isNewline(code) {\n        return code === 0x000A || code === 0x000D || code === 0x000C;\n    }\n\n    // whitespace\n    // A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\n    function isWhiteSpace(code) {\n        return isNewline(code) || code === 0x0020 || code === 0x0009;\n    }\n\n    // § 4.3.8. Check if two code points are a valid escape\n    function isValidEscape(first, second) {\n        // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n        if (first !== 0x005C) {\n            return false;\n        }\n\n        // Otherwise, if the second code point is a newline or EOF, return false.\n        if (isNewline(second) || second === EOF) {\n            return false;\n        }\n\n        // Otherwise, return true.\n        return true;\n    }\n\n    // § 4.3.9. Check if three code points would start an identifier\n    function isIdentifierStart(first, second, third) {\n        // Look at the first code point:\n\n        // U+002D HYPHEN-MINUS\n        if (first === 0x002D) {\n            // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n            // or the second and third code points are a valid escape, return true. Otherwise, return false.\n            return (\n                isNameStart(second) ||\n                second === 0x002D ||\n                isValidEscape(second, third)\n            );\n        }\n\n        // name-start code point\n        if (isNameStart(first)) {\n            // Return true.\n            return true;\n        }\n\n        // U+005C REVERSE SOLIDUS (\\)\n        if (first === 0x005C) {\n            // If the first and second code points are a valid escape, return true. Otherwise, return false.\n            return isValidEscape(first, second);\n        }\n\n        // anything else\n        // Return false.\n        return false;\n    }\n\n    // § 4.3.10. Check if three code points would start a number\n    function isNumberStart(first, second, third) {\n        // Look at the first code point:\n\n        // U+002B PLUS SIGN (+)\n        // U+002D HYPHEN-MINUS (-)\n        if (first === 0x002B || first === 0x002D) {\n            // If the second code point is a digit, return true.\n            if (isDigit(second)) {\n                return 2;\n            }\n\n            // Otherwise, if the second code point is a U+002E FULL STOP (.)\n            // and the third code point is a digit, return true.\n            // Otherwise, return false.\n            return second === 0x002E && isDigit(third) ? 3 : 0;\n        }\n\n        // U+002E FULL STOP (.)\n        if (first === 0x002E) {\n            // If the second code point is a digit, return true. Otherwise, return false.\n            return isDigit(second) ? 2 : 0;\n        }\n\n        // digit\n        if (isDigit(first)) {\n            // Return true.\n            return 1;\n        }\n\n        // anything else\n        // Return false.\n        return 0;\n    }\n\n    //\n    // Misc\n    //\n\n    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\n    function isBOM(code) {\n        // UTF-16BE\n        if (code === 0xFEFF) {\n            return 1;\n        }\n\n        // UTF-16LE\n        if (code === 0xFFFE) {\n            return 1;\n        }\n\n        return 0;\n    }\n\n    // Fast code category\n    //\n    // https://drafts.csswg.org/css-syntax/#tokenizer-definitions\n    // > non-ASCII code point\n    // >   A code point with a value equal to or greater than U+0080 <control>\n    // > name-start code point\n    // >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n    // > name code point\n    // >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)\n    // That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only\n    var CATEGORY = new Array(0x80);\n    charCodeCategory.Eof = 0x80;\n    charCodeCategory.WhiteSpace = 0x82;\n    charCodeCategory.Digit = 0x83;\n    charCodeCategory.NameStart = 0x84;\n    charCodeCategory.NonPrintable = 0x85;\n\n    for (var i = 0; i < CATEGORY.length; i++) {\n        switch (true) {\n            case isWhiteSpace(i):\n                CATEGORY[i] = charCodeCategory.WhiteSpace;\n                break;\n\n            case isDigit(i):\n                CATEGORY[i] = charCodeCategory.Digit;\n                break;\n\n            case isNameStart(i):\n                CATEGORY[i] = charCodeCategory.NameStart;\n                break;\n\n            case isNonPrintable(i):\n                CATEGORY[i] = charCodeCategory.NonPrintable;\n                break;\n\n            default:\n                CATEGORY[i] = i || charCodeCategory.Eof;\n        }\n    }\n\n    function charCodeCategory(code) {\n        return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;\n    }\n    var charCodeDefinitions = {\n        isDigit: isDigit,\n        isHexDigit: isHexDigit,\n        isUppercaseLetter: isUppercaseLetter,\n        isLowercaseLetter: isLowercaseLetter,\n        isLetter: isLetter,\n        isNonAscii: isNonAscii,\n        isNameStart: isNameStart,\n        isName: isName,\n        isNonPrintable: isNonPrintable,\n        isNewline: isNewline,\n        isWhiteSpace: isWhiteSpace,\n        isValidEscape: isValidEscape,\n        isIdentifierStart: isIdentifierStart,\n        isNumberStart: isNumberStart,\n\n        isBOM: isBOM,\n        charCodeCategory: charCodeCategory\n    };\n\n    var isDigit$1 = charCodeDefinitions.isDigit;\n    var isHexDigit$1 = charCodeDefinitions.isHexDigit;\n    var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;\n    var isName$1 = charCodeDefinitions.isName;\n    var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;\n    var isValidEscape$1 = charCodeDefinitions.isValidEscape;\n\n    function getCharCode(source, offset) {\n        return offset < source.length ? source.charCodeAt(offset) : 0;\n    }\n\n    function getNewlineLength(source, offset, code) {\n        if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n            return 2;\n        }\n\n        return 1;\n    }\n\n    function cmpChar(testStr, offset, referenceCode) {\n        var code = testStr.charCodeAt(offset);\n\n        // code.toLowerCase() for A..Z\n        if (isUppercaseLetter$1(code)) {\n            code = code | 32;\n        }\n\n        return code === referenceCode;\n    }\n\n    function cmpStr(testStr, start, end, referenceStr) {\n        if (end - start !== referenceStr.length) {\n            return false;\n        }\n\n        if (start < 0 || end > testStr.length) {\n            return false;\n        }\n\n        for (var i = start; i < end; i++) {\n            var testCode = testStr.charCodeAt(i);\n            var referenceCode = referenceStr.charCodeAt(i - start);\n\n            // testCode.toLowerCase() for A..Z\n            if (isUppercaseLetter$1(testCode)) {\n                testCode = testCode | 32;\n            }\n\n            if (testCode !== referenceCode) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function findWhiteSpaceStart(source, offset) {\n        for (; offset >= 0; offset--) {\n            if (!isWhiteSpace$1(source.charCodeAt(offset))) {\n                break;\n            }\n        }\n\n        return offset + 1;\n    }\n\n    function findWhiteSpaceEnd(source, offset) {\n        for (; offset < source.length; offset++) {\n            if (!isWhiteSpace$1(source.charCodeAt(offset))) {\n                break;\n            }\n        }\n\n        return offset;\n    }\n\n    function findDecimalNumberEnd(source, offset) {\n        for (; offset < source.length; offset++) {\n            if (!isDigit$1(source.charCodeAt(offset))) {\n                break;\n            }\n        }\n\n        return offset;\n    }\n\n    // § 4.3.7. Consume an escaped code point\n    function consumeEscaped(source, offset) {\n        // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n        // that the next input code point has already been verified to be part of a valid escape.\n        offset += 2;\n\n        // hex digit\n        if (isHexDigit$1(getCharCode(source, offset - 1))) {\n            // Consume as many hex digits as possible, but no more than 5.\n            // Note that this means 1-6 hex digits have been consumed in total.\n            for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n                if (!isHexDigit$1(getCharCode(source, offset))) {\n                    break;\n                }\n            }\n\n            // If the next input code point is whitespace, consume it as well.\n            var code = getCharCode(source, offset);\n            if (isWhiteSpace$1(code)) {\n                offset += getNewlineLength(source, offset, code);\n            }\n        }\n\n        return offset;\n    }\n\n    // §4.3.11. Consume a name\n    // Note: This algorithm does not do the verification of the first few code points that are necessary\n    // to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n    // ensure that the stream starts with an identifier before calling this algorithm.\n    function consumeName(source, offset) {\n        // Let result initially be an empty string.\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            var code = source.charCodeAt(offset);\n\n            // name code point\n            if (isName$1(code)) {\n                // Append the code point to result.\n                continue;\n            }\n\n            // the stream starts with a valid escape\n            if (isValidEscape$1(code, getCharCode(source, offset + 1))) {\n                // Consume an escaped code point. Append the returned code point to result.\n                offset = consumeEscaped(source, offset) - 1;\n                continue;\n            }\n\n            // anything else\n            // Reconsume the current input code point. Return result.\n            break;\n        }\n\n        return offset;\n    }\n\n    // §4.3.12. Consume a number\n    function consumeNumber(source, offset) {\n        var code = source.charCodeAt(offset);\n\n        // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n        // consume it and append it to repr.\n        if (code === 0x002B || code === 0x002D) {\n            code = source.charCodeAt(offset += 1);\n        }\n\n        // 3. While the next input code point is a digit, consume it and append it to repr.\n        if (isDigit$1(code)) {\n            offset = findDecimalNumberEnd(source, offset + 1);\n            code = source.charCodeAt(offset);\n        }\n\n        // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n        if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {\n            // 4.1 Consume them.\n            // 4.2 Append them to repr.\n            code = source.charCodeAt(offset += 2);\n\n            // 4.3 Set type to \"number\".\n            // TODO\n\n            // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n            offset = findDecimalNumberEnd(source, offset);\n        }\n\n        // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n        // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n        if (cmpChar(source, offset, 101 /* e */)) {\n            var sign = 0;\n            code = source.charCodeAt(offset + 1);\n\n            // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n            if (code === 0x002D || code === 0x002B) {\n                sign = 1;\n                code = source.charCodeAt(offset + 2);\n            }\n\n            // ... followed by a digit\n            if (isDigit$1(code)) {\n                // 5.1 Consume them.\n                // 5.2 Append them to repr.\n\n                // 5.3 Set type to \"number\".\n                // TODO\n\n                // 5.4 While the next input code point is a digit, consume it and append it to repr.\n                offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n            }\n        }\n\n        return offset;\n    }\n\n    // § 4.3.14. Consume the remnants of a bad url\n    // ... its sole use is to consume enough of the input stream to reach a recovery point\n    // where normal tokenizing can resume.\n    function consumeBadUrlRemnants(source, offset) {\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            var code = source.charCodeAt(offset);\n\n            // U+0029 RIGHT PARENTHESIS ())\n            // EOF\n            if (code === 0x0029) {\n                // Return.\n                offset++;\n                break;\n            }\n\n            if (isValidEscape$1(code, getCharCode(source, offset + 1))) {\n                // Consume an escaped code point.\n                // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n                // without ending the <bad-url-token>. This is otherwise identical to\n                // the \"anything else\" clause.\n                offset = consumeEscaped(source, offset);\n            }\n        }\n\n        return offset;\n    }\n\n    var utils = {\n        consumeEscaped: consumeEscaped,\n        consumeName: consumeName,\n        consumeNumber: consumeNumber,\n        consumeBadUrlRemnants: consumeBadUrlRemnants,\n\n        cmpChar: cmpChar,\n        cmpStr: cmpStr,\n\n        getNewlineLength: getNewlineLength,\n        findWhiteSpaceStart: findWhiteSpaceStart,\n        findWhiteSpaceEnd: findWhiteSpaceEnd\n    };\n\n    var TYPE$1 = _const.TYPE;\n    var NAME$1 = _const.NAME;\n\n\n    var cmpStr$1 = utils.cmpStr;\n\n    var EOF$1 = TYPE$1.EOF;\n    var WHITESPACE = TYPE$1.WhiteSpace;\n    var COMMENT = TYPE$1.Comment;\n\n    var OFFSET_MASK = 0x00FFFFFF;\n    var TYPE_SHIFT = 24;\n\n    var TokenStream = function() {\n        this.offsetAndType = null;\n        this.balance = null;\n\n        this.reset();\n    };\n\n    TokenStream.prototype = {\n        reset: function() {\n            this.eof = false;\n            this.tokenIndex = -1;\n            this.tokenType = 0;\n            this.tokenStart = this.firstCharOffset;\n            this.tokenEnd = this.firstCharOffset;\n        },\n\n        lookupType: function(offset) {\n            offset += this.tokenIndex;\n\n            if (offset < this.tokenCount) {\n                return this.offsetAndType[offset] >> TYPE_SHIFT;\n            }\n\n            return EOF$1;\n        },\n        lookupOffset: function(offset) {\n            offset += this.tokenIndex;\n\n            if (offset < this.tokenCount) {\n                return this.offsetAndType[offset - 1] & OFFSET_MASK;\n            }\n\n            return this.source.length;\n        },\n        lookupValue: function(offset, referenceStr) {\n            offset += this.tokenIndex;\n\n            if (offset < this.tokenCount) {\n                return cmpStr$1(\n                    this.source,\n                    this.offsetAndType[offset - 1] & OFFSET_MASK,\n                    this.offsetAndType[offset] & OFFSET_MASK,\n                    referenceStr\n                );\n            }\n\n            return false;\n        },\n        getTokenStart: function(tokenIndex) {\n            if (tokenIndex === this.tokenIndex) {\n                return this.tokenStart;\n            }\n\n            if (tokenIndex > 0) {\n                return tokenIndex < this.tokenCount\n                    ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                    : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n            }\n\n            return this.firstCharOffset;\n        },\n\n        // TODO: -> skipUntilBalanced\n        getRawLength: function(startToken, mode) {\n            var cursor = startToken;\n            var balanceEnd;\n            var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n            var type;\n\n            loop:\n            for (; cursor < this.tokenCount; cursor++) {\n                balanceEnd = this.balance[cursor];\n\n                // stop scanning on balance edge that points to offset before start token\n                if (balanceEnd < startToken) {\n                    break loop;\n                }\n\n                type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n                // check token is stop type\n                switch (mode(type, this.source, offset)) {\n                    case 1:\n                        break loop;\n\n                    case 2:\n                        cursor++;\n                        break loop;\n\n                    default:\n                        offset = this.offsetAndType[cursor] & OFFSET_MASK;\n\n                        // fast forward to the end of balanced block\n                        if (this.balance[balanceEnd] === cursor) {\n                            cursor = balanceEnd;\n                        }\n                }\n            }\n\n            return cursor - this.tokenIndex;\n        },\n        isBalanceEdge: function(pos) {\n            return this.balance[this.tokenIndex] < pos;\n        },\n        isDelim: function(code, offset) {\n            if (offset) {\n                return (\n                    this.lookupType(offset) === TYPE$1.Delim &&\n                    this.source.charCodeAt(this.lookupOffset(offset)) === code\n                );\n            }\n\n            return (\n                this.tokenType === TYPE$1.Delim &&\n                this.source.charCodeAt(this.tokenStart) === code\n            );\n        },\n\n        getTokenValue: function() {\n            return this.source.substring(this.tokenStart, this.tokenEnd);\n        },\n        getTokenLength: function() {\n            return this.tokenEnd - this.tokenStart;\n        },\n        substrToCursor: function(start) {\n            return this.source.substring(start, this.tokenStart);\n        },\n\n        skipWS: function() {\n            for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n                if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {\n                    break;\n                }\n            }\n\n            if (skipTokenCount > 0) {\n                this.skip(skipTokenCount);\n            }\n        },\n        skipSC: function() {\n            while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n                this.next();\n            }\n        },\n        skip: function(tokenCount) {\n            var next = this.tokenIndex + tokenCount;\n\n            if (next < this.tokenCount) {\n                this.tokenIndex = next;\n                this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n                next = this.offsetAndType[next];\n                this.tokenType = next >> TYPE_SHIFT;\n                this.tokenEnd = next & OFFSET_MASK;\n            } else {\n                this.tokenIndex = this.tokenCount;\n                this.next();\n            }\n        },\n        next: function() {\n            var next = this.tokenIndex + 1;\n\n            if (next < this.tokenCount) {\n                this.tokenIndex = next;\n                this.tokenStart = this.tokenEnd;\n                next = this.offsetAndType[next];\n                this.tokenType = next >> TYPE_SHIFT;\n                this.tokenEnd = next & OFFSET_MASK;\n            } else {\n                this.tokenIndex = this.tokenCount;\n                this.eof = true;\n                this.tokenType = EOF$1;\n                this.tokenStart = this.tokenEnd = this.source.length;\n            }\n        },\n\n        dump: function() {\n            var offset = this.firstCharOffset;\n\n            return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {\n                var start = offset;\n                var end = item & OFFSET_MASK;\n\n                offset = end;\n\n                return {\n                    idx: idx,\n                    type: NAME$1[item >> TYPE_SHIFT],\n                    chunk: this.source.substring(start, end),\n                    balance: this.balance[idx]\n                };\n            }, this);\n        }\n    };\n\n    var TokenStream_1 = TokenStream;\n\n    function noop(value) {\n        return value;\n    }\n\n    function generateMultiplier(multiplier) {\n        if (multiplier.min === 0 && multiplier.max === 0) {\n            return '*';\n        }\n\n        if (multiplier.min === 0 && multiplier.max === 1) {\n            return '?';\n        }\n\n        if (multiplier.min === 1 && multiplier.max === 0) {\n            return multiplier.comma ? '#' : '+';\n        }\n\n        if (multiplier.min === 1 && multiplier.max === 1) {\n            return '';\n        }\n\n        return (\n            (multiplier.comma ? '#' : '') +\n            (multiplier.min === multiplier.max\n                ? '{' + multiplier.min + '}'\n                : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'\n            )\n        );\n    }\n\n    function generateTypeOpts(node) {\n        switch (node.type) {\n            case 'Range':\n                return (\n                    ' [' +\n                    (node.min === null ? '-∞' : node.min) +\n                    ',' +\n                    (node.max === null ? '∞' : node.max) +\n                    ']'\n                );\n\n            default:\n                throw new Error('Unknown node type `' + node.type + '`');\n        }\n    }\n\n    function generateSequence(node, decorate, forceBraces, compact) {\n        var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';\n        var result = node.terms.map(function(term) {\n            return generate(term, decorate, forceBraces, compact);\n        }).join(combinator);\n\n        if (node.explicit || forceBraces) {\n            result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');\n        }\n\n        return result;\n    }\n\n    function generate(node, decorate, forceBraces, compact) {\n        var result;\n\n        switch (node.type) {\n            case 'Group':\n                result =\n                    generateSequence(node, decorate, forceBraces, compact) +\n                    (node.disallowEmpty ? '!' : '');\n                break;\n\n            case 'Multiplier':\n                // return since node is a composition\n                return (\n                    generate(node.term, decorate, forceBraces, compact) +\n                    decorate(generateMultiplier(node), node)\n                );\n\n            case 'Type':\n                result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';\n                break;\n\n            case 'Property':\n                result = '<\\'' + node.name + '\\'>';\n                break;\n\n            case 'Keyword':\n                result = node.name;\n                break;\n\n            case 'AtKeyword':\n                result = '@' + node.name;\n                break;\n\n            case 'Function':\n                result = node.name + '(';\n                break;\n\n            case 'String':\n            case 'Token':\n                result = node.value;\n                break;\n\n            case 'Comma':\n                result = ',';\n                break;\n\n            default:\n                throw new Error('Unknown node type `' + node.type + '`');\n        }\n\n        return decorate(result, node);\n    }\n\n    var generate_1 = function(node, options) {\n        var decorate = noop;\n        var forceBraces = false;\n        var compact = false;\n\n        if (typeof options === 'function') {\n            decorate = options;\n        } else if (options) {\n            forceBraces = Boolean(options.forceBraces);\n            compact = Boolean(options.compact);\n            if (typeof options.decorate === 'function') {\n                decorate = options.decorate;\n            }\n        }\n\n        return generate(node, decorate, forceBraces, compact);\n    };\n\n    function fromMatchResult(matchResult) {\n        var tokens = matchResult.tokens;\n        var longestMatch = matchResult.longestMatch;\n        var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;\n        var mismatchOffset = -1;\n        var entries = 0;\n        var css = '';\n\n        for (var i = 0; i < tokens.length; i++) {\n            if (i === longestMatch) {\n                mismatchOffset = css.length;\n            }\n\n            if (node !== null && tokens[i].node === node) {\n                if (i <= longestMatch) {\n                    entries++;\n                } else {\n                    entries = 0;\n                }\n            }\n\n            css += tokens[i].value;\n        }\n\n        return {\n            node: node,\n            css: css,\n            mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,\n            last: node === null || entries > 1\n        };\n    }\n\n    function getLocation(node, point) {\n        var loc = node && node.loc && node.loc[point];\n\n        if (loc) {\n            return {\n                offset: loc.offset,\n                line: loc.line,\n                column: loc.column\n            };\n        }\n\n        return null;\n    }\n\n    var SyntaxReferenceError = function(type, referenceName) {\n        var error = createCustomError(\n            'SyntaxReferenceError',\n            type + (referenceName ? ' `' + referenceName + '`' : '')\n        );\n\n        error.reference = referenceName;\n\n        return error;\n    };\n\n    var MatchError = function(message, syntax, node, matchResult) {\n        var error = createCustomError('SyntaxMatchError', message);\n        var details = fromMatchResult(matchResult);\n        var mismatchOffset = details.mismatchOffset || 0;\n        var badNode = details.node || node;\n        var end = getLocation(badNode, 'end');\n        var start = details.last ? end : getLocation(badNode, 'start');\n        var css = details.css;\n\n        error.rawMessage = message;\n        error.syntax = syntax ? generate_1(syntax) : '<generic>';\n        error.css = css;\n        error.mismatchOffset = mismatchOffset;\n        error.loc = {\n            source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',\n            start: start,\n            end: end\n        };\n        error.line = start ? start.line : undefined;\n        error.column = start ? start.column : undefined;\n        error.offset = start ? start.offset : undefined;\n        error.message = message + '\\n' +\n            '  syntax: ' + error.syntax + '\\n' +\n            '   value: ' + (error.css || '<empty string>') + '\\n' +\n            '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n        return error;\n    };\n\n    var error = {\n        SyntaxReferenceError: SyntaxReferenceError,\n        MatchError: MatchError\n    };\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var keywords = Object.create(null);\n    var properties = Object.create(null);\n    var HYPHENMINUS = 45; // '-'.charCodeAt()\n\n    function isCustomProperty(str, offset) {\n        offset = offset || 0;\n\n        return str.length - offset >= 2 &&\n               str.charCodeAt(offset) === HYPHENMINUS &&\n               str.charCodeAt(offset + 1) === HYPHENMINUS;\n    }\n\n    function getVendorPrefix(str, offset) {\n        offset = offset || 0;\n\n        // verdor prefix should be at least 3 chars length\n        if (str.length - offset >= 3) {\n            // vendor prefix starts with hyper minus following non-hyper minus\n            if (str.charCodeAt(offset) === HYPHENMINUS &&\n                str.charCodeAt(offset + 1) !== HYPHENMINUS) {\n                // vendor prefix should contain a hyper minus at the ending\n                var secondDashIndex = str.indexOf('-', offset + 2);\n\n                if (secondDashIndex !== -1) {\n                    return str.substring(offset, secondDashIndex + 1);\n                }\n            }\n        }\n\n        return '';\n    }\n\n    function getKeywordDescriptor(keyword) {\n        if (hasOwnProperty.call(keywords, keyword)) {\n            return keywords[keyword];\n        }\n\n        var name = keyword.toLowerCase();\n\n        if (hasOwnProperty.call(keywords, name)) {\n            return keywords[keyword] = keywords[name];\n        }\n\n        var custom = isCustomProperty(name, 0);\n        var vendor = !custom ? getVendorPrefix(name, 0) : '';\n\n        return keywords[keyword] = Object.freeze({\n            basename: name.substr(vendor.length),\n            name: name,\n            vendor: vendor,\n            prefix: vendor,\n            custom: custom\n        });\n    }\n\n    function getPropertyDescriptor(property) {\n        if (hasOwnProperty.call(properties, property)) {\n            return properties[property];\n        }\n\n        var name = property;\n        var hack = property[0];\n\n        if (hack === '/') {\n            hack = property[1] === '/' ? '//' : '/';\n        } else if (hack !== '_' &&\n                   hack !== '*' &&\n                   hack !== '$' &&\n                   hack !== '#' &&\n                   hack !== '+' &&\n                   hack !== '&') {\n            hack = '';\n        }\n\n        var custom = isCustomProperty(name, hack.length);\n\n        // re-use result when possible (the same as for lower case)\n        if (!custom) {\n            name = name.toLowerCase();\n            if (hasOwnProperty.call(properties, name)) {\n                return properties[property] = properties[name];\n            }\n        }\n\n        var vendor = !custom ? getVendorPrefix(name, hack.length) : '';\n        var prefix = name.substr(0, hack.length + vendor.length);\n\n        return properties[property] = Object.freeze({\n            basename: name.substr(prefix.length),\n            name: name.substr(hack.length),\n            hack: hack,\n            vendor: vendor,\n            prefix: prefix,\n            custom: custom\n        });\n    }\n\n    var names = {\n        keyword: getKeywordDescriptor,\n        property: getPropertyDescriptor,\n        isCustomProperty: isCustomProperty,\n        vendorPrefix: getVendorPrefix\n    };\n\n    var MIN_SIZE = 16 * 1024;\n    var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported\n\n    var adoptBuffer = function adoptBuffer(buffer, size) {\n        if (buffer === null || buffer.length < size) {\n            return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));\n        }\n\n        return buffer;\n    };\n\n    var TYPE$2 = _const.TYPE;\n\n\n    var isNewline$1 = charCodeDefinitions.isNewline;\n    var isName$2 = charCodeDefinitions.isName;\n    var isValidEscape$2 = charCodeDefinitions.isValidEscape;\n    var isNumberStart$1 = charCodeDefinitions.isNumberStart;\n    var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;\n    var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;\n    var isBOM$1 = charCodeDefinitions.isBOM;\n\n\n    var cmpStr$2 = utils.cmpStr;\n    var getNewlineLength$1 = utils.getNewlineLength;\n    var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;\n    var consumeEscaped$1 = utils.consumeEscaped;\n    var consumeName$1 = utils.consumeName;\n    var consumeNumber$1 = utils.consumeNumber;\n    var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;\n\n    var OFFSET_MASK$1 = 0x00FFFFFF;\n    var TYPE_SHIFT$1 = 24;\n\n    function tokenize(source, stream) {\n        function getCharCode(offset) {\n            return offset < sourceLength ? source.charCodeAt(offset) : 0;\n        }\n\n        // § 4.3.3. Consume a numeric token\n        function consumeNumericToken() {\n            // Consume a number and let number be the result.\n            offset = consumeNumber$1(source, offset);\n\n            // If the next 3 input code points would start an identifier, then:\n            if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n                // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n                // Consume a name. Set the <dimension-token>’s unit to the returned value.\n                // Return the <dimension-token>.\n                type = TYPE$2.Dimension;\n                offset = consumeName$1(source, offset);\n                return;\n            }\n\n            // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n            if (getCharCode(offset) === 0x0025) {\n                // Create a <percentage-token> with the same value as number, and return it.\n                type = TYPE$2.Percentage;\n                offset++;\n                return;\n            }\n\n            // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n            type = TYPE$2.Number;\n        }\n\n        // § 4.3.4. Consume an ident-like token\n        function consumeIdentLikeToken() {\n            const nameStartOffset = offset;\n\n            // Consume a name, and let string be the result.\n            offset = consumeName$1(source, offset);\n\n            // If string’s value is an ASCII case-insensitive match for \"url\",\n            // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n            if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n                // While the next two input code points are whitespace, consume the next input code point.\n                offset = findWhiteSpaceEnd$1(source, offset + 1);\n\n                // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n                // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n                // then create a <function-token> with its value set to string and return it.\n                if (getCharCode(offset) === 0x0022 ||\n                    getCharCode(offset) === 0x0027) {\n                    type = TYPE$2.Function;\n                    offset = nameStartOffset + 4;\n                    return;\n                }\n\n                // Otherwise, consume a url token, and return it.\n                consumeUrlToken();\n                return;\n            }\n\n            // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n            // Create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0028) {\n                type = TYPE$2.Function;\n                offset++;\n                return;\n            }\n\n            // Otherwise, create an <ident-token> with its value set to string and return it.\n            type = TYPE$2.Ident;\n        }\n\n        // § 4.3.5. Consume a string token\n        function consumeStringToken(endingCodePoint) {\n            // This algorithm may be called with an ending code point, which denotes the code point\n            // that ends the string. If an ending code point is not specified,\n            // the current input code point is used.\n            if (!endingCodePoint) {\n                endingCodePoint = getCharCode(offset++);\n            }\n\n            // Initially create a <string-token> with its value set to the empty string.\n            type = TYPE$2.String;\n\n            // Repeatedly consume the next input code point from the stream:\n            for (; offset < source.length; offset++) {\n                var code = source.charCodeAt(offset);\n\n                switch (charCodeCategory$1(code)) {\n                    // ending code point\n                    case endingCodePoint:\n                        // Return the <string-token>.\n                        offset++;\n                        return;\n\n                    // EOF\n                    case charCodeCategory$1.Eof:\n                        // This is a parse error. Return the <string-token>.\n                        return;\n\n                    // newline\n                    case charCodeCategory$1.WhiteSpace:\n                        if (isNewline$1(code)) {\n                            // This is a parse error. Reconsume the current input code point,\n                            // create a <bad-string-token>, and return it.\n                            offset += getNewlineLength$1(source, offset, code);\n                            type = TYPE$2.BadString;\n                            return;\n                        }\n                        break;\n\n                    // U+005C REVERSE SOLIDUS (\\)\n                    case 0x005C:\n                        // If the next input code point is EOF, do nothing.\n                        if (offset === source.length - 1) {\n                            break;\n                        }\n\n                        var nextCode = getCharCode(offset + 1);\n\n                        // Otherwise, if the next input code point is a newline, consume it.\n                        if (isNewline$1(nextCode)) {\n                            offset += getNewlineLength$1(source, offset + 1, nextCode);\n                        } else if (isValidEscape$2(code, nextCode)) {\n                            // Otherwise, (the stream starts with a valid escape) consume\n                            // an escaped code point and append the returned code point to\n                            // the <string-token>’s value.\n                            offset = consumeEscaped$1(source, offset) - 1;\n                        }\n                        break;\n\n                    // anything else\n                    // Append the current input code point to the <string-token>’s value.\n                }\n            }\n        }\n\n        // § 4.3.6. Consume a url token\n        // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n        // This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n        // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n        // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n        function consumeUrlToken() {\n            // Initially create a <url-token> with its value set to the empty string.\n            type = TYPE$2.Url;\n\n            // Consume as much whitespace as possible.\n            offset = findWhiteSpaceEnd$1(source, offset);\n\n            // Repeatedly consume the next input code point from the stream:\n            for (; offset < source.length; offset++) {\n                var code = source.charCodeAt(offset);\n\n                switch (charCodeCategory$1(code)) {\n                    // U+0029 RIGHT PARENTHESIS ())\n                    case 0x0029:\n                        // Return the <url-token>.\n                        offset++;\n                        return;\n\n                    // EOF\n                    case charCodeCategory$1.Eof:\n                        // This is a parse error. Return the <url-token>.\n                        return;\n\n                    // whitespace\n                    case charCodeCategory$1.WhiteSpace:\n                        // Consume as much whitespace as possible.\n                        offset = findWhiteSpaceEnd$1(source, offset);\n\n                        // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                        // consume it and return the <url-token>\n                        // (if EOF was encountered, this is a parse error);\n                        if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                            if (offset < source.length) {\n                                offset++;\n                            }\n                            return;\n                        }\n\n                        // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                        // and return it.\n                        offset = consumeBadUrlRemnants$1(source, offset);\n                        type = TYPE$2.BadUrl;\n                        return;\n\n                    // U+0022 QUOTATION MARK (\")\n                    // U+0027 APOSTROPHE (')\n                    // U+0028 LEFT PARENTHESIS (()\n                    // non-printable code point\n                    case 0x0022:\n                    case 0x0027:\n                    case 0x0028:\n                    case charCodeCategory$1.NonPrintable:\n                        // This is a parse error. Consume the remnants of a bad url,\n                        // create a <bad-url-token>, and return it.\n                        offset = consumeBadUrlRemnants$1(source, offset);\n                        type = TYPE$2.BadUrl;\n                        return;\n\n                    // U+005C REVERSE SOLIDUS (\\)\n                    case 0x005C:\n                        // If the stream starts with a valid escape, consume an escaped code point and\n                        // append the returned code point to the <url-token>’s value.\n                        if (isValidEscape$2(code, getCharCode(offset + 1))) {\n                            offset = consumeEscaped$1(source, offset) - 1;\n                            break;\n                        }\n\n                        // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                        // create a <bad-url-token>, and return it.\n                        offset = consumeBadUrlRemnants$1(source, offset);\n                        type = TYPE$2.BadUrl;\n                        return;\n\n                    // anything else\n                    // Append the current input code point to the <url-token>’s value.\n                }\n            }\n        }\n\n        if (!stream) {\n            stream = new TokenStream_1();\n        }\n\n        // ensure source is a string\n        source = String(source || '');\n\n        var sourceLength = source.length;\n        var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token\n        var balance = adoptBuffer(stream.balance, sourceLength + 1);\n        var tokenCount = 0;\n        var start = isBOM$1(getCharCode(0));\n        var offset = start;\n        var balanceCloseType = 0;\n        var balanceStart = 0;\n        var balancePrev = 0;\n\n        // https://drafts.csswg.org/css-syntax-3/#consume-token\n        // § 4.3.1. Consume a token\n        while (offset < sourceLength) {\n            var code = source.charCodeAt(offset);\n            var type = 0;\n\n            balance[tokenCount] = sourceLength;\n\n            switch (charCodeCategory$1(code)) {\n                // whitespace\n                case charCodeCategory$1.WhiteSpace:\n                    // Consume as much whitespace as possible. Return a <whitespace-token>.\n                    type = TYPE$2.WhiteSpace;\n                    offset = findWhiteSpaceEnd$1(source, offset + 1);\n                    break;\n\n                // U+0022 QUOTATION MARK (\")\n                case 0x0022:\n                    // Consume a string token and return it.\n                    consumeStringToken();\n                    break;\n\n                // U+0023 NUMBER SIGN (#)\n                case 0x0023:\n                    // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                    if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                        // Create a <hash-token>.\n                        type = TYPE$2.Hash;\n\n                        // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to \"id\".\n                        // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                        //     // TODO: set id flag\n                        // }\n\n                        // Consume a name, and set the <hash-token>’s value to the returned string.\n                        offset = consumeName$1(source, offset + 1);\n\n                        // Return the <hash-token>.\n                    } else {\n                        // Otherwise, return a <delim-token> with its value set to the current input code point.\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n\n                    break;\n\n                // U+0027 APOSTROPHE (')\n                case 0x0027:\n                    // Consume a string token and return it.\n                    consumeStringToken();\n                    break;\n\n                // U+0028 LEFT PARENTHESIS (()\n                case 0x0028:\n                    // Return a <(-token>.\n                    type = TYPE$2.LeftParenthesis;\n                    offset++;\n                    break;\n\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return a <)-token>.\n                    type = TYPE$2.RightParenthesis;\n                    offset++;\n                    break;\n\n                // U+002B PLUS SIGN (+)\n                case 0x002B:\n                    // If the input stream starts with a number, ...\n                    if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                        // ... reconsume the current input code point, consume a numeric token, and return it.\n                        consumeNumericToken();\n                    } else {\n                        // Otherwise, return a <delim-token> with its value set to the current input code point.\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n                    break;\n\n                // U+002C COMMA (,)\n                case 0x002C:\n                    // Return a <comma-token>.\n                    type = TYPE$2.Comma;\n                    offset++;\n                    break;\n\n                // U+002D HYPHEN-MINUS (-)\n                case 0x002D:\n                    // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                    if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                        consumeNumericToken();\n                    } else {\n                        // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                        if (getCharCode(offset + 1) === 0x002D &&\n                            getCharCode(offset + 2) === 0x003E) {\n                            type = TYPE$2.CDC;\n                            offset = offset + 3;\n                        } else {\n                            // Otherwise, if the input stream starts with an identifier, ...\n                            if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                                // ... reconsume the current input code point, consume an ident-like token, and return it.\n                                consumeIdentLikeToken();\n                            } else {\n                                // Otherwise, return a <delim-token> with its value set to the current input code point.\n                                type = TYPE$2.Delim;\n                                offset++;\n                            }\n                        }\n                    }\n                    break;\n\n                // U+002E FULL STOP (.)\n                case 0x002E:\n                    // If the input stream starts with a number, ...\n                    if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                        // ... reconsume the current input code point, consume a numeric token, and return it.\n                        consumeNumericToken();\n                    } else {\n                        // Otherwise, return a <delim-token> with its value set to the current input code point.\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n\n                    break;\n\n                // U+002F SOLIDUS (/)\n                case 0x002F:\n                    // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                    if (getCharCode(offset + 1) === 0x002A) {\n                        // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                        // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                        type = TYPE$2.Comment;\n                        offset = source.indexOf('*/', offset + 2) + 2;\n                        if (offset === 1) {\n                            offset = source.length;\n                        }\n                    } else {\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n                    break;\n\n                // U+003A COLON (:)\n                case 0x003A:\n                    // Return a <colon-token>.\n                    type = TYPE$2.Colon;\n                    offset++;\n                    break;\n\n                // U+003B SEMICOLON (;)\n                case 0x003B:\n                    // Return a <semicolon-token>.\n                    type = TYPE$2.Semicolon;\n                    offset++;\n                    break;\n\n                // U+003C LESS-THAN SIGN (<)\n                case 0x003C:\n                    // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                    if (getCharCode(offset + 1) === 0x0021 &&\n                        getCharCode(offset + 2) === 0x002D &&\n                        getCharCode(offset + 3) === 0x002D) {\n                        // ... consume them and return a <CDO-token>.\n                        type = TYPE$2.CDO;\n                        offset = offset + 4;\n                    } else {\n                        // Otherwise, return a <delim-token> with its value set to the current input code point.\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n\n                    break;\n\n                // U+0040 COMMERCIAL AT (@)\n                case 0x0040:\n                    // If the next 3 input code points would start an identifier, ...\n                    if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                        // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                        type = TYPE$2.AtKeyword;\n                        offset = consumeName$1(source, offset + 1);\n                    } else {\n                        // Otherwise, return a <delim-token> with its value set to the current input code point.\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n\n                    break;\n\n                // U+005B LEFT SQUARE BRACKET ([)\n                case 0x005B:\n                    // Return a <[-token>.\n                    type = TYPE$2.LeftSquareBracket;\n                    offset++;\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the input stream starts with a valid escape, ...\n                    if (isValidEscape$2(code, getCharCode(offset + 1))) {\n                        // ... reconsume the current input code point, consume an ident-like token, and return it.\n                        consumeIdentLikeToken();\n                    } else {\n                        // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                        type = TYPE$2.Delim;\n                        offset++;\n                    }\n                    break;\n\n                // U+005D RIGHT SQUARE BRACKET (])\n                case 0x005D:\n                    // Return a <]-token>.\n                    type = TYPE$2.RightSquareBracket;\n                    offset++;\n                    break;\n\n                // U+007B LEFT CURLY BRACKET ({)\n                case 0x007B:\n                    // Return a <{-token>.\n                    type = TYPE$2.LeftCurlyBracket;\n                    offset++;\n                    break;\n\n                // U+007D RIGHT CURLY BRACKET (})\n                case 0x007D:\n                    // Return a <}-token>.\n                    type = TYPE$2.RightCurlyBracket;\n                    offset++;\n                    break;\n\n                // digit\n                case charCodeCategory$1.Digit:\n                    // Reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                    break;\n\n                // name-start code point\n                case charCodeCategory$1.NameStart:\n                    // Reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                    break;\n\n                // EOF\n                case charCodeCategory$1.Eof:\n                    // Return an <EOF-token>.\n                    break;\n\n                // anything else\n                default:\n                    // Return a <delim-token> with its value set to the current input code point.\n                    type = TYPE$2.Delim;\n                    offset++;\n            }\n\n            switch (type) {\n                case balanceCloseType:\n                    balancePrev = balanceStart & OFFSET_MASK$1;\n                    balanceStart = balance[balancePrev];\n                    balanceCloseType = balanceStart >> TYPE_SHIFT$1;\n                    balance[tokenCount] = balancePrev;\n                    balance[balancePrev++] = tokenCount;\n                    for (; balancePrev < tokenCount; balancePrev++) {\n                        if (balance[balancePrev] === sourceLength) {\n                            balance[balancePrev] = tokenCount;\n                        }\n                    }\n                    break;\n\n                case TYPE$2.LeftParenthesis:\n                case TYPE$2.Function:\n                    balance[tokenCount] = balanceStart;\n                    balanceCloseType = TYPE$2.RightParenthesis;\n                    balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;\n                    break;\n\n                case TYPE$2.LeftSquareBracket:\n                    balance[tokenCount] = balanceStart;\n                    balanceCloseType = TYPE$2.RightSquareBracket;\n                    balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;\n                    break;\n\n                case TYPE$2.LeftCurlyBracket:\n                    balance[tokenCount] = balanceStart;\n                    balanceCloseType = TYPE$2.RightCurlyBracket;\n                    balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;\n                    break;\n            }\n\n            offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;\n        }\n\n        // finalize buffers\n        offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>\n        balance[tokenCount] = sourceLength;\n        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token\n        while (balanceStart !== 0) {\n            balancePrev = balanceStart & OFFSET_MASK$1;\n            balanceStart = balance[balancePrev];\n            balance[balancePrev] = sourceLength;\n        }\n\n        // update stream\n        stream.source = source;\n        stream.firstCharOffset = start;\n        stream.offsetAndType = offsetAndType;\n        stream.tokenCount = tokenCount;\n        stream.balance = balance;\n        stream.reset();\n        stream.next();\n\n        return stream;\n    }\n\n    // extend tokenizer with constants\n    Object.keys(_const).forEach(function(key) {\n        tokenize[key] = _const[key];\n    });\n\n    // extend tokenizer with static methods from utils\n    Object.keys(charCodeDefinitions).forEach(function(key) {\n        tokenize[key] = charCodeDefinitions[key];\n    });\n    Object.keys(utils).forEach(function(key) {\n        tokenize[key] = utils[key];\n    });\n\n    var tokenizer = tokenize;\n\n    var isDigit$2 = tokenizer.isDigit;\n    var cmpChar$1 = tokenizer.cmpChar;\n    var TYPE$3 = tokenizer.TYPE;\n\n    var DELIM = TYPE$3.Delim;\n    var WHITESPACE$1 = TYPE$3.WhiteSpace;\n    var COMMENT$1 = TYPE$3.Comment;\n    var IDENT = TYPE$3.Ident;\n    var NUMBER = TYPE$3.Number;\n    var DIMENSION = TYPE$3.Dimension;\n    var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\n    var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)\n    var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\n    var DISALLOW_SIGN = true;\n    var ALLOW_SIGN = false;\n\n    function isDelim(token, code) {\n        return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;\n    }\n\n    function skipSC(token, offset, getNextToken) {\n        while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {\n            token = getNextToken(++offset);\n        }\n\n        return offset;\n    }\n\n    function checkInteger(token, valueOffset, disallowSign, offset) {\n        if (!token) {\n            return 0;\n        }\n\n        var code = token.value.charCodeAt(valueOffset);\n\n        if (code === PLUSSIGN || code === HYPHENMINUS$1) {\n            if (disallowSign) {\n                // Number sign is not allowed\n                return 0;\n            }\n            valueOffset++;\n        }\n\n        for (; valueOffset < token.value.length; valueOffset++) {\n            if (!isDigit$2(token.value.charCodeAt(valueOffset))) {\n                // Integer is expected\n                return 0;\n            }\n        }\n\n        return offset + 1;\n    }\n\n    // ... <signed-integer>\n    // ... ['+' | '-'] <signless-integer>\n    function consumeB(token, offset_, getNextToken) {\n        var sign = false;\n        var offset = skipSC(token, offset_, getNextToken);\n\n        token = getNextToken(offset);\n\n        if (token === null) {\n            return offset_;\n        }\n\n        if (token.type !== NUMBER) {\n            if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {\n                sign = true;\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                if (token === null && token.type !== NUMBER) {\n                    return 0;\n                }\n            } else {\n                return offset_;\n            }\n        }\n\n        if (!sign) {\n            var code = token.value.charCodeAt(0);\n            if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {\n                // Number sign is expected\n                return 0;\n            }\n        }\n\n        return checkInteger(token, sign ? 0 : 1, sign, offset);\n    }\n\n    // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\n    var genericAnPlusB = function anPlusB(token, getNextToken) {\n        /* eslint-disable brace-style*/\n        var offset = 0;\n\n        if (!token) {\n            return 0;\n        }\n\n        // <integer>\n        if (token.type === NUMBER) {\n            return checkInteger(token, 0, ALLOW_SIGN, offset); // b\n        }\n\n        // -n\n        // -n <signed-integer>\n        // -n ['+' | '-'] <signless-integer>\n        // -n- <signless-integer>\n        // <dashndashdigit-ident>\n        else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {\n            // expect 1st char is N\n            if (!cmpChar$1(token.value, 1, N)) {\n                return 0;\n            }\n\n            switch (token.value.length) {\n                // -n\n                // -n <signed-integer>\n                // -n ['+' | '-'] <signless-integer>\n                case 2:\n                    return consumeB(getNextToken(++offset), offset, getNextToken);\n\n                // -n- <signless-integer>\n                case 3:\n                    if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {\n                        return 0;\n                    }\n\n                    offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                    token = getNextToken(offset);\n\n                    return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n                // <dashndashdigit-ident>\n                default:\n                    if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {\n                        return 0;\n                    }\n\n                    return checkInteger(token, 3, DISALLOW_SIGN, offset);\n            }\n        }\n\n        // '+'? n\n        // '+'? n <signed-integer>\n        // '+'? n ['+' | '-'] <signless-integer>\n        // '+'? n- <signless-integer>\n        // '+'? <ndashdigit-ident>\n        else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {\n            // just ignore a plus\n            if (token.type !== IDENT) {\n                token = getNextToken(++offset);\n            }\n\n            if (token === null || !cmpChar$1(token.value, 0, N)) {\n                return 0;\n            }\n\n            switch (token.value.length) {\n                // '+'? n\n                // '+'? n <signed-integer>\n                // '+'? n ['+' | '-'] <signless-integer>\n                case 1:\n                    return consumeB(getNextToken(++offset), offset, getNextToken);\n\n                // '+'? n- <signless-integer>\n                case 2:\n                    if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {\n                        return 0;\n                    }\n\n                    offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                    token = getNextToken(offset);\n\n                    return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n                // '+'? <ndashdigit-ident>\n                default:\n                    if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {\n                        return 0;\n                    }\n\n                    return checkInteger(token, 2, DISALLOW_SIGN, offset);\n            }\n        }\n\n        // <ndashdigit-dimension>\n        // <ndash-dimension> <signless-integer>\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        else if (token.type === DIMENSION) {\n            var code = token.value.charCodeAt(0);\n            var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;\n\n            for (var i = sign; i < token.value.length; i++) {\n                if (!isDigit$2(token.value.charCodeAt(i))) {\n                    break;\n                }\n            }\n\n            if (i === sign) {\n                // Integer is expected\n                return 0;\n            }\n\n            if (!cmpChar$1(token.value, i, N)) {\n                return 0;\n            }\n\n            // <n-dimension>\n            // <n-dimension> <signed-integer>\n            // <n-dimension> ['+' | '-'] <signless-integer>\n            if (i + 1 === token.value.length) {\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n            } else {\n                if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {\n                    return 0;\n                }\n\n                // <ndash-dimension> <signless-integer>\n                if (i + 2 === token.value.length) {\n                    offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                    token = getNextToken(offset);\n\n                    return checkInteger(token, 0, DISALLOW_SIGN, offset);\n                }\n                // <ndashdigit-dimension>\n                else {\n                    return checkInteger(token, i + 2, DISALLOW_SIGN, offset);\n                }\n            }\n        }\n\n        return 0;\n    };\n\n    var isHexDigit$2 = tokenizer.isHexDigit;\n    var cmpChar$2 = tokenizer.cmpChar;\n    var TYPE$4 = tokenizer.TYPE;\n\n    var IDENT$1 = TYPE$4.Ident;\n    var DELIM$1 = TYPE$4.Delim;\n    var NUMBER$1 = TYPE$4.Number;\n    var DIMENSION$1 = TYPE$4.Dimension;\n    var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)\n    var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)\n    var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\n    var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)\n\n    function isDelim$1(token, code) {\n        return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;\n    }\n\n    function startsWith(token, code) {\n        return token.value.charCodeAt(0) === code;\n    }\n\n    function hexSequence(token, offset, allowDash) {\n        for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {\n            var code = token.value.charCodeAt(pos);\n\n            if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {\n                if (hexSequence(token, offset + hexlen + 1, false) > 0) {\n                    return 6; // dissallow following question marks\n                }\n\n                return 0; // dash at the ending of a hex sequence is not allowed\n            }\n\n            if (!isHexDigit$2(code)) {\n                return 0; // not a hex digit\n            }\n\n            if (++hexlen > 6) {\n                return 0; // too many hex digits\n            }    }\n\n        return hexlen;\n    }\n\n    function withQuestionMarkSequence(consumed, length, getNextToken) {\n        if (!consumed) {\n            return 0; // nothing consumed\n        }\n\n        while (isDelim$1(getNextToken(length), QUESTIONMARK)) {\n            if (++consumed > 6) {\n                return 0; // too many question marks\n            }\n\n            length++;\n        }\n\n        return length;\n    }\n\n    // https://drafts.csswg.org/css-syntax/#urange\n    // Informally, the <urange> production has three forms:\n    // U+0001\n    //      Defines a range consisting of a single code point, in this case the code point \"1\".\n    // U+0001-00ff\n    //      Defines a range of codepoints between the first and the second value, in this case\n    //      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n    // U+00??\n    //      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n    //      in this case defining the same as the value U+0000-00ff.\n    // In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n    //\n    // <urange> =\n    //   u '+' <ident-token> '?'* |\n    //   u <dimension-token> '?'* |\n    //   u <number-token> '?'* |\n    //   u <number-token> <dimension-token> |\n    //   u <number-token> <number-token> |\n    //   u '+' '?'+\n    var genericUrange = function urange(token, getNextToken) {\n        var length = 0;\n\n        // should start with `u` or `U`\n        if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {\n            return 0;\n        }\n\n        token = getNextToken(++length);\n        if (token === null) {\n            return 0;\n        }\n\n        // u '+' <ident-token> '?'*\n        // u '+' '?'+\n        if (isDelim$1(token, PLUSSIGN$1)) {\n            token = getNextToken(++length);\n            if (token === null) {\n                return 0;\n            }\n\n            if (token.type === IDENT$1) {\n                // u '+' <ident-token> '?'*\n                return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);\n            }\n\n            if (isDelim$1(token, QUESTIONMARK)) {\n                // u '+' '?'+\n                return withQuestionMarkSequence(1, ++length, getNextToken);\n            }\n\n            // Hex digit or question mark is expected\n            return 0;\n        }\n\n        // u <number-token> '?'*\n        // u <number-token> <dimension-token>\n        // u <number-token> <number-token>\n        if (token.type === NUMBER$1) {\n            if (!startsWith(token, PLUSSIGN$1)) {\n                return 0;\n            }\n\n            var consumedHexLength = hexSequence(token, 1, true);\n            if (consumedHexLength === 0) {\n                return 0;\n            }\n\n            token = getNextToken(++length);\n            if (token === null) {\n                // u <number-token> <eof>\n                return length;\n            }\n\n            if (token.type === DIMENSION$1 || token.type === NUMBER$1) {\n                // u <number-token> <dimension-token>\n                // u <number-token> <number-token>\n                if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {\n                    return 0;\n                }\n\n                return length + 1;\n            }\n\n            // u <number-token> '?'*\n            return withQuestionMarkSequence(consumedHexLength, length, getNextToken);\n        }\n\n        // u <dimension-token> '?'*\n        if (token.type === DIMENSION$1) {\n            if (!startsWith(token, PLUSSIGN$1)) {\n                return 0;\n            }\n\n            return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);\n        }\n\n        return 0;\n    };\n\n    var isIdentifierStart$2 = tokenizer.isIdentifierStart;\n    var isHexDigit$3 = tokenizer.isHexDigit;\n    var isDigit$3 = tokenizer.isDigit;\n    var cmpStr$3 = tokenizer.cmpStr;\n    var consumeNumber$2 = tokenizer.consumeNumber;\n    var TYPE$5 = tokenizer.TYPE;\n\n\n\n    var cssWideKeywords = ['unset', 'initial', 'inherit'];\n    var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];\n\n    // https://www.w3.org/TR/css-values-3/#lengths\n    var LENGTH = {\n        // absolute length units\n        'px': true,\n        'mm': true,\n        'cm': true,\n        'in': true,\n        'pt': true,\n        'pc': true,\n        'q': true,\n\n        // relative length units\n        'em': true,\n        'ex': true,\n        'ch': true,\n        'rem': true,\n\n        // viewport-percentage lengths\n        'vh': true,\n        'vw': true,\n        'vmin': true,\n        'vmax': true,\n        'vm': true\n    };\n\n    var ANGLE = {\n        'deg': true,\n        'grad': true,\n        'rad': true,\n        'turn': true\n    };\n\n    var TIME = {\n        's': true,\n        'ms': true\n    };\n\n    var FREQUENCY = {\n        'hz': true,\n        'khz': true\n    };\n\n    // https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)\n    var RESOLUTION = {\n        'dpi': true,\n        'dpcm': true,\n        'dppx': true,\n        'x': true      // https://github.com/w3c/csswg-drafts/issues/461\n    };\n\n    // https://drafts.csswg.org/css-grid/#fr-unit\n    var FLEX = {\n        'fr': true\n    };\n\n    // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume\n    var DECIBEL = {\n        'db': true\n    };\n\n    // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch\n    var SEMITONES = {\n        'st': true\n    };\n\n    // safe char code getter\n    function charCode(str, index) {\n        return index < str.length ? str.charCodeAt(index) : 0;\n    }\n\n    function eqStr(actual, expected) {\n        return cmpStr$3(actual, 0, actual.length, expected);\n    }\n\n    function eqStrAny(actual, expected) {\n        for (var i = 0; i < expected.length; i++) {\n            if (eqStr(actual, expected[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // IE postfix hack, i.e. 123\\0 or 123px\\9\n    function isPostfixIeHack(str, offset) {\n        if (offset !== str.length - 2) {\n            return false;\n        }\n\n        return (\n            str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\\)\n            isDigit$3(str.charCodeAt(offset + 1))\n        );\n    }\n\n    function outOfRange(opts, value, numEnd) {\n        if (opts && opts.type === 'Range') {\n            var num = Number(\n                numEnd !== undefined && numEnd !== value.length\n                    ? value.substr(0, numEnd)\n                    : value\n            );\n\n            if (isNaN(num)) {\n                return true;\n            }\n\n            if (opts.min !== null && num < opts.min) {\n                return true;\n            }\n\n            if (opts.max !== null && num > opts.max) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function consumeFunction(token, getNextToken) {\n        var startIdx = token.index;\n        var length = 0;\n\n        // balanced token consuming\n        do {\n            length++;\n\n            if (token.balance <= startIdx) {\n                break;\n            }\n        } while (token = getNextToken(length));\n\n        return length;\n    }\n\n    // TODO: implement\n    // can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed\n    // https://drafts.csswg.org/css-values/#calc-notation\n    function calc(next) {\n        return function(token, getNextToken, opts) {\n            if (token === null) {\n                return 0;\n            }\n\n            if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {\n                return consumeFunction(token, getNextToken);\n            }\n\n            return next(token, getNextToken, opts);\n        };\n    }\n\n    function tokenType(expectedTokenType) {\n        return function(token) {\n            if (token === null || token.type !== expectedTokenType) {\n                return 0;\n            }\n\n            return 1;\n        };\n    }\n\n    function func(name) {\n        name = name + '(';\n\n        return function(token, getNextToken) {\n            if (token !== null && eqStr(token.value, name)) {\n                return consumeFunction(token, getNextToken);\n            }\n\n            return 0;\n        };\n    }\n\n    // =========================\n    // Complex types\n    //\n\n    // https://drafts.csswg.org/css-values-4/#custom-idents\n    // 4.2. Author-defined Identifiers: the <custom-ident> type\n    // Some properties accept arbitrary author-defined identifiers as a component value.\n    // This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier\n    // that would not be misinterpreted as a pre-defined keyword in that property’s value definition.\n    //\n    // See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident\n    function customIdent(token) {\n        if (token === null || token.type !== TYPE$5.Ident) {\n            return 0;\n        }\n\n        var name = token.value.toLowerCase();\n\n        // The CSS-wide keywords are not valid <custom-ident>s\n        if (eqStrAny(name, cssWideKeywords)) {\n            return 0;\n        }\n\n        // The default keyword is reserved and is also not a valid <custom-ident>\n        if (eqStr(name, 'default')) {\n            return 0;\n        }\n\n        // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)\n        // Specifications using <custom-ident> must specify clearly what other keywords\n        // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords\n        // in that property’s value definition are excluded. Excluded keywords are excluded\n        // in all ASCII case permutations.\n\n        return 1;\n    }\n\n    // https://drafts.csswg.org/css-variables/#typedef-custom-property-name\n    // A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.\n    // The <custom-property-name> production corresponds to this: it’s defined as any valid identifier\n    // that starts with two dashes, except -- itself, which is reserved for future use by CSS.\n    // NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.\n    function customPropertyName(token) {\n        // ... defined as any valid identifier\n        if (token === null || token.type !== TYPE$5.Ident) {\n            return 0;\n        }\n\n        // ... that starts with two dashes (U+002D HYPHEN-MINUS)\n        if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {\n            return 0;\n        }\n\n        return 1;\n    }\n\n    // https://drafts.csswg.org/css-color-4/#hex-notation\n    // The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.\n    // In other words, a hex color is written as a hash character, \"#\", followed by some number of digits 0-9 or\n    // letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).\n    function hexColor(token) {\n        if (token === null || token.type !== TYPE$5.Hash) {\n            return 0;\n        }\n\n        var length = token.value.length;\n\n        // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)\n        if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {\n            return 0;\n        }\n\n        for (var i = 1; i < length; i++) {\n            if (!isHexDigit$3(token.value.charCodeAt(i))) {\n                return 0;\n            }\n        }\n\n        return 1;\n    }\n\n    function idSelector(token) {\n        if (token === null || token.type !== TYPE$5.Hash) {\n            return 0;\n        }\n\n        if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {\n            return 0;\n        }\n\n        return 1;\n    }\n\n    // https://drafts.csswg.org/css-syntax/#any-value\n    // It represents the entirety of what a valid declaration can have as its value.\n    function declarationValue(token, getNextToken) {\n        if (!token) {\n            return 0;\n        }\n\n        var length = 0;\n        var level = 0;\n        var startIdx = token.index;\n\n        // The <declaration-value> production matches any sequence of one or more tokens,\n        // so long as the sequence ...\n        scan:\n        do {\n            switch (token.type) {\n                // ... does not contain <bad-string-token>, <bad-url-token>,\n                case TYPE$5.BadString:\n                case TYPE$5.BadUrl:\n                    break scan;\n\n                // ... unmatched <)-token>, <]-token>, or <}-token>,\n                case TYPE$5.RightCurlyBracket:\n                case TYPE$5.RightParenthesis:\n                case TYPE$5.RightSquareBracket:\n                    if (token.balance > token.index || token.balance < startIdx) {\n                        break scan;\n                    }\n\n                    level--;\n                    break;\n\n                // ... or top-level <semicolon-token> tokens\n                case TYPE$5.Semicolon:\n                    if (level === 0) {\n                        break scan;\n                    }\n\n                    break;\n\n                // ... or <delim-token> tokens with a value of \"!\"\n                case TYPE$5.Delim:\n                    if (token.value === '!' && level === 0) {\n                        break scan;\n                    }\n\n                    break;\n\n                case TYPE$5.Function:\n                case TYPE$5.LeftParenthesis:\n                case TYPE$5.LeftSquareBracket:\n                case TYPE$5.LeftCurlyBracket:\n                    level++;\n                    break;\n            }\n\n            length++;\n\n            // until balance closing\n            if (token.balance <= startIdx) {\n                break;\n            }\n        } while (token = getNextToken(length));\n\n        return length;\n    }\n\n    // https://drafts.csswg.org/css-syntax/#any-value\n    // The <any-value> production is identical to <declaration-value>, but also\n    // allows top-level <semicolon-token> tokens and <delim-token> tokens\n    // with a value of \"!\". It represents the entirety of what valid CSS can be in any context.\n    function anyValue(token, getNextToken) {\n        if (!token) {\n            return 0;\n        }\n\n        var startIdx = token.index;\n        var length = 0;\n\n        // The <any-value> production matches any sequence of one or more tokens,\n        // so long as the sequence ...\n        scan:\n        do {\n            switch (token.type) {\n                // ... does not contain <bad-string-token>, <bad-url-token>,\n                case TYPE$5.BadString:\n                case TYPE$5.BadUrl:\n                    break scan;\n\n                // ... unmatched <)-token>, <]-token>, or <}-token>,\n                case TYPE$5.RightCurlyBracket:\n                case TYPE$5.RightParenthesis:\n                case TYPE$5.RightSquareBracket:\n                    if (token.balance > token.index || token.balance < startIdx) {\n                        break scan;\n                    }\n\n                    break;\n            }\n\n            length++;\n\n            // until balance closing\n            if (token.balance <= startIdx) {\n                break;\n            }\n        } while (token = getNextToken(length));\n\n        return length;\n    }\n\n    // =========================\n    // Dimensions\n    //\n\n    function dimension(type) {\n        return function(token, getNextToken, opts) {\n            if (token === null || token.type !== TYPE$5.Dimension) {\n                return 0;\n            }\n\n            var numberEnd = consumeNumber$2(token.value, 0);\n\n            // check unit\n            if (type !== null) {\n                // check for IE postfix hack, i.e. 123px\\0 or 123px\\9\n                var reverseSolidusOffset = token.value.indexOf('\\\\', numberEnd);\n                var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)\n                    ? token.value.substr(numberEnd)\n                    : token.value.substring(numberEnd, reverseSolidusOffset);\n\n                if (type.hasOwnProperty(unit.toLowerCase()) === false) {\n                    return 0;\n                }\n            }\n\n            // check range if specified\n            if (outOfRange(opts, token.value, numberEnd)) {\n                return 0;\n            }\n\n            return 1;\n        };\n    }\n\n    // =========================\n    // Percentage\n    //\n\n    // §5.5. Percentages: the <percentage> type\n    // https://drafts.csswg.org/css-values-4/#percentages\n    function percentage(token, getNextToken, opts) {\n        // ... corresponds to the <percentage-token> production\n        if (token === null || token.type !== TYPE$5.Percentage) {\n            return 0;\n        }\n\n        // check range if specified\n        if (outOfRange(opts, token.value, token.value.length - 1)) {\n            return 0;\n        }\n\n        return 1;\n    }\n\n    // =========================\n    // Numeric\n    //\n\n    // https://drafts.csswg.org/css-values-4/#numbers\n    // The value <zero> represents a literal number with the value 0. Expressions that merely\n    // evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;\n    // only literal <number-token>s do.\n    function zero(next) {\n        if (typeof next !== 'function') {\n            next = function() {\n                return 0;\n            };\n        }\n\n        return function(token, getNextToken, opts) {\n            if (token !== null && token.type === TYPE$5.Number) {\n                if (Number(token.value) === 0) {\n                    return 1;\n                }\n            }\n\n            return next(token, getNextToken, opts);\n        };\n    }\n\n    // § 5.3. Real Numbers: the <number> type\n    // https://drafts.csswg.org/css-values-4/#numbers\n    // Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.\n    // ... It corresponds to the <number-token> production\n    function number(token, getNextToken, opts) {\n        if (token === null) {\n            return 0;\n        }\n\n        var numberEnd = consumeNumber$2(token.value, 0);\n        var isNumber = numberEnd === token.value.length;\n        if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {\n            return 0;\n        }\n\n        // check range if specified\n        if (outOfRange(opts, token.value, numberEnd)) {\n            return 0;\n        }\n\n        return 1;\n    }\n\n    // §5.2. Integers: the <integer> type\n    // https://drafts.csswg.org/css-values-4/#integers\n    function integer(token, getNextToken, opts) {\n        // ... corresponds to a subset of the <number-token> production\n        if (token === null || token.type !== TYPE$5.Number) {\n            return 0;\n        }\n\n        // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.\n        var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)\n                token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)\n\n        // When written literally, an integer is one or more decimal digits 0 through 9 ...\n        for (; i < token.value.length; i++) {\n            if (!isDigit$3(token.value.charCodeAt(i))) {\n                return 0;\n            }\n        }\n\n        // check range if specified\n        if (outOfRange(opts, token.value, i)) {\n            return 0;\n        }\n\n        return 1;\n    }\n\n    var generic = {\n        // token types\n        'ident-token': tokenType(TYPE$5.Ident),\n        'function-token': tokenType(TYPE$5.Function),\n        'at-keyword-token': tokenType(TYPE$5.AtKeyword),\n        'hash-token': tokenType(TYPE$5.Hash),\n        'string-token': tokenType(TYPE$5.String),\n        'bad-string-token': tokenType(TYPE$5.BadString),\n        'url-token': tokenType(TYPE$5.Url),\n        'bad-url-token': tokenType(TYPE$5.BadUrl),\n        'delim-token': tokenType(TYPE$5.Delim),\n        'number-token': tokenType(TYPE$5.Number),\n        'percentage-token': tokenType(TYPE$5.Percentage),\n        'dimension-token': tokenType(TYPE$5.Dimension),\n        'whitespace-token': tokenType(TYPE$5.WhiteSpace),\n        'CDO-token': tokenType(TYPE$5.CDO),\n        'CDC-token': tokenType(TYPE$5.CDC),\n        'colon-token': tokenType(TYPE$5.Colon),\n        'semicolon-token': tokenType(TYPE$5.Semicolon),\n        'comma-token': tokenType(TYPE$5.Comma),\n        '[-token': tokenType(TYPE$5.LeftSquareBracket),\n        ']-token': tokenType(TYPE$5.RightSquareBracket),\n        '(-token': tokenType(TYPE$5.LeftParenthesis),\n        ')-token': tokenType(TYPE$5.RightParenthesis),\n        '{-token': tokenType(TYPE$5.LeftCurlyBracket),\n        '}-token': tokenType(TYPE$5.RightCurlyBracket),\n\n        // token type aliases\n        'string': tokenType(TYPE$5.String),\n        'ident': tokenType(TYPE$5.Ident),\n\n        // complex types\n        'custom-ident': customIdent,\n        'custom-property-name': customPropertyName,\n        'hex-color': hexColor,\n        'id-selector': idSelector, // element( <id-selector> )\n        'an-plus-b': genericAnPlusB,\n        'urange': genericUrange,\n        'declaration-value': declarationValue,\n        'any-value': anyValue,\n\n        // dimensions\n        'dimension': calc(dimension(null)),\n        'angle': calc(dimension(ANGLE)),\n        'decibel': calc(dimension(DECIBEL)),\n        'frequency': calc(dimension(FREQUENCY)),\n        'flex': calc(dimension(FLEX)),\n        'length': calc(zero(dimension(LENGTH))),\n        'resolution': calc(dimension(RESOLUTION)),\n        'semitones': calc(dimension(SEMITONES)),\n        'time': calc(dimension(TIME)),\n\n        // percentage\n        'percentage': calc(percentage),\n\n        // numeric\n        'zero': zero(),\n        'number': calc(number),\n        'integer': calc(integer),\n\n        // old IE stuff\n        '-ms-legacy-expression': func('expression')\n    };\n\n    var _SyntaxError$1 = function SyntaxError(message, input, offset) {\n        var error = createCustomError('SyntaxError', message);\n\n        error.input = input;\n        error.offset = offset;\n        error.rawMessage = message;\n        error.message = error.rawMessage + '\\n' +\n            '  ' + error.input + '\\n' +\n            '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';\n\n        return error;\n    };\n\n    var TAB = 9;\n    var N$1 = 10;\n    var F = 12;\n    var R = 13;\n    var SPACE = 32;\n\n    var Tokenizer = function(str) {\n        this.str = str;\n        this.pos = 0;\n    };\n\n    Tokenizer.prototype = {\n        charCodeAt: function(pos) {\n            return pos < this.str.length ? this.str.charCodeAt(pos) : 0;\n        },\n        charCode: function() {\n            return this.charCodeAt(this.pos);\n        },\n        nextCharCode: function() {\n            return this.charCodeAt(this.pos + 1);\n        },\n        nextNonWsCode: function(pos) {\n            return this.charCodeAt(this.findWsEnd(pos));\n        },\n        findWsEnd: function(pos) {\n            for (; pos < this.str.length; pos++) {\n                var code = this.str.charCodeAt(pos);\n                if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {\n                    break;\n                }\n            }\n\n            return pos;\n        },\n        substringToPos: function(end) {\n            return this.str.substring(this.pos, this.pos = end);\n        },\n        eat: function(code) {\n            if (this.charCode() !== code) {\n                this.error('Expect `' + String.fromCharCode(code) + '`');\n            }\n\n            this.pos++;\n        },\n        peek: function() {\n            return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';\n        },\n        error: function(message) {\n            throw new _SyntaxError$1(message, this.str, this.pos);\n        }\n    };\n\n    var tokenizer$1 = Tokenizer;\n\n    var TAB$1 = 9;\n    var N$2 = 10;\n    var F$1 = 12;\n    var R$1 = 13;\n    var SPACE$1 = 32;\n    var EXCLAMATIONMARK = 33;    // !\n    var NUMBERSIGN = 35;         // #\n    var AMPERSAND = 38;          // &\n    var APOSTROPHE = 39;         // '\n    var LEFTPARENTHESIS = 40;    // (\n    var RIGHTPARENTHESIS = 41;   // )\n    var ASTERISK = 42;           // *\n    var PLUSSIGN$2 = 43;           // +\n    var COMMA = 44;              // ,\n    var HYPERMINUS = 45;         // -\n    var LESSTHANSIGN = 60;       // <\n    var GREATERTHANSIGN = 62;    // >\n    var QUESTIONMARK$1 = 63;       // ?\n    var COMMERCIALAT = 64;       // @\n    var LEFTSQUAREBRACKET = 91;  // [\n    var RIGHTSQUAREBRACKET = 93; // ]\n    var LEFTCURLYBRACKET = 123;  // {\n    var VERTICALLINE = 124;      // |\n    var RIGHTCURLYBRACKET = 125; // }\n    var INFINITY = 8734;         // ∞\n    var NAME_CHAR = createCharMap(function(ch) {\n        return /[a-zA-Z0-9\\-]/.test(ch);\n    });\n    var COMBINATOR_PRECEDENCE = {\n        ' ': 1,\n        '&&': 2,\n        '||': 3,\n        '|': 4\n    };\n\n    function createCharMap(fn) {\n        var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n        for (var i = 0; i < 128; i++) {\n            array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n        }\n        return array;\n    }\n\n    function scanSpaces(tokenizer) {\n        return tokenizer.substringToPos(\n            tokenizer.findWsEnd(tokenizer.pos)\n        );\n    }\n\n    function scanWord(tokenizer) {\n        var end = tokenizer.pos;\n\n        for (; end < tokenizer.str.length; end++) {\n            var code = tokenizer.str.charCodeAt(end);\n            if (code >= 128 || NAME_CHAR[code] === 0) {\n                break;\n            }\n        }\n\n        if (tokenizer.pos === end) {\n            tokenizer.error('Expect a keyword');\n        }\n\n        return tokenizer.substringToPos(end);\n    }\n\n    function scanNumber(tokenizer) {\n        var end = tokenizer.pos;\n\n        for (; end < tokenizer.str.length; end++) {\n            var code = tokenizer.str.charCodeAt(end);\n            if (code < 48 || code > 57) {\n                break;\n            }\n        }\n\n        if (tokenizer.pos === end) {\n            tokenizer.error('Expect a number');\n        }\n\n        return tokenizer.substringToPos(end);\n    }\n\n    function scanString(tokenizer) {\n        var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n        if (end === -1) {\n            tokenizer.pos = tokenizer.str.length;\n            tokenizer.error('Expect an apostrophe');\n        }\n\n        return tokenizer.substringToPos(end + 1);\n    }\n\n    function readMultiplierRange(tokenizer) {\n        var min = null;\n        var max = null;\n\n        tokenizer.eat(LEFTCURLYBRACKET);\n\n        min = scanNumber(tokenizer);\n\n        if (tokenizer.charCode() === COMMA) {\n            tokenizer.pos++;\n            if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n                max = scanNumber(tokenizer);\n            }\n        } else {\n            max = min;\n        }\n\n        tokenizer.eat(RIGHTCURLYBRACKET);\n\n        return {\n            min: Number(min),\n            max: max ? Number(max) : 0\n        };\n    }\n\n    function readMultiplier(tokenizer) {\n        var range = null;\n        var comma = false;\n\n        switch (tokenizer.charCode()) {\n            case ASTERISK:\n                tokenizer.pos++;\n\n                range = {\n                    min: 0,\n                    max: 0\n                };\n\n                break;\n\n            case PLUSSIGN$2:\n                tokenizer.pos++;\n\n                range = {\n                    min: 1,\n                    max: 0\n                };\n\n                break;\n\n            case QUESTIONMARK$1:\n                tokenizer.pos++;\n\n                range = {\n                    min: 0,\n                    max: 1\n                };\n\n                break;\n\n            case NUMBERSIGN:\n                tokenizer.pos++;\n\n                comma = true;\n\n                if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n                    range = readMultiplierRange(tokenizer);\n                } else {\n                    range = {\n                        min: 1,\n                        max: 0\n                    };\n                }\n\n                break;\n\n            case LEFTCURLYBRACKET:\n                range = readMultiplierRange(tokenizer);\n                break;\n\n            default:\n                return null;\n        }\n\n        return {\n            type: 'Multiplier',\n            comma: comma,\n            min: range.min,\n            max: range.max,\n            term: null\n        };\n    }\n\n    function maybeMultiplied(tokenizer, node) {\n        var multiplier = readMultiplier(tokenizer);\n\n        if (multiplier !== null) {\n            multiplier.term = node;\n            return multiplier;\n        }\n\n        return node;\n    }\n\n    function maybeToken(tokenizer) {\n        var ch = tokenizer.peek();\n\n        if (ch === '') {\n            return null;\n        }\n\n        return {\n            type: 'Token',\n            value: ch\n        };\n    }\n\n    function readProperty(tokenizer) {\n        var name;\n\n        tokenizer.eat(LESSTHANSIGN);\n        tokenizer.eat(APOSTROPHE);\n\n        name = scanWord(tokenizer);\n\n        tokenizer.eat(APOSTROPHE);\n        tokenizer.eat(GREATERTHANSIGN);\n\n        return maybeMultiplied(tokenizer, {\n            type: 'Property',\n            name: name\n        });\n    }\n\n    // https://drafts.csswg.org/css-values-3/#numeric-ranges\n    // 4.1. Range Restrictions and Range Definition Notation\n    //\n    // Range restrictions can be annotated in the numeric type notation using CSS bracketed\n    // range notation—[min,max]—within the angle brackets, after the identifying keyword,\n    // indicating a closed range between (and including) min and max.\n    // For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\n    function readTypeRange(tokenizer) {\n        // use null for Infinity to make AST format JSON serializable/deserializable\n        var min = null; // -Infinity\n        var max = null; // Infinity\n        var sign = 1;\n\n        tokenizer.eat(LEFTSQUAREBRACKET);\n\n        if (tokenizer.charCode() === HYPERMINUS) {\n            tokenizer.peek();\n            sign = -1;\n        }\n\n        if (sign == -1 && tokenizer.charCode() === INFINITY) {\n            tokenizer.peek();\n        } else {\n            min = sign * Number(scanNumber(tokenizer));\n        }\n\n        scanSpaces(tokenizer);\n        tokenizer.eat(COMMA);\n        scanSpaces(tokenizer);\n\n        if (tokenizer.charCode() === INFINITY) {\n            tokenizer.peek();\n        } else {\n            sign = 1;\n\n            if (tokenizer.charCode() === HYPERMINUS) {\n                tokenizer.peek();\n                sign = -1;\n            }\n\n            max = sign * Number(scanNumber(tokenizer));\n        }\n\n        tokenizer.eat(RIGHTSQUAREBRACKET);\n\n        // If no range is indicated, either by using the bracketed range notation\n        // or in the property description, then [−∞,∞] is assumed.\n        if (min === null && max === null) {\n            return null;\n        }\n\n        return {\n            type: 'Range',\n            min: min,\n            max: max\n        };\n    }\n\n    function readType(tokenizer) {\n        var name;\n        var opts = null;\n\n        tokenizer.eat(LESSTHANSIGN);\n        name = scanWord(tokenizer);\n\n        if (tokenizer.charCode() === LEFTPARENTHESIS &&\n            tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n            tokenizer.pos += 2;\n            name += '()';\n        }\n\n        if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n            scanSpaces(tokenizer);\n            opts = readTypeRange(tokenizer);\n        }\n\n        tokenizer.eat(GREATERTHANSIGN);\n\n        return maybeMultiplied(tokenizer, {\n            type: 'Type',\n            name: name,\n            opts: opts\n        });\n    }\n\n    function readKeywordOrFunction(tokenizer) {\n        var name;\n\n        name = scanWord(tokenizer);\n\n        if (tokenizer.charCode() === LEFTPARENTHESIS) {\n            tokenizer.pos++;\n\n            return {\n                type: 'Function',\n                name: name\n            };\n        }\n\n        return maybeMultiplied(tokenizer, {\n            type: 'Keyword',\n            name: name\n        });\n    }\n\n    function regroupTerms(terms, combinators) {\n        function createGroup(terms, combinator) {\n            return {\n                type: 'Group',\n                terms: terms,\n                combinator: combinator,\n                disallowEmpty: false,\n                explicit: false\n            };\n        }\n\n        combinators = Object.keys(combinators).sort(function(a, b) {\n            return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n        });\n\n        while (combinators.length > 0) {\n            var combinator = combinators.shift();\n            for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n                var term = terms[i];\n                if (term.type === 'Combinator') {\n                    if (term.value === combinator) {\n                        if (subgroupStart === -1) {\n                            subgroupStart = i - 1;\n                        }\n                        terms.splice(i, 1);\n                        i--;\n                    } else {\n                        if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                            terms.splice(\n                                subgroupStart,\n                                i - subgroupStart,\n                                createGroup(terms.slice(subgroupStart, i), combinator)\n                            );\n                            i = subgroupStart + 1;\n                        }\n                        subgroupStart = -1;\n                    }\n                }\n            }\n\n            if (subgroupStart !== -1 && combinators.length) {\n                terms.splice(\n                    subgroupStart,\n                    i - subgroupStart,\n                    createGroup(terms.slice(subgroupStart, i), combinator)\n                );\n            }\n        }\n\n        return combinator;\n    }\n\n    function readImplicitGroup(tokenizer) {\n        var terms = [];\n        var combinators = {};\n        var token;\n        var prevToken = null;\n        var prevTokenPos = tokenizer.pos;\n\n        while (token = peek(tokenizer)) {\n            if (token.type !== 'Spaces') {\n                if (token.type === 'Combinator') {\n                    // check for combinator in group beginning and double combinator sequence\n                    if (prevToken === null || prevToken.type === 'Combinator') {\n                        tokenizer.pos = prevTokenPos;\n                        tokenizer.error('Unexpected combinator');\n                    }\n\n                    combinators[token.value] = true;\n                } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                    combinators[' '] = true;  // a b\n                    terms.push({\n                        type: 'Combinator',\n                        value: ' '\n                    });\n                }\n\n                terms.push(token);\n                prevToken = token;\n                prevTokenPos = tokenizer.pos;\n            }\n        }\n\n        // check for combinator in group ending\n        if (prevToken !== null && prevToken.type === 'Combinator') {\n            tokenizer.pos -= prevTokenPos;\n            tokenizer.error('Unexpected combinator');\n        }\n\n        return {\n            type: 'Group',\n            terms: terms,\n            combinator: regroupTerms(terms, combinators) || ' ',\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    function readGroup(tokenizer) {\n        var result;\n\n        tokenizer.eat(LEFTSQUAREBRACKET);\n        result = readImplicitGroup(tokenizer);\n        tokenizer.eat(RIGHTSQUAREBRACKET);\n\n        result.explicit = true;\n\n        if (tokenizer.charCode() === EXCLAMATIONMARK) {\n            tokenizer.pos++;\n            result.disallowEmpty = true;\n        }\n\n        return result;\n    }\n\n    function peek(tokenizer) {\n        var code = tokenizer.charCode();\n\n        if (code < 128 && NAME_CHAR[code] === 1) {\n            return readKeywordOrFunction(tokenizer);\n        }\n\n        switch (code) {\n            case RIGHTSQUAREBRACKET:\n                // don't eat, stop scan a group\n                break;\n\n            case LEFTSQUAREBRACKET:\n                return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n            case LESSTHANSIGN:\n                return tokenizer.nextCharCode() === APOSTROPHE\n                    ? readProperty(tokenizer)\n                    : readType(tokenizer);\n\n            case VERTICALLINE:\n                return {\n                    type: 'Combinator',\n                    value: tokenizer.substringToPos(\n                        tokenizer.nextCharCode() === VERTICALLINE\n                            ? tokenizer.pos + 2\n                            : tokenizer.pos + 1\n                    )\n                };\n\n            case AMPERSAND:\n                tokenizer.pos++;\n                tokenizer.eat(AMPERSAND);\n\n                return {\n                    type: 'Combinator',\n                    value: '&&'\n                };\n\n            case COMMA:\n                tokenizer.pos++;\n                return {\n                    type: 'Comma'\n                };\n\n            case APOSTROPHE:\n                return maybeMultiplied(tokenizer, {\n                    type: 'String',\n                    value: scanString(tokenizer)\n                });\n\n            case SPACE$1:\n            case TAB$1:\n            case N$2:\n            case R$1:\n            case F$1:\n                return {\n                    type: 'Spaces',\n                    value: scanSpaces(tokenizer)\n                };\n\n            case COMMERCIALAT:\n                code = tokenizer.nextCharCode();\n\n                if (code < 128 && NAME_CHAR[code] === 1) {\n                    tokenizer.pos++;\n                    return {\n                        type: 'AtKeyword',\n                        name: scanWord(tokenizer)\n                    };\n                }\n\n                return maybeToken(tokenizer);\n\n            case ASTERISK:\n            case PLUSSIGN$2:\n            case QUESTIONMARK$1:\n            case NUMBERSIGN:\n            case EXCLAMATIONMARK:\n                // prohibited tokens (used as a multiplier start)\n                break;\n\n            case LEFTCURLYBRACKET:\n                // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n                // check next char isn't a number, because it's likely a disjoined multiplier\n                code = tokenizer.nextCharCode();\n\n                if (code < 48 || code > 57) {\n                    return maybeToken(tokenizer);\n                }\n\n                break;\n\n            default:\n                return maybeToken(tokenizer);\n        }\n    }\n\n    function parse(source) {\n        var tokenizer = new tokenizer$1(source);\n        var result = readImplicitGroup(tokenizer);\n\n        if (tokenizer.pos !== source.length) {\n            tokenizer.error('Unexpected input');\n        }\n\n        // reduce redundant groups with single group term\n        if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n            result = result.terms[0];\n        }\n\n        return result;\n    }\n\n    // warm up parse to elimitate code branches that never execute\n    // fix soft deoptimizations (insufficient type feedback)\n    parse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\n\n    var parse_1 = parse;\n\n    var noop$1 = function() {};\n\n    function ensureFunction(value) {\n        return typeof value === 'function' ? value : noop$1;\n    }\n\n    var walk = function(node, options, context) {\n        function walk(node) {\n            enter.call(context, node);\n\n            switch (node.type) {\n                case 'Group':\n                    node.terms.forEach(walk);\n                    break;\n\n                case 'Multiplier':\n                    walk(node.term);\n                    break;\n\n                case 'Type':\n                case 'Property':\n                case 'Keyword':\n                case 'AtKeyword':\n                case 'Function':\n                case 'String':\n                case 'Token':\n                case 'Comma':\n                    break;\n\n                default:\n                    throw new Error('Unknown type: ' + node.type);\n            }\n\n            leave.call(context, node);\n        }\n\n        var enter = noop$1;\n        var leave = noop$1;\n\n        if (typeof options === 'function') {\n            enter = options;\n        } else if (options) {\n            enter = ensureFunction(options.enter);\n            leave = ensureFunction(options.leave);\n        }\n\n        if (enter === noop$1 && leave === noop$1) {\n            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n        }\n\n        walk(node);\n    };\n\n    var tokenStream = new TokenStream_1();\n    var astToTokens = {\n        decorator: function(handlers) {\n            var curNode = null;\n            var prev = { len: 0, node: null };\n            var nodes = [prev];\n            var buffer = '';\n\n            return {\n                children: handlers.children,\n                node: function(node) {\n                    var tmp = curNode;\n                    curNode = node;\n                    handlers.node.call(this, node);\n                    curNode = tmp;\n                },\n                chunk: function(chunk) {\n                    buffer += chunk;\n                    if (prev.node !== curNode) {\n                        nodes.push({\n                            len: chunk.length,\n                            node: curNode\n                        });\n                    } else {\n                        prev.len += chunk.length;\n                    }\n                },\n                result: function() {\n                    return prepareTokens(buffer, nodes);\n                }\n            };\n        }\n    };\n\n    function prepareTokens(str, nodes) {\n        var tokens = [];\n        var nodesOffset = 0;\n        var nodesIndex = 0;\n        var currentNode = nodes ? nodes[nodesIndex].node : null;\n\n        tokenizer(str, tokenStream);\n\n        while (!tokenStream.eof) {\n            if (nodes) {\n                while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {\n                    nodesOffset += nodes[nodesIndex++].len;\n                    currentNode = nodes[nodesIndex].node;\n                }\n            }\n\n            tokens.push({\n                type: tokenStream.tokenType,\n                value: tokenStream.getTokenValue(),\n                index: tokenStream.tokenIndex, // TODO: remove it, temporary solution\n                balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution\n                node: currentNode\n            });\n            tokenStream.next();\n            // console.log({ ...tokens[tokens.length - 1], node: undefined });\n        }\n\n        return tokens;\n    }\n\n    var prepareTokens_1 = function(value, syntax) {\n        if (typeof value === 'string') {\n            return prepareTokens(value, null);\n        }\n\n        return syntax.generate(value, astToTokens);\n    };\n\n    var MATCH = { type: 'Match' };\n    var MISMATCH = { type: 'Mismatch' };\n    var DISALLOW_EMPTY = { type: 'DisallowEmpty' };\n    var LEFTPARENTHESIS$1 = 40;  // (\n    var RIGHTPARENTHESIS$1 = 41; // )\n\n    function createCondition(match, thenBranch, elseBranch) {\n        // reduce node count\n        if (thenBranch === MATCH && elseBranch === MISMATCH) {\n            return match;\n        }\n\n        if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n            return match;\n        }\n\n        if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n            thenBranch = match.then;\n            match = match.match;\n        }\n\n        return {\n            type: 'If',\n            match: match,\n            then: thenBranch,\n            else: elseBranch\n        };\n    }\n\n    function isFunctionType(name) {\n        return (\n            name.length > 2 &&\n            name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&\n            name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1\n        );\n    }\n\n    function isEnumCapatible(term) {\n        return (\n            term.type === 'Keyword' ||\n            term.type === 'AtKeyword' ||\n            term.type === 'Function' ||\n            term.type === 'Type' && isFunctionType(term.name)\n        );\n    }\n\n    function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n        switch (combinator) {\n            case ' ':\n                // Juxtaposing components means that all of them must occur, in the given order.\n                //\n                // a b c\n                // =\n                // match a\n                //   then match b\n                //     then match c\n                //       then MATCH\n                //       else MISMATCH\n                //     else MISMATCH\n                //   else MISMATCH\n                var result = MATCH;\n\n                for (var i = terms.length - 1; i >= 0; i--) {\n                    var term = terms[i];\n\n                    result = createCondition(\n                        term,\n                        result,\n                        MISMATCH\n                    );\n                }\n                return result;\n\n            case '|':\n                // A bar (|) separates two or more alternatives: exactly one of them must occur.\n                //\n                // a | b | c\n                // =\n                // match a\n                //   then MATCH\n                //   else match b\n                //     then MATCH\n                //     else match c\n                //       then MATCH\n                //       else MISMATCH\n\n                var result = MISMATCH;\n                var map = null;\n\n                for (var i = terms.length - 1; i >= 0; i--) {\n                    var term = terms[i];\n\n                    // reduce sequence of keywords into a Enum\n                    if (isEnumCapatible(term)) {\n                        if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                            map = Object.create(null);\n                            result = createCondition(\n                                {\n                                    type: 'Enum',\n                                    map: map\n                                },\n                                MATCH,\n                                result\n                            );\n                        }\n\n                        if (map !== null) {\n                            var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                            if (key in map === false) {\n                                map[key] = term;\n                                continue;\n                            }\n                        }\n                    }\n\n                    map = null;\n\n                    // create a new conditonal node\n                    result = createCondition(\n                        term,\n                        MATCH,\n                        result\n                    );\n                }\n                return result;\n\n            case '&&':\n                // A double ampersand (&&) separates two or more components,\n                // all of which must occur, in any order.\n\n                // Use MatchOnce for groups with a large number of terms,\n                // since &&-groups produces at least N!-node trees\n                if (terms.length > 5) {\n                    return {\n                        type: 'MatchOnce',\n                        terms: terms,\n                        all: true\n                    };\n                }\n\n                // Use a combination tree for groups with small number of terms\n                //\n                // a && b && c\n                // =\n                // match a\n                //   then [b && c]\n                //   else match b\n                //     then [a && c]\n                //     else match c\n                //       then [a && b]\n                //       else MISMATCH\n                //\n                // a && b\n                // =\n                // match a\n                //   then match b\n                //     then MATCH\n                //     else MISMATCH\n                //   else match b\n                //     then match a\n                //       then MATCH\n                //       else MISMATCH\n                //     else MISMATCH\n                var result = MISMATCH;\n\n                for (var i = terms.length - 1; i >= 0; i--) {\n                    var term = terms[i];\n                    var thenClause;\n\n                    if (terms.length > 1) {\n                        thenClause = buildGroupMatchGraph(\n                            combinator,\n                            terms.filter(function(newGroupTerm) {\n                                return newGroupTerm !== term;\n                            }),\n                            false\n                        );\n                    } else {\n                        thenClause = MATCH;\n                    }\n\n                    result = createCondition(\n                        term,\n                        thenClause,\n                        result\n                    );\n                }\n                return result;\n\n            case '||':\n                // A double bar (||) separates two or more options:\n                // one or more of them must occur, in any order.\n\n                // Use MatchOnce for groups with a large number of terms,\n                // since ||-groups produces at least N!-node trees\n                if (terms.length > 5) {\n                    return {\n                        type: 'MatchOnce',\n                        terms: terms,\n                        all: false\n                    };\n                }\n\n                // Use a combination tree for groups with small number of terms\n                //\n                // a || b || c\n                // =\n                // match a\n                //   then [b || c]\n                //   else match b\n                //     then [a || c]\n                //     else match c\n                //       then [a || b]\n                //       else MISMATCH\n                //\n                // a || b\n                // =\n                // match a\n                //   then match b\n                //     then MATCH\n                //     else MATCH\n                //   else match b\n                //     then match a\n                //       then MATCH\n                //       else MATCH\n                //     else MISMATCH\n                var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n                for (var i = terms.length - 1; i >= 0; i--) {\n                    var term = terms[i];\n                    var thenClause;\n\n                    if (terms.length > 1) {\n                        thenClause = buildGroupMatchGraph(\n                            combinator,\n                            terms.filter(function(newGroupTerm) {\n                                return newGroupTerm !== term;\n                            }),\n                            true\n                        );\n                    } else {\n                        thenClause = MATCH;\n                    }\n\n                    result = createCondition(\n                        term,\n                        thenClause,\n                        result\n                    );\n                }\n                return result;\n        }\n    }\n\n    function buildMultiplierMatchGraph(node) {\n        var result = MATCH;\n        var matchTerm = buildMatchGraph(node.term);\n\n        if (node.max === 0) {\n            // disable repeating of empty match to prevent infinite loop\n            matchTerm = createCondition(\n                matchTerm,\n                DISALLOW_EMPTY,\n                MISMATCH\n            );\n\n            // an occurrence count is not limited, make a cycle;\n            // to collect more terms on each following matching mismatch\n            result = createCondition(\n                matchTerm,\n                null, // will be a loop\n                MISMATCH\n            );\n\n            result.then = createCondition(\n                MATCH,\n                MATCH,\n                result // make a loop\n            );\n\n            if (node.comma) {\n                result.then.else = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n        } else {\n            // create a match node chain for [min .. max] interval with optional matches\n            for (var i = node.min || 1; i <= node.max; i++) {\n                if (node.comma && result !== MATCH) {\n                    result = createCondition(\n                        { type: 'Comma', syntax: node },\n                        result,\n                        MISMATCH\n                    );\n                }\n\n                result = createCondition(\n                    matchTerm,\n                    createCondition(\n                        MATCH,\n                        MATCH,\n                        result\n                    ),\n                    MISMATCH\n                );\n            }\n        }\n\n        if (node.min === 0) {\n            // allow zero match\n            result = createCondition(\n                MATCH,\n                MATCH,\n                result\n            );\n        } else {\n            // create a match node chain to collect [0 ... min - 1] required matches\n            for (var i = 0; i < node.min - 1; i++) {\n                if (node.comma && result !== MATCH) {\n                    result = createCondition(\n                        { type: 'Comma', syntax: node },\n                        result,\n                        MISMATCH\n                    );\n                }\n\n                result = createCondition(\n                    matchTerm,\n                    result,\n                    MISMATCH\n                );\n            }\n        }\n\n        return result;\n    }\n\n    function buildMatchGraph(node) {\n        if (typeof node === 'function') {\n            return {\n                type: 'Generic',\n                fn: node\n            };\n        }\n\n        switch (node.type) {\n            case 'Group':\n                var result = buildGroupMatchGraph(\n                    node.combinator,\n                    node.terms.map(buildMatchGraph),\n                    false\n                );\n\n                if (node.disallowEmpty) {\n                    result = createCondition(\n                        result,\n                        DISALLOW_EMPTY,\n                        MISMATCH\n                    );\n                }\n\n                return result;\n\n            case 'Multiplier':\n                return buildMultiplierMatchGraph(node);\n\n            case 'Type':\n            case 'Property':\n                return {\n                    type: node.type,\n                    name: node.name,\n                    syntax: node\n                };\n\n            case 'Keyword':\n                return {\n                    type: node.type,\n                    name: node.name.toLowerCase(),\n                    syntax: node\n                };\n\n            case 'AtKeyword':\n                return {\n                    type: node.type,\n                    name: '@' + node.name.toLowerCase(),\n                    syntax: node\n                };\n\n            case 'Function':\n                return {\n                    type: node.type,\n                    name: node.name.toLowerCase() + '(',\n                    syntax: node\n                };\n\n            case 'String':\n                // convert a one char length String to a Token\n                if (node.value.length === 3) {\n                    return {\n                        type: 'Token',\n                        value: node.value.charAt(1),\n                        syntax: node\n                    };\n                }\n\n                // otherwise use it as is\n                return {\n                    type: node.type,\n                    value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                    syntax: node\n                };\n\n            case 'Token':\n                return {\n                    type: node.type,\n                    value: node.value,\n                    syntax: node\n                };\n\n            case 'Comma':\n                return {\n                    type: node.type,\n                    syntax: node\n                };\n\n            default:\n                throw new Error('Unknown node type:', node.type);\n        }\n    }\n\n    var matchGraph = {\n        MATCH: MATCH,\n        MISMATCH: MISMATCH,\n        DISALLOW_EMPTY: DISALLOW_EMPTY,\n        buildMatchGraph: function(syntaxTree, ref) {\n            if (typeof syntaxTree === 'string') {\n                syntaxTree = parse_1(syntaxTree);\n            }\n\n            return {\n                type: 'MatchGraph',\n                match: buildMatchGraph(syntaxTree),\n                syntax: ref || null,\n                source: syntaxTree\n            };\n        }\n    };\n\n    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n    var MATCH$1 = matchGraph.MATCH;\n    var MISMATCH$1 = matchGraph.MISMATCH;\n    var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;\n    var TYPE$6 = _const.TYPE;\n\n    var STUB = 0;\n    var TOKEN = 1;\n    var OPEN_SYNTAX = 2;\n    var CLOSE_SYNTAX = 3;\n\n    var EXIT_REASON_MATCH = 'Match';\n    var EXIT_REASON_MISMATCH = 'Mismatch';\n    var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\n    var ITERATION_LIMIT = 15000;\n    var totalIterationCount = 0;\n\n    function reverseList(list) {\n        var prev = null;\n        var next = null;\n        var item = list;\n\n        while (item !== null) {\n            next = item.prev;\n            item.prev = prev;\n            prev = item;\n            item = next;\n        }\n\n        return prev;\n    }\n\n    function areStringsEqualCaseInsensitive(testStr, referenceStr) {\n        if (testStr.length !== referenceStr.length) {\n            return false;\n        }\n\n        for (var i = 0; i < testStr.length; i++) {\n            var testCode = testStr.charCodeAt(i);\n            var referenceCode = referenceStr.charCodeAt(i);\n\n            // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n            if (testCode >= 0x0041 && testCode <= 0x005A) {\n                testCode = testCode | 32;\n            }\n\n            if (testCode !== referenceCode) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function isCommaContextStart(token) {\n        if (token === null) {\n            return true;\n        }\n\n        return (\n            token.type === TYPE$6.Comma ||\n            token.type === TYPE$6.Function ||\n            token.type === TYPE$6.LeftParenthesis ||\n            token.type === TYPE$6.LeftSquareBracket ||\n            token.type === TYPE$6.LeftCurlyBracket ||\n            token.type === TYPE$6.Delim\n        );\n    }\n\n    function isCommaContextEnd(token) {\n        if (token === null) {\n            return true;\n        }\n\n        return (\n            token.type === TYPE$6.RightParenthesis ||\n            token.type === TYPE$6.RightSquareBracket ||\n            token.type === TYPE$6.RightCurlyBracket ||\n            token.type === TYPE$6.Delim\n        );\n    }\n\n    function internalMatch(tokens, state, syntaxes) {\n        function moveToNextToken() {\n            do {\n                tokenIndex++;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n            } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));\n        }\n\n        function getNextToken(offset) {\n            var nextIndex = tokenIndex + offset;\n\n            return nextIndex < tokens.length ? tokens[nextIndex] : null;\n        }\n\n        function stateSnapshotFromSyntax(nextState, prev) {\n            return {\n                nextState: nextState,\n                matchStack: matchStack,\n                syntaxStack: syntaxStack,\n                thenStack: thenStack,\n                tokenIndex: tokenIndex,\n                prev: prev\n            };\n        }\n\n        function pushThenStack(nextState) {\n            thenStack = {\n                nextState: nextState,\n                matchStack: matchStack,\n                syntaxStack: syntaxStack,\n                prev: thenStack\n            };\n        }\n\n        function pushElseStack(nextState) {\n            elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n        }\n\n        function addTokenToMatch() {\n            matchStack = {\n                type: TOKEN,\n                syntax: state.syntax,\n                token: token,\n                prev: matchStack\n            };\n\n            moveToNextToken();\n            syntaxStash = null;\n\n            if (tokenIndex > longestMatch) {\n                longestMatch = tokenIndex;\n            }\n        }\n\n        function openSyntax() {\n            syntaxStack = {\n                syntax: state.syntax,\n                opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n                prev: syntaxStack\n            };\n\n            matchStack = {\n                type: OPEN_SYNTAX,\n                syntax: state.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        function closeSyntax() {\n            if (matchStack.type === OPEN_SYNTAX) {\n                matchStack = matchStack.prev;\n            } else {\n                matchStack = {\n                    type: CLOSE_SYNTAX,\n                    syntax: syntaxStack.syntax,\n                    token: matchStack.token,\n                    prev: matchStack\n                };\n            }\n\n            syntaxStack = syntaxStack.prev;\n        }\n\n        var syntaxStack = null;\n        var thenStack = null;\n        var elseStack = null;\n\n        // null – stashing allowed, nothing stashed\n        // false – stashing disabled, nothing stashed\n        // anithing else – fail stashable syntaxes, some syntax stashed\n        var syntaxStash = null;\n\n        var iterationCount = 0; // count iterations and prevent infinite loop\n        var exitReason = null;\n\n        var token = null;\n        var tokenIndex = -1;\n        var longestMatch = 0;\n        var matchStack = {\n            type: STUB,\n            syntax: null,\n            token: null,\n            prev: null\n        };\n\n        moveToNextToken();\n\n        while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n            // function mapList(list, fn) {\n            //     var result = [];\n            //     while (list) {\n            //         result.unshift(fn(list));\n            //         list = list.prev;\n            //     }\n            //     return result;\n            // }\n            // console.log('--\\n',\n            //     '#' + iterationCount,\n            //     require('util').inspect({\n            //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n            //         token: token && token.value,\n            //         tokenIndex,\n            //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n            //     }, { depth: null })\n            // );\n            switch (state.type) {\n                case 'Match':\n                    if (thenStack === null) {\n                        // turn to MISMATCH when some tokens left unmatched\n                        if (token !== null) {\n                            // doesn't mismatch if just one token left and it's an IE hack\n                            if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                                state = MISMATCH$1;\n                                break;\n                            }\n                        }\n\n                        // break the main loop, return a result - MATCH\n                        exitReason = EXIT_REASON_MATCH;\n                        break;\n                    }\n\n                    // go to next syntax (`then` branch)\n                    state = thenStack.nextState;\n\n                    // check match is not empty\n                    if (state === DISALLOW_EMPTY$1) {\n                        if (thenStack.matchStack === matchStack) {\n                            state = MISMATCH$1;\n                            break;\n                        } else {\n                            state = MATCH$1;\n                        }\n                    }\n\n                    // close syntax if needed\n                    while (thenStack.syntaxStack !== syntaxStack) {\n                        closeSyntax();\n                    }\n\n                    // pop stack\n                    thenStack = thenStack.prev;\n                    break;\n\n                case 'Mismatch':\n                    // when some syntax is stashed\n                    if (syntaxStash !== null && syntaxStash !== false) {\n                        // there is no else branches or a branch reduce match stack\n                        if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                            // restore state from the stash\n                            elseStack = syntaxStash;\n                            syntaxStash = false; // disable stashing\n                        }\n                    } else if (elseStack === null) {\n                        // no else branches -> break the main loop\n                        // return a result - MISMATCH\n                        exitReason = EXIT_REASON_MISMATCH;\n                        break;\n                    }\n\n                    // go to next syntax (`else` branch)\n                    state = elseStack.nextState;\n\n                    // restore all the rest stack states\n                    thenStack = elseStack.thenStack;\n                    syntaxStack = elseStack.syntaxStack;\n                    matchStack = elseStack.matchStack;\n                    tokenIndex = elseStack.tokenIndex;\n                    token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                    // pop stack\n                    elseStack = elseStack.prev;\n                    break;\n\n                case 'MatchGraph':\n                    state = state.match;\n                    break;\n\n                case 'If':\n                    // IMPORTANT: else stack push must go first,\n                    // since it stores the state of thenStack before changes\n                    if (state.else !== MISMATCH$1) {\n                        pushElseStack(state.else);\n                    }\n\n                    if (state.then !== MATCH$1) {\n                        pushThenStack(state.then);\n                    }\n\n                    state = state.match;\n                    break;\n\n                case 'MatchOnce':\n                    state = {\n                        type: 'MatchOnceBuffer',\n                        syntax: state,\n                        index: 0,\n                        mask: 0\n                    };\n                    break;\n\n                case 'MatchOnceBuffer':\n                    var terms = state.syntax.terms;\n\n                    if (state.index === terms.length) {\n                        // no matches at all or it's required all terms to be matched\n                        if (state.mask === 0 || state.syntax.all) {\n                            state = MISMATCH$1;\n                            break;\n                        }\n\n                        // a partial match is ok\n                        state = MATCH$1;\n                        break;\n                    }\n\n                    // all terms are matched\n                    if (state.mask === (1 << terms.length) - 1) {\n                        state = MATCH$1;\n                        break;\n                    }\n\n                    for (; state.index < terms.length; state.index++) {\n                        var matchFlag = 1 << state.index;\n\n                        if ((state.mask & matchFlag) === 0) {\n                            // IMPORTANT: else stack push must go first,\n                            // since it stores the state of thenStack before changes\n                            pushElseStack(state);\n                            pushThenStack({\n                                type: 'AddMatchOnce',\n                                syntax: state.syntax,\n                                mask: state.mask | matchFlag\n                            });\n\n                            // match\n                            state = terms[state.index++];\n                            break;\n                        }\n                    }\n                    break;\n\n                case 'AddMatchOnce':\n                    state = {\n                        type: 'MatchOnceBuffer',\n                        syntax: state.syntax,\n                        index: 0,\n                        mask: state.mask\n                    };\n                    break;\n\n                case 'Enum':\n                    if (token !== null) {\n                        var name = token.value.toLowerCase();\n\n                        // drop \\0 and \\9 hack from keyword name\n                        if (name.indexOf('\\\\') !== -1) {\n                            name = name.replace(/\\\\[09].*$/, '');\n                        }\n\n                        if (hasOwnProperty$1.call(state.map, name)) {\n                            state = state.map[name];\n                            break;\n                        }\n                    }\n\n                    state = MISMATCH$1;\n                    break;\n\n                case 'Generic':\n                    var opts = syntaxStack !== null ? syntaxStack.opts : null;\n                    var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                    if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                        while (tokenIndex < lastTokenIndex) {\n                            addTokenToMatch();\n                        }\n\n                        state = MATCH$1;\n                    } else {\n                        state = MISMATCH$1;\n                    }\n\n                    break;\n\n                case 'Type':\n                case 'Property':\n                    var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                    var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                    if (!dictSyntax || !dictSyntax.match) {\n                        throw new Error(\n                            'Bad syntax reference: ' +\n                            (state.type === 'Type'\n                                ? '<' + state.name + '>'\n                                : '<\\'' + state.name + '\\'>')\n                        );\n                    }\n\n                    // stash a syntax for types with low priority\n                    if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                        var lowPriorityMatching =\n                            // https://drafts.csswg.org/css-values-4/#custom-idents\n                            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                            // can only claim the keyword if no other unfulfilled production can claim it.\n                            (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||\n\n                            // https://drafts.csswg.org/css-values-4/#lengths\n                            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                            // it must parse as a <number>\n                            (state.name === 'length' && token.value === '0');\n\n                        if (lowPriorityMatching) {\n                            if (syntaxStash === null) {\n                                syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                            }\n\n                            state = MISMATCH$1;\n                            break;\n                        }\n                    }\n\n                    openSyntax();\n                    state = dictSyntax.match;\n                    break;\n\n                case 'Keyword':\n                    var name = state.name;\n\n                    if (token !== null) {\n                        var keywordName = token.value;\n\n                        // drop \\0 and \\9 hack from keyword name\n                        if (keywordName.indexOf('\\\\') !== -1) {\n                            keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                        }\n\n                        if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                            addTokenToMatch();\n                            state = MATCH$1;\n                            break;\n                        }\n                    }\n\n                    state = MISMATCH$1;\n                    break;\n\n                case 'AtKeyword':\n                case 'Function':\n                    if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                        addTokenToMatch();\n                        state = MATCH$1;\n                        break;\n                    }\n\n                    state = MISMATCH$1;\n                    break;\n\n                case 'Token':\n                    if (token !== null && token.value === state.value) {\n                        addTokenToMatch();\n                        state = MATCH$1;\n                        break;\n                    }\n\n                    state = MISMATCH$1;\n                    break;\n\n                case 'Comma':\n                    if (token !== null && token.type === TYPE$6.Comma) {\n                        if (isCommaContextStart(matchStack.token)) {\n                            state = MISMATCH$1;\n                        } else {\n                            addTokenToMatch();\n                            state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;\n                        }\n                    } else {\n                        state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;\n                    }\n\n                    break;\n\n                case 'String':\n                    var string = '';\n\n                    for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                        string += tokens[lastTokenIndex].value;\n                    }\n\n                    if (areStringsEqualCaseInsensitive(string, state.value)) {\n                        while (tokenIndex < lastTokenIndex) {\n                            addTokenToMatch();\n                        }\n\n                        state = MATCH$1;\n                    } else {\n                        state = MISMATCH$1;\n                    }\n\n                    break;\n\n                default:\n                    throw new Error('Unknown node type: ' + state.type);\n            }\n        }\n\n        totalIterationCount += iterationCount;\n\n        switch (exitReason) {\n            case null:\n                console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n                exitReason = EXIT_REASON_ITERATION_LIMIT;\n                matchStack = null;\n                break;\n\n            case EXIT_REASON_MATCH:\n                while (syntaxStack !== null) {\n                    closeSyntax();\n                }\n                break;\n\n            default:\n                matchStack = null;\n        }\n\n        return {\n            tokens: tokens,\n            reason: exitReason,\n            iterations: iterationCount,\n            match: matchStack,\n            longestMatch: longestMatch\n        };\n    }\n\n    function matchAsList(tokens, matchGraph, syntaxes) {\n        var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n        if (matchResult.match !== null) {\n            var item = reverseList(matchResult.match).prev;\n\n            matchResult.match = [];\n\n            while (item !== null) {\n                switch (item.type) {\n                    case STUB:\n                        break;\n\n                    case OPEN_SYNTAX:\n                    case CLOSE_SYNTAX:\n                        matchResult.match.push({\n                            type: item.type,\n                            syntax: item.syntax\n                        });\n                        break;\n\n                    default:\n                        matchResult.match.push({\n                            token: item.token.value,\n                            node: item.token.node\n                        });\n                        break;\n                }\n\n                item = item.prev;\n            }\n        }\n\n        return matchResult;\n    }\n\n    function matchAsTree(tokens, matchGraph, syntaxes) {\n        var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n        if (matchResult.match === null) {\n            return matchResult;\n        }\n\n        var item = matchResult.match;\n        var host = matchResult.match = {\n            syntax: matchGraph.syntax || null,\n            match: []\n        };\n        var hostStack = [host];\n\n        // revert a list and start with 2nd item since 1st is a stub item\n        item = reverseList(item).prev;\n\n        // build a tree\n        while (item !== null) {\n            switch (item.type) {\n                case OPEN_SYNTAX:\n                    host.match.push(host = {\n                        syntax: item.syntax,\n                        match: []\n                    });\n                    hostStack.push(host);\n                    break;\n\n                case CLOSE_SYNTAX:\n                    hostStack.pop();\n                    host = hostStack[hostStack.length - 1];\n                    break;\n\n                default:\n                    host.match.push({\n                        syntax: item.syntax || null,\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n            }\n\n            item = item.prev;\n        }\n\n        return matchResult;\n    }\n\n    var match = {\n        matchAsList: matchAsList,\n        matchAsTree: matchAsTree,\n        getTotalIterationCount: function() {\n            return totalIterationCount;\n        }\n    };\n\n    function getTrace(node) {\n        function shouldPutToTrace(syntax) {\n            if (syntax === null) {\n                return false;\n            }\n\n            return (\n                syntax.type === 'Type' ||\n                syntax.type === 'Property' ||\n                syntax.type === 'Keyword'\n            );\n        }\n\n        function hasMatch(matchNode) {\n            if (Array.isArray(matchNode.match)) {\n                // use for-loop for better perfomance\n                for (var i = 0; i < matchNode.match.length; i++) {\n                    if (hasMatch(matchNode.match[i])) {\n                        if (shouldPutToTrace(matchNode.syntax)) {\n                            result.unshift(matchNode.syntax);\n                        }\n\n                        return true;\n                    }\n                }\n            } else if (matchNode.node === node) {\n                result = shouldPutToTrace(matchNode.syntax)\n                    ? [matchNode.syntax]\n                    : [];\n\n                return true;\n            }\n\n            return false;\n        }\n\n        var result = null;\n\n        if (this.matched !== null) {\n            hasMatch(this.matched);\n        }\n\n        return result;\n    }\n\n    function testNode(match, node, fn) {\n        var trace = getTrace.call(match, node);\n\n        if (trace === null) {\n            return false;\n        }\n\n        return trace.some(fn);\n    }\n\n    function isType(node, type) {\n        return testNode(this, node, function(matchNode) {\n            return matchNode.type === 'Type' && matchNode.name === type;\n        });\n    }\n\n    function isProperty(node, property) {\n        return testNode(this, node, function(matchNode) {\n            return matchNode.type === 'Property' && matchNode.name === property;\n        });\n    }\n\n    function isKeyword(node) {\n        return testNode(this, node, function(matchNode) {\n            return matchNode.type === 'Keyword';\n        });\n    }\n\n    var trace = {\n        getTrace: getTrace,\n        isType: isType,\n        isProperty: isProperty,\n        isKeyword: isKeyword\n    };\n\n    function getFirstMatchNode(matchNode) {\n        if ('node' in matchNode) {\n            return matchNode.node;\n        }\n\n        return getFirstMatchNode(matchNode.match[0]);\n    }\n\n    function getLastMatchNode(matchNode) {\n        if ('node' in matchNode) {\n            return matchNode.node;\n        }\n\n        return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);\n    }\n\n    function matchFragments(lexer, ast, match, type, name) {\n        function findFragments(matchNode) {\n            if (matchNode.syntax !== null &&\n                matchNode.syntax.type === type &&\n                matchNode.syntax.name === name) {\n                var start = getFirstMatchNode(matchNode);\n                var end = getLastMatchNode(matchNode);\n\n                lexer.syntax.walk(ast, function(node, item, list) {\n                    if (node === start) {\n                        var nodes = new List_1();\n\n                        do {\n                            nodes.appendData(item.data);\n\n                            if (item.data === end) {\n                                break;\n                            }\n\n                            item = item.next;\n                        } while (item !== null);\n\n                        fragments.push({\n                            parent: list,\n                            nodes: nodes\n                        });\n                    }\n                });\n            }\n\n            if (Array.isArray(matchNode.match)) {\n                matchNode.match.forEach(findFragments);\n            }\n        }\n\n        var fragments = [];\n\n        if (match.matched !== null) {\n            findFragments(match.matched);\n        }\n\n        return fragments;\n    }\n\n    var search = {\n        matchFragments: matchFragments\n    };\n\n    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\n    function isValidNumber(value) {\n        // Number.isInteger(value) && value >= 0\n        return (\n            typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value &&\n            value >= 0\n        );\n    }\n\n    function isValidLocation(loc) {\n        return (\n            Boolean(loc) &&\n            isValidNumber(loc.offset) &&\n            isValidNumber(loc.line) &&\n            isValidNumber(loc.column)\n        );\n    }\n\n    function createNodeStructureChecker(type, fields) {\n        return function checkNode(node, warn) {\n            if (!node || node.constructor !== Object) {\n                return warn(node, 'Type of node should be an Object');\n            }\n\n            for (var key in node) {\n                var valid = true;\n\n                if (hasOwnProperty$2.call(node, key) === false) {\n                    continue;\n                }\n\n                if (key === 'type') {\n                    if (node.type !== type) {\n                        warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                    }\n                } else if (key === 'loc') {\n                    if (node.loc === null) {\n                        continue;\n                    } else if (node.loc && node.loc.constructor === Object) {\n                        if (typeof node.loc.source !== 'string') {\n                            key += '.source';\n                        } else if (!isValidLocation(node.loc.start)) {\n                            key += '.start';\n                        } else if (!isValidLocation(node.loc.end)) {\n                            key += '.end';\n                        } else {\n                            continue;\n                        }\n                    }\n\n                    valid = false;\n                } else if (fields.hasOwnProperty(key)) {\n                    for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n                        var fieldType = fields[key][i];\n\n                        switch (fieldType) {\n                            case String:\n                                valid = typeof node[key] === 'string';\n                                break;\n\n                            case Boolean:\n                                valid = typeof node[key] === 'boolean';\n                                break;\n\n                            case null:\n                                valid = node[key] === null;\n                                break;\n\n                            default:\n                                if (typeof fieldType === 'string') {\n                                    valid = node[key] && node[key].type === fieldType;\n                                } else if (Array.isArray(fieldType)) {\n                                    valid = node[key] instanceof List_1;\n                                }\n                        }\n                    }\n                } else {\n                    warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n                }\n\n                if (!valid) {\n                    warn(node, 'Bad value for `' + type + '.' + key + '`');\n                }\n            }\n\n            for (var key in fields) {\n                if (hasOwnProperty$2.call(fields, key) &&\n                    hasOwnProperty$2.call(node, key) === false) {\n                    warn(node, 'Field `' + type + '.' + key + '` is missed');\n                }\n            }\n        };\n    }\n\n    function processStructure(name, nodeType) {\n        var structure = nodeType.structure;\n        var fields = {\n            type: String,\n            loc: true\n        };\n        var docs = {\n            type: '\"' + name + '\"'\n        };\n\n        for (var key in structure) {\n            if (hasOwnProperty$2.call(structure, key) === false) {\n                continue;\n            }\n\n            var docsTypes = [];\n            var fieldTypes = fields[key] = Array.isArray(structure[key])\n                ? structure[key].slice()\n                : [structure[key]];\n\n            for (var i = 0; i < fieldTypes.length; i++) {\n                var fieldType = fieldTypes[i];\n                if (fieldType === String || fieldType === Boolean) {\n                    docsTypes.push(fieldType.name);\n                } else if (fieldType === null) {\n                    docsTypes.push('null');\n                } else if (typeof fieldType === 'string') {\n                    docsTypes.push('<' + fieldType + '>');\n                } else if (Array.isArray(fieldType)) {\n                    docsTypes.push('List'); // TODO: use type enum\n                } else {\n                    throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n                }\n            }\n\n            docs[key] = docsTypes.join(' | ');\n        }\n\n        return {\n            docs: docs,\n            check: createNodeStructureChecker(name, fields)\n        };\n    }\n\n    var structure = {\n        getStructureFromConfig: function(config) {\n            var structure = {};\n\n            if (config.node) {\n                for (var name in config.node) {\n                    if (hasOwnProperty$2.call(config.node, name)) {\n                        var nodeType = config.node[name];\n\n                        if (nodeType.structure) {\n                            structure[name] = processStructure(name, nodeType);\n                        } else {\n                            throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                        }\n                    }\n                }\n            }\n\n            return structure;\n        }\n    };\n\n    var SyntaxReferenceError$1 = error.SyntaxReferenceError;\n    var MatchError$1 = error.MatchError;\n\n\n\n\n\n\n    var buildMatchGraph$1 = matchGraph.buildMatchGraph;\n    var matchAsTree$1 = match.matchAsTree;\n\n\n    var getStructureFromConfig = structure.getStructureFromConfig;\n    var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');\n    var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');\n\n    function dumpMapSyntax(map, compact, syntaxAsAst) {\n        var result = {};\n\n        for (var name in map) {\n            if (map[name].syntax) {\n                result[name] = syntaxAsAst\n                    ? map[name].syntax\n                    : generate_1(map[name].syntax, { compact: compact });\n            }\n        }\n\n        return result;\n    }\n\n    function valueHasVar(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n            if (tokens[i].value.toLowerCase() === 'var(') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function buildMatchResult(match, error, iterations) {\n        return {\n            matched: match,\n            iterations: iterations,\n            error: error,\n            getTrace: trace.getTrace,\n            isType: trace.isType,\n            isProperty: trace.isProperty,\n            isKeyword: trace.isKeyword\n        };\n    }\n\n    function matchSyntax(lexer, syntax, value, useCommon) {\n        var tokens = prepareTokens_1(value, lexer.syntax);\n        var result;\n\n        if (valueHasVar(tokens)) {\n            return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n        }\n\n        if (useCommon) {\n            result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);\n        }\n\n        if (!useCommon || !result.match) {\n            result = matchAsTree$1(tokens, syntax.match, lexer);\n            if (!result.match) {\n                return buildMatchResult(\n                    null,\n                    new MatchError$1(result.reason, syntax.syntax, value, result),\n                    result.iterations\n                );\n            }\n        }\n\n        return buildMatchResult(result.match, null, result.iterations);\n    }\n\n    var Lexer = function(config, syntax, structure) {\n        this.valueCommonSyntax = cssWideKeywords$1;\n        this.syntax = syntax;\n        this.generic = false;\n        this.atrules = {};\n        this.properties = {};\n        this.types = {};\n        this.structure = structure || getStructureFromConfig(config);\n\n        if (config) {\n            if (config.types) {\n                for (var name in config.types) {\n                    this.addType_(name, config.types[name]);\n                }\n            }\n\n            if (config.generic) {\n                this.generic = true;\n                for (var name in generic) {\n                    this.addType_(name, generic[name]);\n                }\n            }\n\n            if (config.atrules) {\n                for (var name in config.atrules) {\n                    this.addAtrule_(name, config.atrules[name]);\n                }\n            }\n\n            if (config.properties) {\n                for (var name in config.properties) {\n                    this.addProperty_(name, config.properties[name]);\n                }\n            }\n        }\n    };\n\n    Lexer.prototype = {\n        structure: {},\n        checkStructure: function(ast) {\n            function collectWarning(node, message) {\n                warns.push({\n                    node: node,\n                    message: message\n                });\n            }\n\n            var structure = this.structure;\n            var warns = [];\n\n            this.syntax.walk(ast, function(node) {\n                if (structure.hasOwnProperty(node.type)) {\n                    structure[node.type].check(node, collectWarning);\n                } else {\n                    collectWarning(node, 'Unknown node type `' + node.type + '`');\n                }\n            });\n\n            return warns.length ? warns : false;\n        },\n\n        createDescriptor: function(syntax, type, name) {\n            var ref = {\n                type: type,\n                name: name\n            };\n            var descriptor = {\n                type: type,\n                name: name,\n                syntax: null,\n                match: null\n            };\n\n            if (typeof syntax === 'function') {\n                descriptor.match = buildMatchGraph$1(syntax, ref);\n            } else {\n                if (typeof syntax === 'string') {\n                    // lazy parsing on first access\n                    Object.defineProperty(descriptor, 'syntax', {\n                        get: function() {\n                            Object.defineProperty(descriptor, 'syntax', {\n                                value: parse_1(syntax)\n                            });\n\n                            return descriptor.syntax;\n                        }\n                    });\n                } else {\n                    descriptor.syntax = syntax;\n                }\n\n                // lazy graph build on first access\n                Object.defineProperty(descriptor, 'match', {\n                    get: function() {\n                        Object.defineProperty(descriptor, 'match', {\n                            value: buildMatchGraph$1(descriptor.syntax, ref)\n                        });\n\n                        return descriptor.match;\n                    }\n                });\n            }\n\n            return descriptor;\n        },\n        addAtrule_: function(name, syntax) {\n            this.atrules[name] = {\n                prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n                descriptors: syntax.descriptors\n                    ? Object.keys(syntax.descriptors).reduce((res, name) => {\n                        res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);\n                        return res;\n                    }, {})\n                    : null\n            };\n        },\n        addProperty_: function(name, syntax) {\n            this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n        },\n        addType_: function(name, syntax) {\n            this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n            if (syntax === generic['-ms-legacy-expression']) {\n                this.valueCommonSyntax = cssWideKeywordsWithExpression;\n            }\n        },\n\n        matchAtrulePrelude: function(atruleName, prelude) {\n            var atrule = names.keyword(atruleName);\n\n            var atrulePreludeSyntax = atrule.vendor\n                ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)\n                : this.getAtrulePrelude(atrule.name);\n\n            if (!atrulePreludeSyntax) {\n                if (atrule.basename in this.atrules) {\n                    return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));\n                }\n\n                return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));\n            }\n\n            return matchSyntax(this, atrulePreludeSyntax, prelude, true);\n        },\n        matchAtruleDescriptor: function(atruleName, descriptorName, value) {\n            var atrule = names.keyword(atruleName);\n            var descriptor = names.keyword(descriptorName);\n\n            var atruleEntry = atrule.vendor\n                ? this.atrules[atrule.name] || this.atrules[atrule.basename]\n                : this.atrules[atrule.name];\n\n            if (!atruleEntry) {\n                return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));\n            }\n\n            if (!atruleEntry.descriptors) {\n                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));\n            }\n\n            var atruleDescriptorSyntax = descriptor.vendor\n                ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]\n                : atruleEntry.descriptors[descriptor.name];\n\n            if (!atruleDescriptorSyntax) {\n                return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));\n            }\n\n            return matchSyntax(this, atruleDescriptorSyntax, value, true);\n        },\n        matchDeclaration: function(node) {\n            if (node.type !== 'Declaration') {\n                return buildMatchResult(null, new Error('Not a Declaration node'));\n            }\n\n            return this.matchProperty(node.property, node.value);\n        },\n        matchProperty: function(propertyName, value) {\n            var property = names.property(propertyName);\n\n            // don't match syntax for a custom property\n            if (property.custom) {\n                return buildMatchResult(null, new Error('Lexer matching doesn\\'t applicable for custom properties'));\n            }\n\n            var propertySyntax = property.vendor\n                ? this.getProperty(property.name) || this.getProperty(property.basename)\n                : this.getProperty(property.name);\n\n            if (!propertySyntax) {\n                return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));\n            }\n\n            return matchSyntax(this, propertySyntax, value, true);\n        },\n        matchType: function(typeName, value) {\n            var typeSyntax = this.getType(typeName);\n\n            if (!typeSyntax) {\n                return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));\n            }\n\n            return matchSyntax(this, typeSyntax, value, false);\n        },\n        match: function(syntax, value) {\n            if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n                return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));\n            }\n\n            if (typeof syntax === 'string' || !syntax.match) {\n                syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n            }\n\n            return matchSyntax(this, syntax, value, false);\n        },\n\n        findValueFragments: function(propertyName, value, type, name) {\n            return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n        },\n        findDeclarationValueFragments: function(declaration, type, name) {\n            return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n        },\n        findAllFragments: function(ast, type, name) {\n            var result = [];\n\n            this.syntax.walk(ast, {\n                visit: 'Declaration',\n                enter: function(declaration) {\n                    result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n                }.bind(this)\n            });\n\n            return result;\n        },\n\n        getAtrulePrelude: function(atruleName) {\n            return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;\n        },\n        getAtruleDescriptor: function(atruleName, name) {\n            return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators\n                ? this.atrules[atruleName].declarators[name] || null\n                : null;\n        },\n        getProperty: function(name) {\n            return this.properties.hasOwnProperty(name) ? this.properties[name] : null;\n        },\n        getType: function(name) {\n            return this.types.hasOwnProperty(name) ? this.types[name] : null;\n        },\n\n        validate: function() {\n            function validate(syntax, name, broken, descriptor) {\n                if (broken.hasOwnProperty(name)) {\n                    return broken[name];\n                }\n\n                broken[name] = false;\n                if (descriptor.syntax !== null) {\n                    walk(descriptor.syntax, function(node) {\n                        if (node.type !== 'Type' && node.type !== 'Property') {\n                            return;\n                        }\n\n                        var map = node.type === 'Type' ? syntax.types : syntax.properties;\n                        var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                        if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n                            broken[name] = true;\n                        }\n                    }, this);\n                }\n            }\n\n            var brokenTypes = {};\n            var brokenProperties = {};\n\n            for (var key in this.types) {\n                validate(this, key, brokenTypes, this.types[key]);\n            }\n\n            for (var key in this.properties) {\n                validate(this, key, brokenProperties, this.properties[key]);\n            }\n\n            brokenTypes = Object.keys(brokenTypes).filter(function(name) {\n                return brokenTypes[name];\n            });\n            brokenProperties = Object.keys(brokenProperties).filter(function(name) {\n                return brokenProperties[name];\n            });\n\n            if (brokenTypes.length || brokenProperties.length) {\n                return {\n                    types: brokenTypes,\n                    properties: brokenProperties\n                };\n            }\n\n            return null;\n        },\n        dump: function(syntaxAsAst, pretty) {\n            return {\n                generic: this.generic,\n                types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n                properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)\n            };\n        },\n        toString: function() {\n            return JSON.stringify(this.dump());\n        }\n    };\n\n    var Lexer_1 = Lexer;\n\n    var definitionSyntax = {\n        SyntaxError: _SyntaxError$1,\n        parse: parse_1,\n        generate: generate_1,\n        walk: walk\n    };\n\n    var isBOM$2 = tokenizer.isBOM;\n\n    var N$3 = 10;\n    var F$2 = 12;\n    var R$2 = 13;\n\n    function computeLinesAndColumns(host, source) {\n        var sourceLength = source.length;\n        var lines = adoptBuffer(host.lines, sourceLength); // +1\n        var line = host.startLine;\n        var columns = adoptBuffer(host.columns, sourceLength);\n        var column = host.startColumn;\n        var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;\n\n        for (var i = startOffset; i < sourceLength; i++) { // -1\n            var code = source.charCodeAt(i);\n\n            lines[i] = line;\n            columns[i] = column++;\n\n            if (code === N$3 || code === R$2 || code === F$2) {\n                if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {\n                    i++;\n                    lines[i] = line;\n                    columns[i] = column;\n                }\n\n                line++;\n                column = 1;\n            }\n        }\n\n        lines[i] = line;\n        columns[i] = column;\n\n        host.lines = lines;\n        host.columns = columns;\n    }\n\n    var OffsetToLocation = function() {\n        this.lines = null;\n        this.columns = null;\n        this.linesAndColumnsComputed = false;\n    };\n\n    OffsetToLocation.prototype = {\n        setSource: function(source, startOffset, startLine, startColumn) {\n            this.source = source;\n            this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;\n            this.startLine = typeof startLine === 'undefined' ? 1 : startLine;\n            this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;\n            this.linesAndColumnsComputed = false;\n        },\n\n        ensureLinesAndColumnsComputed: function() {\n            if (!this.linesAndColumnsComputed) {\n                computeLinesAndColumns(this, this.source);\n                this.linesAndColumnsComputed = true;\n            }\n        },\n        getLocation: function(offset, filename) {\n            this.ensureLinesAndColumnsComputed();\n\n            return {\n                source: filename,\n                offset: this.startOffset + offset,\n                line: this.lines[offset],\n                column: this.columns[offset]\n            };\n        },\n        getLocationRange: function(start, end, filename) {\n            this.ensureLinesAndColumnsComputed();\n\n            return {\n                source: filename,\n                start: {\n                    offset: this.startOffset + start,\n                    line: this.lines[start],\n                    column: this.columns[start]\n                },\n                end: {\n                    offset: this.startOffset + end,\n                    line: this.lines[end],\n                    column: this.columns[end]\n                }\n            };\n        }\n    };\n\n    var OffsetToLocation_1 = OffsetToLocation;\n\n    var TYPE$7 = tokenizer.TYPE;\n    var WHITESPACE$2 = TYPE$7.WhiteSpace;\n    var COMMENT$2 = TYPE$7.Comment;\n\n    var sequence = function readSequence(recognizer) {\n        var children = this.createList();\n        var child = null;\n        var context = {\n            recognizer: recognizer,\n            space: null,\n            ignoreWS: false,\n            ignoreWSAfter: false\n        };\n\n        this.scanner.skipSC();\n\n        while (!this.scanner.eof) {\n            switch (this.scanner.tokenType) {\n                case COMMENT$2:\n                    this.scanner.next();\n                    continue;\n\n                case WHITESPACE$2:\n                    if (context.ignoreWS) {\n                        this.scanner.next();\n                    } else {\n                        context.space = this.WhiteSpace();\n                    }\n                    continue;\n            }\n\n            child = recognizer.getNode.call(this, context);\n\n            if (child === undefined) {\n                break;\n            }\n\n            if (context.space !== null) {\n                children.push(context.space);\n                context.space = null;\n            }\n\n            children.push(child);\n\n            if (context.ignoreWSAfter) {\n                context.ignoreWSAfter = false;\n                context.ignoreWS = true;\n            } else {\n                context.ignoreWS = false;\n            }\n        }\n\n        return children;\n    };\n\n    var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;\n\n    var noop$2 = function() {};\n\n    var TYPE$8 = _const.TYPE;\n    var NAME$2 = _const.NAME;\n    var WHITESPACE$3 = TYPE$8.WhiteSpace;\n    var IDENT$2 = TYPE$8.Ident;\n    var FUNCTION = TYPE$8.Function;\n    var URL = TYPE$8.Url;\n    var HASH = TYPE$8.Hash;\n    var PERCENTAGE = TYPE$8.Percentage;\n    var NUMBER$2 = TYPE$8.Number;\n    var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)\n    var NULL = 0;\n\n    function createParseContext(name) {\n        return function() {\n            return this[name]();\n        };\n    }\n\n    function processConfig(config) {\n        var parserConfig = {\n            context: {},\n            scope: {},\n            atrule: {},\n            pseudo: {}\n        };\n\n        if (config.parseContext) {\n            for (var name in config.parseContext) {\n                switch (typeof config.parseContext[name]) {\n                    case 'function':\n                        parserConfig.context[name] = config.parseContext[name];\n                        break;\n\n                    case 'string':\n                        parserConfig.context[name] = createParseContext(config.parseContext[name]);\n                        break;\n                }\n            }\n        }\n\n        if (config.scope) {\n            for (var name in config.scope) {\n                parserConfig.scope[name] = config.scope[name];\n            }\n        }\n\n        if (config.atrule) {\n            for (var name in config.atrule) {\n                var atrule = config.atrule[name];\n\n                if (atrule.parse) {\n                    parserConfig.atrule[name] = atrule.parse;\n                }\n            }\n        }\n\n        if (config.pseudo) {\n            for (var name in config.pseudo) {\n                var pseudo = config.pseudo[name];\n\n                if (pseudo.parse) {\n                    parserConfig.pseudo[name] = pseudo.parse;\n                }\n            }\n        }\n\n        if (config.node) {\n            for (var name in config.node) {\n                parserConfig[name] = config.node[name].parse;\n            }\n        }\n\n        return parserConfig;\n    }\n\n    var create = function createParser(config) {\n        var parser = {\n            scanner: new TokenStream_1(),\n            locationMap: new OffsetToLocation_1(),\n\n            filename: '<unknown>',\n            needPositions: false,\n            onParseError: noop$2,\n            onParseErrorThrow: false,\n            parseAtrulePrelude: true,\n            parseRulePrelude: true,\n            parseValue: true,\n            parseCustomProperty: false,\n\n            readSequence: sequence,\n\n            createList: function() {\n                return new List_1();\n            },\n            createSingleNodeList: function(node) {\n                return new List_1().appendData(node);\n            },\n            getFirstListNode: function(list) {\n                return list && list.first();\n            },\n            getLastListNode: function(list) {\n                return list.last();\n            },\n\n            parseWithFallback: function(consumer, fallback) {\n                var startToken = this.scanner.tokenIndex;\n\n                try {\n                    return consumer.call(this);\n                } catch (e) {\n                    if (this.onParseErrorThrow) {\n                        throw e;\n                    }\n\n                    var fallbackNode = fallback.call(this, startToken);\n\n                    this.onParseErrorThrow = true;\n                    this.onParseError(e, fallbackNode);\n                    this.onParseErrorThrow = false;\n\n                    return fallbackNode;\n                }\n            },\n\n            lookupNonWSType: function(offset) {\n                do {\n                    var type = this.scanner.lookupType(offset++);\n                    if (type !== WHITESPACE$3) {\n                        return type;\n                    }\n                } while (type !== NULL);\n\n                return NULL;\n            },\n\n            eat: function(tokenType) {\n                if (this.scanner.tokenType !== tokenType) {\n                    var offset = this.scanner.tokenStart;\n                    var message = NAME$2[tokenType] + ' is expected';\n\n                    // tweak message and offset\n                    switch (tokenType) {\n                        case IDENT$2:\n                            // when identifier is expected but there is a function or url\n                            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n                                offset = this.scanner.tokenEnd - 1;\n                                message = 'Identifier is expected but function found';\n                            } else {\n                                message = 'Identifier is expected';\n                            }\n                            break;\n\n                        case HASH:\n                            if (this.scanner.isDelim(NUMBERSIGN$1)) {\n                                this.scanner.next();\n                                offset++;\n                                message = 'Name is expected';\n                            }\n                            break;\n\n                        case PERCENTAGE:\n                            if (this.scanner.tokenType === NUMBER$2) {\n                                offset = this.scanner.tokenEnd;\n                                message = 'Percent sign is expected';\n                            }\n                            break;\n\n                        default:\n                            // when test type is part of another token show error for current position + 1\n                            // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n                            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n                                offset = offset + 1;\n                            }\n                    }\n\n                    this.error(message, offset);\n                }\n\n                this.scanner.next();\n            },\n\n            consume: function(tokenType) {\n                var value = this.scanner.getTokenValue();\n\n                this.eat(tokenType);\n\n                return value;\n            },\n            consumeFunctionName: function() {\n                var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n\n                this.eat(FUNCTION);\n\n                return name;\n            },\n\n            getLocation: function(start, end) {\n                if (this.needPositions) {\n                    return this.locationMap.getLocationRange(\n                        start,\n                        end,\n                        this.filename\n                    );\n                }\n\n                return null;\n            },\n            getLocationFromList: function(list) {\n                if (this.needPositions) {\n                    var head = this.getFirstListNode(list);\n                    var tail = this.getLastListNode(list);\n                    return this.locationMap.getLocationRange(\n                        head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                        tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                        this.filename\n                    );\n                }\n\n                return null;\n            },\n\n            error: function(message, offset) {\n                var location = typeof offset !== 'undefined' && offset < this.scanner.source.length\n                    ? this.locationMap.getLocation(offset)\n                    : this.scanner.eof\n                        ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))\n                        : this.locationMap.getLocation(this.scanner.tokenStart);\n\n                throw new _SyntaxError(\n                    message || 'Unexpected input',\n                    this.scanner.source,\n                    location.offset,\n                    location.line,\n                    location.column\n                );\n            }\n        };\n\n        config = processConfig(config || {});\n        for (var key in config) {\n            parser[key] = config[key];\n        }\n\n        return function(source, options) {\n            options = options || {};\n\n            var context = options.context || 'default';\n            var ast;\n\n            tokenizer(source, parser.scanner);\n            parser.locationMap.setSource(\n                source,\n                options.offset,\n                options.line,\n                options.column\n            );\n\n            parser.filename = options.filename || '<unknown>';\n            parser.needPositions = Boolean(options.positions);\n            parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$2;\n            parser.onParseErrorThrow = false;\n            parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n            parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n            parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n            parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n            if (!parser.context.hasOwnProperty(context)) {\n                throw new Error('Unknown context `' + context + '`');\n            }\n\n            ast = parser.context[context].call(parser, options);\n\n            if (!parser.scanner.eof) {\n                parser.error();\n            }\n\n            return ast;\n        };\n    };\n\n    /* -*- Mode: js; js-indent-level: 2; -*- */\n    /*\n     * Copyright 2011 Mozilla Foundation and contributors\n     * Licensed under the New BSD license. See LICENSE or:\n     * http://opensource.org/licenses/BSD-3-Clause\n     */\n\n    var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n    /**\n     * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n     */\n    var encode = function (number) {\n      if (0 <= number && number < intToCharMap.length) {\n        return intToCharMap[number];\n      }\n      throw new TypeError(\"Must be between 0 and 63: \" + number);\n    };\n\n    /**\n     * Decode a single base 64 character code digit to an integer. Returns -1 on\n     * failure.\n     */\n    var decode = function (charCode) {\n      var bigA = 65;     // 'A'\n      var bigZ = 90;     // 'Z'\n\n      var littleA = 97;  // 'a'\n      var littleZ = 122; // 'z'\n\n      var zero = 48;     // '0'\n      var nine = 57;     // '9'\n\n      var plus = 43;     // '+'\n      var slash = 47;    // '/'\n\n      var littleOffset = 26;\n      var numberOffset = 52;\n\n      // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n      if (bigA <= charCode && charCode <= bigZ) {\n        return (charCode - bigA);\n      }\n\n      // 26 - 51: abcdefghijklmnopqrstuvwxyz\n      if (littleA <= charCode && charCode <= littleZ) {\n        return (charCode - littleA + littleOffset);\n      }\n\n      // 52 - 61: 0123456789\n      if (zero <= charCode && charCode <= nine) {\n        return (charCode - zero + numberOffset);\n      }\n\n      // 62: +\n      if (charCode == plus) {\n        return 62;\n      }\n\n      // 63: /\n      if (charCode == slash) {\n        return 63;\n      }\n\n      // Invalid base64 digit.\n      return -1;\n    };\n\n    var base64 = {\n    \tencode: encode,\n    \tdecode: decode\n    };\n\n    /* -*- Mode: js; js-indent-level: 2; -*- */\n    /*\n     * Copyright 2011 Mozilla Foundation and contributors\n     * Licensed under the New BSD license. See LICENSE or:\n     * http://opensource.org/licenses/BSD-3-Clause\n     *\n     * Based on the Base 64 VLQ implementation in Closure Compiler:\n     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n     *\n     * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions are\n     * met:\n     *\n     *  * Redistributions of source code must retain the above copyright\n     *    notice, this list of conditions and the following disclaimer.\n     *  * Redistributions in binary form must reproduce the above\n     *    copyright notice, this list of conditions and the following\n     *    disclaimer in the documentation and/or other materials provided\n     *    with the distribution.\n     *  * Neither the name of Google Inc. nor the names of its\n     *    contributors may be used to endorse or promote products derived\n     *    from this software without specific prior written permission.\n     *\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n     * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n     */\n\n\n\n    // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n    // length quantities we use in the source map spec, the first bit is the sign,\n    // the next four bits are the actual value, and the 6th bit is the\n    // continuation bit. The continuation bit tells us whether there are more\n    // digits in this value following this digit.\n    //\n    //   Continuation\n    //   |    Sign\n    //   |    |\n    //   V    V\n    //   101011\n\n    var VLQ_BASE_SHIFT = 5;\n\n    // binary: 100000\n    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n    // binary: 011111\n    var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n    // binary: 100000\n    var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n    /**\n     * Converts from a two-complement value to a value where the sign bit is\n     * placed in the least significant bit.  For example, as decimals:\n     *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n     *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n     */\n    function toVLQSigned(aValue) {\n      return aValue < 0\n        ? ((-aValue) << 1) + 1\n        : (aValue << 1) + 0;\n    }\n\n    /**\n     * Converts to a two-complement value from a value where the sign bit is\n     * placed in the least significant bit.  For example, as decimals:\n     *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n     *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n     */\n    function fromVLQSigned(aValue) {\n      var isNegative = (aValue & 1) === 1;\n      var shifted = aValue >> 1;\n      return isNegative\n        ? -shifted\n        : shifted;\n    }\n\n    /**\n     * Returns the base 64 VLQ encoded value.\n     */\n    var encode$1 = function base64VLQ_encode(aValue) {\n      var encoded = \"\";\n      var digit;\n\n      var vlq = toVLQSigned(aValue);\n\n      do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n          // There are still more digits in this value, so we must make sure the\n          // continuation bit is marked.\n          digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n      } while (vlq > 0);\n\n      return encoded;\n    };\n\n    /**\n     * Decodes the next base 64 VLQ value from the given string and returns the\n     * value and the rest of the string via the out parameter.\n     */\n    var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n      var strLen = aStr.length;\n      var result = 0;\n      var shift = 0;\n      var continuation, digit;\n\n      do {\n        if (aIndex >= strLen) {\n          throw new Error(\"Expected more digits in base 64 VLQ value.\");\n        }\n\n        digit = base64.decode(aStr.charCodeAt(aIndex++));\n        if (digit === -1) {\n          throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n        }\n\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n      } while (continuation);\n\n      aOutParam.value = fromVLQSigned(result);\n      aOutParam.rest = aIndex;\n    };\n\n    var base64Vlq = {\n    \tencode: encode$1,\n    \tdecode: decode$1\n    };\n\n    function createCommonjsModule(fn, module) {\n    \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n\n    function getCjsExportFromNamespace (n) {\n    \treturn n && n['default'] || n;\n    }\n\n    var util = createCommonjsModule(function (module, exports) {\n    /* -*- Mode: js; js-indent-level: 2; -*- */\n    /*\n     * Copyright 2011 Mozilla Foundation and contributors\n     * Licensed under the New BSD license. See LICENSE or:\n     * http://opensource.org/licenses/BSD-3-Clause\n     */\n\n    /**\n     * This is a helper function for getting values from parameter/options\n     * objects.\n     *\n     * @param args The object we are extracting values from\n     * @param name The name of the property we are getting.\n     * @param defaultValue An optional value to return if the property is missing\n     * from the object. If this is not specified and the property is missing, an\n     * error will be thrown.\n     */\n    function getArg(aArgs, aName, aDefaultValue) {\n      if (aName in aArgs) {\n        return aArgs[aName];\n      } else if (arguments.length === 3) {\n        return aDefaultValue;\n      } else {\n        throw new Error('\"' + aName + '\" is a required argument.');\n      }\n    }\n    exports.getArg = getArg;\n\n    var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\n    var dataUrlRegexp = /^data:.+\\,.+$/;\n\n    function urlParse(aUrl) {\n      var match = aUrl.match(urlRegexp);\n      if (!match) {\n        return null;\n      }\n      return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n      };\n    }\n    exports.urlParse = urlParse;\n\n    function urlGenerate(aParsedUrl) {\n      var url = '';\n      if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + ':';\n      }\n      url += '//';\n      if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + '@';\n      }\n      if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n      }\n      if (aParsedUrl.port) {\n        url += \":\" + aParsedUrl.port;\n      }\n      if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n      }\n      return url;\n    }\n    exports.urlGenerate = urlGenerate;\n\n    /**\n     * Normalizes a path, or the path portion of a URL:\n     *\n     * - Replaces consecutive slashes with one slash.\n     * - Removes unnecessary '.' parts.\n     * - Removes unnecessary '<dir>/..' parts.\n     *\n     * Based on code in the Node.js 'path' core module.\n     *\n     * @param aPath The path or url to normalize.\n     */\n    function normalize(aPath) {\n      var path = aPath;\n      var url = urlParse(aPath);\n      if (url) {\n        if (!url.path) {\n          return aPath;\n        }\n        path = url.path;\n      }\n      var isAbsolute = exports.isAbsolute(path);\n\n      var parts = path.split(/\\/+/);\n      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n        part = parts[i];\n        if (part === '.') {\n          parts.splice(i, 1);\n        } else if (part === '..') {\n          up++;\n        } else if (up > 0) {\n          if (part === '') {\n            // The first part is blank if the path is absolute. Trying to go\n            // above the root is a no-op. Therefore we can remove all '..' parts\n            // directly after the root.\n            parts.splice(i + 1, up);\n            up = 0;\n          } else {\n            parts.splice(i, 2);\n            up--;\n          }\n        }\n      }\n      path = parts.join('/');\n\n      if (path === '') {\n        path = isAbsolute ? '/' : '.';\n      }\n\n      if (url) {\n        url.path = path;\n        return urlGenerate(url);\n      }\n      return path;\n    }\n    exports.normalize = normalize;\n\n    /**\n     * Joins two paths/URLs.\n     *\n     * @param aRoot The root path or URL.\n     * @param aPath The path or URL to be joined with the root.\n     *\n     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n     *   first.\n     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n     *   is updated with the result and aRoot is returned. Otherwise the result\n     *   is returned.\n     *   - If aPath is absolute, the result is aPath.\n     *   - Otherwise the two paths are joined with a slash.\n     * - Joining for example 'http://' and 'www.example.com' is also supported.\n     */\n    function join(aRoot, aPath) {\n      if (aRoot === \"\") {\n        aRoot = \".\";\n      }\n      if (aPath === \"\") {\n        aPath = \".\";\n      }\n      var aPathUrl = urlParse(aPath);\n      var aRootUrl = urlParse(aRoot);\n      if (aRootUrl) {\n        aRoot = aRootUrl.path || '/';\n      }\n\n      // `join(foo, '//www.example.org')`\n      if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n          aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n      }\n\n      if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n      }\n\n      // `join('http://', 'www.example.com')`\n      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n      }\n\n      var joined = aPath.charAt(0) === '/'\n        ? aPath\n        : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n      if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n      }\n      return joined;\n    }\n    exports.join = join;\n\n    exports.isAbsolute = function (aPath) {\n      return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n    };\n\n    /**\n     * Make a path relative to a URL or another path.\n     *\n     * @param aRoot The root path or URL.\n     * @param aPath The path or URL to be made relative to aRoot.\n     */\n    function relative(aRoot, aPath) {\n      if (aRoot === \"\") {\n        aRoot = \".\";\n      }\n\n      aRoot = aRoot.replace(/\\/$/, '');\n\n      // It is possible for the path to be above the root. In this case, simply\n      // checking whether the root is a prefix of the path won't work. Instead, we\n      // need to remove components from the root one by one, until either we find\n      // a prefix that fits, or we run out of components to remove.\n      var level = 0;\n      while (aPath.indexOf(aRoot + '/') !== 0) {\n        var index = aRoot.lastIndexOf(\"/\");\n        if (index < 0) {\n          return aPath;\n        }\n\n        // If the only part of the root that is left is the scheme (i.e. http://,\n        // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n        // have exhausted all components, so the path is not relative to the root.\n        aRoot = aRoot.slice(0, index);\n        if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n          return aPath;\n        }\n\n        ++level;\n      }\n\n      // Make sure we add a \"../\" for each component we removed from the root.\n      return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n    }\n    exports.relative = relative;\n\n    var supportsNullProto = (function () {\n      var obj = Object.create(null);\n      return !('__proto__' in obj);\n    }());\n\n    function identity (s) {\n      return s;\n    }\n\n    /**\n     * Because behavior goes wacky when you set `__proto__` on objects, we\n     * have to prefix all the strings in our set with an arbitrary character.\n     *\n     * See https://github.com/mozilla/source-map/pull/31 and\n     * https://github.com/mozilla/source-map/issues/30\n     *\n     * @param String aStr\n     */\n    function toSetString(aStr) {\n      if (isProtoString(aStr)) {\n        return '$' + aStr;\n      }\n\n      return aStr;\n    }\n    exports.toSetString = supportsNullProto ? identity : toSetString;\n\n    function fromSetString(aStr) {\n      if (isProtoString(aStr)) {\n        return aStr.slice(1);\n      }\n\n      return aStr;\n    }\n    exports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n    function isProtoString(s) {\n      if (!s) {\n        return false;\n      }\n\n      var length = s.length;\n\n      if (length < 9 /* \"__proto__\".length */) {\n        return false;\n      }\n\n      if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n          s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n          s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n          s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n          s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n          s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n          s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n          s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n          s.charCodeAt(length - 9) !== 95  /* '_' */) {\n        return false;\n      }\n\n      for (var i = length - 10; i >= 0; i--) {\n        if (s.charCodeAt(i) !== 36 /* '$' */) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Comparator between two mappings where the original positions are compared.\n     *\n     * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n     * mappings with the same original source/line/column, but different generated\n     * line and column the same. Useful when searching for a mapping with a\n     * stubbed out mapping.\n     */\n    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n      var cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n      }\n\n      cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      return strcmp(mappingA.name, mappingB.name);\n    }\n    exports.compareByOriginalPositions = compareByOriginalPositions;\n\n    /**\n     * Comparator between two mappings with deflated source and name indices where\n     * the generated positions are compared.\n     *\n     * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n     * mappings with the same generated line and column, but different\n     * source/name/original line and column the same. Useful when searching for a\n     * mapping with a stubbed out mapping.\n     */\n    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n      var cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n      if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n      }\n\n      cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      return strcmp(mappingA.name, mappingB.name);\n    }\n    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n    function strcmp(aStr1, aStr2) {\n      if (aStr1 === aStr2) {\n        return 0;\n      }\n\n      if (aStr1 === null) {\n        return 1; // aStr2 !== null\n      }\n\n      if (aStr2 === null) {\n        return -1; // aStr1 !== null\n      }\n\n      if (aStr1 > aStr2) {\n        return 1;\n      }\n\n      return -1;\n    }\n\n    /**\n     * Comparator between two mappings with inflated source and name strings where\n     * the generated positions are compared.\n     */\n    function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n      var cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      return strcmp(mappingA.name, mappingB.name);\n    }\n    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n    /**\n     * Strip any JSON XSSI avoidance prefix from the string (as documented\n     * in the source maps specification), and then parse the string as\n     * JSON.\n     */\n    function parseSourceMapInput(str) {\n      return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n    }\n    exports.parseSourceMapInput = parseSourceMapInput;\n\n    /**\n     * Compute the URL of a source given the the source root, the source's\n     * URL, and the source map's URL.\n     */\n    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n      sourceURL = sourceURL || '';\n\n      if (sourceRoot) {\n        // This follows what Chrome does.\n        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n          sourceRoot += '/';\n        }\n        // The spec says:\n        //   Line 4: An optional source root, useful for relocating source\n        //   files on a server or removing repeated values in the\n        //   “sources” entry.  This value is prepended to the individual\n        //   entries in the “source” field.\n        sourceURL = sourceRoot + sourceURL;\n      }\n\n      // Historically, SourceMapConsumer did not take the sourceMapURL as\n      // a parameter.  This mode is still somewhat supported, which is why\n      // this code block is conditional.  However, it's preferable to pass\n      // the source map URL to SourceMapConsumer, so that this function\n      // can implement the source URL resolution algorithm as outlined in\n      // the spec.  This block is basically the equivalent of:\n      //    new URL(sourceURL, sourceMapURL).toString()\n      // ... except it avoids using URL, which wasn't available in the\n      // older releases of node still supported by this library.\n      //\n      // The spec says:\n      //   If the sources are not absolute URLs after prepending of the\n      //   “sourceRoot”, the sources are resolved relative to the\n      //   SourceMap (like resolving script src in a html document).\n      if (sourceMapURL) {\n        var parsed = urlParse(sourceMapURL);\n        if (!parsed) {\n          throw new Error(\"sourceMapURL could not be parsed\");\n        }\n        if (parsed.path) {\n          // Strip the last path component, but keep the \"/\".\n          var index = parsed.path.lastIndexOf('/');\n          if (index >= 0) {\n            parsed.path = parsed.path.substring(0, index + 1);\n          }\n        }\n        sourceURL = join(urlGenerate(parsed), sourceURL);\n      }\n\n      return normalize(sourceURL);\n    }\n    exports.computeSourceURL = computeSourceURL;\n    });\n    var util_1 = util.getArg;\n    var util_2 = util.urlParse;\n    var util_3 = util.urlGenerate;\n    var util_4 = util.normalize;\n    var util_5 = util.join;\n    var util_6 = util.isAbsolute;\n    var util_7 = util.relative;\n    var util_8 = util.toSetString;\n    var util_9 = util.fromSetString;\n    var util_10 = util.compareByOriginalPositions;\n    var util_11 = util.compareByGeneratedPositionsDeflated;\n    var util_12 = util.compareByGeneratedPositionsInflated;\n    var util_13 = util.parseSourceMapInput;\n    var util_14 = util.computeSourceURL;\n\n    /* -*- Mode: js; js-indent-level: 2; -*- */\n    /*\n     * Copyright 2011 Mozilla Foundation and contributors\n     * Licensed under the New BSD license. See LICENSE or:\n     * http://opensource.org/licenses/BSD-3-Clause\n     */\n\n\n    var has = Object.prototype.hasOwnProperty;\n    var hasNativeMap = typeof Map !== \"undefined\";\n\n    /**\n     * A data structure which is a combination of an array and a set. Adding a new\n     * member is O(1), testing for membership is O(1), and finding the index of an\n     * element is O(1). Removing elements from the set is not supported. Only\n     * strings are supported for membership.\n     */\n    function ArraySet() {\n      this._array = [];\n      this._set = hasNativeMap ? new Map() : Object.create(null);\n    }\n\n    /**\n     * Static method for creating ArraySet instances from an existing array.\n     */\n    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n      var set = new ArraySet();\n      for (var i = 0, len = aArray.length; i < len; i++) {\n        set.add(aArray[i], aAllowDuplicates);\n      }\n      return set;\n    };\n\n    /**\n     * Return how many unique items are in this ArraySet. If duplicates have been\n     * added, than those do not count towards the size.\n     *\n     * @returns Number\n     */\n    ArraySet.prototype.size = function ArraySet_size() {\n      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n    };\n\n    /**\n     * Add the given string to this set.\n     *\n     * @param String aStr\n     */\n    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n      var idx = this._array.length;\n      if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n      }\n      if (!isDuplicate) {\n        if (hasNativeMap) {\n          this._set.set(aStr, idx);\n        } else {\n          this._set[sStr] = idx;\n        }\n      }\n    };\n\n    /**\n     * Is the given string a member of this set?\n     *\n     * @param String aStr\n     */\n    ArraySet.prototype.has = function ArraySet_has(aStr) {\n      if (hasNativeMap) {\n        return this._set.has(aStr);\n      } else {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n      }\n    };\n\n    /**\n     * What is the index of the given string in the array?\n     *\n     * @param String aStr\n     */\n    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n      if (hasNativeMap) {\n        var idx = this._set.get(aStr);\n        if (idx >= 0) {\n            return idx;\n        }\n      } else {\n        var sStr = util.toSetString(aStr);\n        if (has.call(this._set, sStr)) {\n          return this._set[sStr];\n        }\n      }\n\n      throw new Error('\"' + aStr + '\" is not in the set.');\n    };\n\n    /**\n     * What is the element at the given index?\n     *\n     * @param Number aIdx\n     */\n    ArraySet.prototype.at = function ArraySet_at(aIdx) {\n      if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n      }\n      throw new Error('No element indexed by ' + aIdx);\n    };\n\n    /**\n     * Returns the array representation of this set (which has the proper indices\n     * indicated by indexOf). Note that this is a copy of the internal array used\n     * for storing the members so that no one can mess with internal state.\n     */\n    ArraySet.prototype.toArray = function ArraySet_toArray() {\n      return this._array.slice();\n    };\n\n    var ArraySet_1 = ArraySet;\n\n    var arraySet = {\n    \tArraySet: ArraySet_1\n    };\n\n    /* -*- Mode: js; js-indent-level: 2; -*- */\n    /*\n     * Copyright 2014 Mozilla Foundation and contributors\n     * Licensed under the New BSD license. See LICENSE or:\n     * http://opensource.org/licenses/BSD-3-Clause\n     */\n\n\n\n    /**\n     * Determine whether mappingB is after mappingA with respect to generated\n     * position.\n     */\n    function generatedPositionAfter(mappingA, mappingB) {\n      // Optimized for most common case\n      var lineA = mappingA.generatedLine;\n      var lineB = mappingB.generatedLine;\n      var columnA = mappingA.generatedColumn;\n      var columnB = mappingB.generatedColumn;\n      return lineB > lineA || lineB == lineA && columnB >= columnA ||\n             util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n    }\n\n    /**\n     * A data structure to provide a sorted view of accumulated mappings in a\n     * performance conscious manner. It trades a neglibable overhead in general\n     * case for a large speedup in case of mappings being added in order.\n     */\n    function MappingList() {\n      this._array = [];\n      this._sorted = true;\n      // Serves as infimum\n      this._last = {generatedLine: -1, generatedColumn: 0};\n    }\n\n    /**\n     * Iterate through internal items. This method takes the same arguments that\n     * `Array.prototype.forEach` takes.\n     *\n     * NOTE: The order of the mappings is NOT guaranteed.\n     */\n    MappingList.prototype.unsortedForEach =\n      function MappingList_forEach(aCallback, aThisArg) {\n        this._array.forEach(aCallback, aThisArg);\n      };\n\n    /**\n     * Add the given source mapping.\n     *\n     * @param Object aMapping\n     */\n    MappingList.prototype.add = function MappingList_add(aMapping) {\n      if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n      } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n      }\n    };\n\n    /**\n     * Returns the flat, sorted array of mappings. The mappings are sorted by\n     * generated position.\n     *\n     * WARNING: This method returns internal data without copying, for\n     * performance. The return value must NOT be mutated, and should be treated as\n     * an immutable borrow. If you want to take ownership, you must make your own\n     * copy.\n     */\n    MappingList.prototype.toArray = function MappingList_toArray() {\n      if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositionsInflated);\n        this._sorted = true;\n      }\n      return this._array;\n    };\n\n    var MappingList_1 = MappingList;\n\n    var mappingList = {\n    \tMappingList: MappingList_1\n    };\n\n    /* -*- Mode: js; js-indent-level: 2; -*- */\n    /*\n     * Copyright 2011 Mozilla Foundation and contributors\n     * Licensed under the New BSD license. See LICENSE or:\n     * http://opensource.org/licenses/BSD-3-Clause\n     */\n\n\n\n    var ArraySet$1 = arraySet.ArraySet;\n    var MappingList$1 = mappingList.MappingList;\n\n    /**\n     * An instance of the SourceMapGenerator represents a source map which is\n     * being built incrementally. You may pass an object with the following\n     * properties:\n     *\n     *   - file: The filename of the generated source.\n     *   - sourceRoot: A root for all relative URLs in this source map.\n     */\n    function SourceMapGenerator(aArgs) {\n      if (!aArgs) {\n        aArgs = {};\n      }\n      this._file = util.getArg(aArgs, 'file', null);\n      this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n      this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n      this._sources = new ArraySet$1();\n      this._names = new ArraySet$1();\n      this._mappings = new MappingList$1();\n      this._sourcesContents = null;\n    }\n\n    SourceMapGenerator.prototype._version = 3;\n\n    /**\n     * Creates a new SourceMapGenerator based on a SourceMapConsumer\n     *\n     * @param aSourceMapConsumer The SourceMap.\n     */\n    SourceMapGenerator.fromSourceMap =\n      function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n          file: aSourceMapConsumer.file,\n          sourceRoot: sourceRoot\n        });\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          var newMapping = {\n            generated: {\n              line: mapping.generatedLine,\n              column: mapping.generatedColumn\n            }\n          };\n\n          if (mapping.source != null) {\n            newMapping.source = mapping.source;\n            if (sourceRoot != null) {\n              newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n\n            newMapping.original = {\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            };\n\n            if (mapping.name != null) {\n              newMapping.name = mapping.name;\n            }\n          }\n\n          generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var sourceRelative = sourceFile;\n          if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n          }\n\n          if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n          }\n\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n          if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n          }\n        });\n        return generator;\n      };\n\n    /**\n     * Add a single mapping from original source line and column to the generated\n     * source's line and column for this source map being created. The mapping\n     * object should have the following properties:\n     *\n     *   - generated: An object with the generated line and column positions.\n     *   - original: An object with the original line and column positions.\n     *   - source: The original source file (relative to the sourceRoot).\n     *   - name: An optional original token name for this mapping.\n     */\n    SourceMapGenerator.prototype.addMapping =\n      function SourceMapGenerator_addMapping(aArgs) {\n        var generated = util.getArg(aArgs, 'generated');\n        var original = util.getArg(aArgs, 'original', null);\n        var source = util.getArg(aArgs, 'source', null);\n        var name = util.getArg(aArgs, 'name', null);\n\n        if (!this._skipValidation) {\n          this._validateMapping(generated, original, source, name);\n        }\n\n        if (source != null) {\n          source = String(source);\n          if (!this._sources.has(source)) {\n            this._sources.add(source);\n          }\n        }\n\n        if (name != null) {\n          name = String(name);\n          if (!this._names.has(name)) {\n            this._names.add(name);\n          }\n        }\n\n        this._mappings.add({\n          generatedLine: generated.line,\n          generatedColumn: generated.column,\n          originalLine: original != null && original.line,\n          originalColumn: original != null && original.column,\n          source: source,\n          name: name\n        });\n      };\n\n    /**\n     * Set the source content for a source file.\n     */\n    SourceMapGenerator.prototype.setSourceContent =\n      function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n        if (this._sourceRoot != null) {\n          source = util.relative(this._sourceRoot, source);\n        }\n\n        if (aSourceContent != null) {\n          // Add the source content to the _sourcesContents map.\n          // Create a new _sourcesContents map if the property is null.\n          if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n          }\n          this._sourcesContents[util.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n          // Remove the source file from the _sourcesContents map.\n          // If the _sourcesContents map is empty, set the property to null.\n          delete this._sourcesContents[util.toSetString(source)];\n          if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n          }\n        }\n      };\n\n    /**\n     * Applies the mappings of a sub-source-map for a specific source file to the\n     * source map being generated. Each mapping to the supplied source file is\n     * rewritten using the supplied source map. Note: The resolution for the\n     * resulting mappings is the minimium of this map and the supplied map.\n     *\n     * @param aSourceMapConsumer The source map to be applied.\n     * @param aSourceFile Optional. The filename of the source file.\n     *        If omitted, SourceMapConsumer's file property will be used.\n     * @param aSourceMapPath Optional. The dirname of the path to the source map\n     *        to be applied. If relative, it is relative to the SourceMapConsumer.\n     *        This parameter is needed when the two source maps aren't in the same\n     *        directory, and the source map to be applied contains relative source\n     *        paths. If so, those relative source paths need to be rewritten\n     *        relative to the SourceMapGenerator.\n     */\n    SourceMapGenerator.prototype.applySourceMap =\n      function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile;\n        // If aSourceFile is omitted, we will use the file property of the SourceMap\n        if (aSourceFile == null) {\n          if (aSourceMapConsumer.file == null) {\n            throw new Error(\n              'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n              'or the source map\\'s \"file\" property. Both were omitted.'\n            );\n          }\n          sourceFile = aSourceMapConsumer.file;\n        }\n        var sourceRoot = this._sourceRoot;\n        // Make \"sourceFile\" relative if an absolute Url is passed.\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        // Applying the SourceMap can add and remove items from the sources and\n        // the names array.\n        var newSources = new ArraySet$1();\n        var newNames = new ArraySet$1();\n\n        // Find mappings for the \"sourceFile\"\n        this._mappings.unsortedForEach(function (mapping) {\n          if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            });\n            if (original.source != null) {\n              // Copy mapping\n              mapping.source = original.source;\n              if (aSourceMapPath != null) {\n                mapping.source = util.join(aSourceMapPath, mapping.source);\n              }\n              if (sourceRoot != null) {\n                mapping.source = util.relative(sourceRoot, mapping.source);\n              }\n              mapping.originalLine = original.line;\n              mapping.originalColumn = original.column;\n              if (original.name != null) {\n                mapping.name = original.name;\n              }\n            }\n          }\n\n          var source = mapping.source;\n          if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n          }\n\n          var name = mapping.name;\n          if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n          }\n\n        }, this);\n        this._sources = newSources;\n        this._names = newNames;\n\n        // Copy sourcesContents of applied map.\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n          if (content != null) {\n            if (aSourceMapPath != null) {\n              sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n            if (sourceRoot != null) {\n              sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n            this.setSourceContent(sourceFile, content);\n          }\n        }, this);\n      };\n\n    /**\n     * A mapping can have one of the three levels of data:\n     *\n     *   1. Just the generated position.\n     *   2. The Generated position, original position, and original source.\n     *   3. Generated and original position, original source, as well as a name\n     *      token.\n     *\n     * To maintain consistency, we validate that any new mapping being added falls\n     * in to one of these categories.\n     */\n    SourceMapGenerator.prototype._validateMapping =\n      function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                                  aName) {\n        // When aOriginal is truthy but has empty values for .line and .column,\n        // it is most likely a programmer error. In this case we throw a very\n        // specific error message to try to guide them the right way.\n        // For example: https://github.com/Polymer/polymer-bundler/pull/519\n        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n            throw new Error(\n                'original.line and original.column are not numbers -- you probably meant to omit ' +\n                'the original mapping entirely and only map the generated position. If so, pass ' +\n                'null for the original mapping instead of an object with empty or null values.'\n            );\n        }\n\n        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n            && aGenerated.line > 0 && aGenerated.column >= 0\n            && !aOriginal && !aSource && !aName) {\n          // Case 1.\n          return;\n        }\n        else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n                 && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n                 && aGenerated.line > 0 && aGenerated.column >= 0\n                 && aOriginal.line > 0 && aOriginal.column >= 0\n                 && aSource) {\n          // Cases 2 and 3.\n          return;\n        }\n        else {\n          throw new Error('Invalid mapping: ' + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n          }));\n        }\n      };\n\n    /**\n     * Serialize the accumulated mappings in to the stream of base 64 VLQs\n     * specified by the source map format.\n     */\n    SourceMapGenerator.prototype._serializeMappings =\n      function SourceMapGenerator_serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = '';\n        var next;\n        var mapping;\n        var nameIdx;\n        var sourceIdx;\n\n        var mappings = this._mappings.toArray();\n        for (var i = 0, len = mappings.length; i < len; i++) {\n          mapping = mappings[i];\n          next = '';\n\n          if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n            while (mapping.generatedLine !== previousGeneratedLine) {\n              next += ';';\n              previousGeneratedLine++;\n            }\n          }\n          else {\n            if (i > 0) {\n              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                continue;\n              }\n              next += ',';\n            }\n          }\n\n          next += base64Vlq.encode(mapping.generatedColumn\n                                     - previousGeneratedColumn);\n          previousGeneratedColumn = mapping.generatedColumn;\n\n          if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64Vlq.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx;\n\n            // lines are stored 0-based in SourceMap spec version 3\n            next += base64Vlq.encode(mapping.originalLine - 1\n                                       - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n\n            next += base64Vlq.encode(mapping.originalColumn\n                                       - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n\n            if (mapping.name != null) {\n              nameIdx = this._names.indexOf(mapping.name);\n              next += base64Vlq.encode(nameIdx - previousName);\n              previousName = nameIdx;\n            }\n          }\n\n          result += next;\n        }\n\n        return result;\n      };\n\n    SourceMapGenerator.prototype._generateSourcesContent =\n      function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function (source) {\n          if (!this._sourcesContents) {\n            return null;\n          }\n          if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n          }\n          var key = util.toSetString(source);\n          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n            ? this._sourcesContents[key]\n            : null;\n        }, this);\n      };\n\n    /**\n     * Externalize the source map.\n     */\n    SourceMapGenerator.prototype.toJSON =\n      function SourceMapGenerator_toJSON() {\n        var map = {\n          version: this._version,\n          sources: this._sources.toArray(),\n          names: this._names.toArray(),\n          mappings: this._serializeMappings()\n        };\n        if (this._file != null) {\n          map.file = this._file;\n        }\n        if (this._sourceRoot != null) {\n          map.sourceRoot = this._sourceRoot;\n        }\n        if (this._sourcesContents) {\n          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n\n        return map;\n      };\n\n    /**\n     * Render the source map being generated to a string.\n     */\n    SourceMapGenerator.prototype.toString =\n      function SourceMapGenerator_toString() {\n        return JSON.stringify(this.toJSON());\n      };\n\n    var SourceMapGenerator_1 = SourceMapGenerator;\n\n    var sourceMapGenerator = {\n    \tSourceMapGenerator: SourceMapGenerator_1\n    };\n\n    var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;\n    var trackNodes = {\n        Atrule: true,\n        Selector: true,\n        Declaration: true\n    };\n\n    var sourceMap = function generateSourceMap(handlers) {\n        var map = new SourceMapGenerator$1();\n        var line = 1;\n        var column = 0;\n        var generated = {\n            line: 1,\n            column: 0\n        };\n        var original = {\n            line: 0, // should be zero to add first mapping\n            column: 0\n        };\n        var sourceMappingActive = false;\n        var activatedGenerated = {\n            line: 1,\n            column: 0\n        };\n        var activatedMapping = {\n            generated: activatedGenerated\n        };\n\n        var handlersNode = handlers.node;\n        handlers.node = function(node) {\n            if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {\n                var nodeLine = node.loc.start.line;\n                var nodeColumn = node.loc.start.column - 1;\n\n                if (original.line !== nodeLine ||\n                    original.column !== nodeColumn) {\n                    original.line = nodeLine;\n                    original.column = nodeColumn;\n\n                    generated.line = line;\n                    generated.column = column;\n\n                    if (sourceMappingActive) {\n                        sourceMappingActive = false;\n                        if (generated.line !== activatedGenerated.line ||\n                            generated.column !== activatedGenerated.column) {\n                            map.addMapping(activatedMapping);\n                        }\n                    }\n\n                    sourceMappingActive = true;\n                    map.addMapping({\n                        source: node.loc.source,\n                        original: original,\n                        generated: generated\n                    });\n                }\n            }\n\n            handlersNode.call(this, node);\n\n            if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {\n                activatedGenerated.line = line;\n                activatedGenerated.column = column;\n            }\n        };\n\n        var handlersChunk = handlers.chunk;\n        handlers.chunk = function(chunk) {\n            for (var i = 0; i < chunk.length; i++) {\n                if (chunk.charCodeAt(i) === 10) { // \\n\n                    line++;\n                    column = 0;\n                } else {\n                    column++;\n                }\n            }\n\n            handlersChunk(chunk);\n        };\n\n        var handlersResult = handlers.result;\n        handlers.result = function() {\n            if (sourceMappingActive) {\n                map.addMapping(activatedMapping);\n            }\n\n            return {\n                css: handlersResult(),\n                map: map\n            };\n        };\n\n        return handlers;\n    };\n\n    var hasOwnProperty$3 = Object.prototype.hasOwnProperty;\n\n    function processChildren(node, delimeter) {\n        var list = node.children;\n        var prev = null;\n\n        if (typeof delimeter !== 'function') {\n            list.forEach(this.node, this);\n        } else {\n            list.forEach(function(node) {\n                if (prev !== null) {\n                    delimeter.call(this, prev);\n                }\n\n                this.node(node);\n                prev = node;\n            }, this);\n        }\n    }\n\n    var create$1 = function createGenerator(config) {\n        function processNode(node) {\n            if (hasOwnProperty$3.call(types, node.type)) {\n                types[node.type].call(this, node);\n            } else {\n                throw new Error('Unknown node type: ' + node.type);\n            }\n        }\n\n        var types = {};\n\n        if (config.node) {\n            for (var name in config.node) {\n                types[name] = config.node[name].generate;\n            }\n        }\n\n        return function(node, options) {\n            var buffer = '';\n            var handlers = {\n                children: processChildren,\n                node: processNode,\n                chunk: function(chunk) {\n                    buffer += chunk;\n                },\n                result: function() {\n                    return buffer;\n                }\n            };\n\n            if (options) {\n                if (typeof options.decorator === 'function') {\n                    handlers = options.decorator(handlers);\n                }\n\n                if (options.sourceMap) {\n                    handlers = sourceMap(handlers);\n                }\n            }\n\n            handlers.node(node);\n\n            return handlers.result();\n        };\n    };\n\n    var create$2 = function createConvertors(walk) {\n        return {\n            fromPlainObject: function(ast) {\n                walk(ast, {\n                    enter: function(node) {\n                        if (node.children && node.children instanceof List_1 === false) {\n                            node.children = new List_1().fromArray(node.children);\n                        }\n                    }\n                });\n\n                return ast;\n            },\n            toPlainObject: function(ast) {\n                walk(ast, {\n                    leave: function(node) {\n                        if (node.children && node.children instanceof List_1) {\n                            node.children = node.children.toArray();\n                        }\n                    }\n                });\n\n                return ast;\n            }\n        };\n    };\n\n    var hasOwnProperty$4 = Object.prototype.hasOwnProperty;\n    var noop$3 = function() {};\n\n    function ensureFunction$1(value) {\n        return typeof value === 'function' ? value : noop$3;\n    }\n\n    function invokeForType(fn, type) {\n        return function(node, item, list) {\n            if (node.type === type) {\n                fn.call(this, node, item, list);\n            }\n        };\n    }\n\n    function getWalkersFromStructure(name, nodeType) {\n        var structure = nodeType.structure;\n        var walkers = [];\n\n        for (var key in structure) {\n            if (hasOwnProperty$4.call(structure, key) === false) {\n                continue;\n            }\n\n            var fieldTypes = structure[key];\n            var walker = {\n                name: key,\n                type: false,\n                nullable: false\n            };\n\n            if (!Array.isArray(structure[key])) {\n                fieldTypes = [structure[key]];\n            }\n\n            for (var i = 0; i < fieldTypes.length; i++) {\n                var fieldType = fieldTypes[i];\n                if (fieldType === null) {\n                    walker.nullable = true;\n                } else if (typeof fieldType === 'string') {\n                    walker.type = 'node';\n                } else if (Array.isArray(fieldType)) {\n                    walker.type = 'list';\n                }\n            }\n\n            if (walker.type) {\n                walkers.push(walker);\n            }\n        }\n\n        if (walkers.length) {\n            return {\n                context: nodeType.walkContext,\n                fields: walkers\n            };\n        }\n\n        return null;\n    }\n\n    function getTypesFromConfig(config) {\n        var types = {};\n\n        for (var name in config.node) {\n            if (hasOwnProperty$4.call(config.node, name)) {\n                var nodeType = config.node[name];\n\n                if (!nodeType.structure) {\n                    throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                }\n\n                types[name] = getWalkersFromStructure(name, nodeType);\n            }\n        }\n\n        return types;\n    }\n\n    function createTypeIterator(config, reverse) {\n        var fields = config.fields.slice();\n        var contextName = config.context;\n        var useContext = typeof contextName === 'string';\n\n        if (reverse) {\n            fields.reverse();\n        }\n\n        return function(node, context, walk) {\n            var prevContextValue;\n\n            if (useContext) {\n                prevContextValue = context[contextName];\n                context[contextName] = node;\n            }\n\n            for (var i = 0; i < fields.length; i++) {\n                var field = fields[i];\n                var ref = node[field.name];\n\n                if (!field.nullable || ref) {\n                    if (field.type === 'list') {\n                        if (reverse) {\n                            ref.forEachRight(walk);\n                        } else {\n                            ref.forEach(walk);\n                        }\n                    } else {\n                        walk(ref);\n                    }\n                }\n            }\n\n            if (useContext) {\n                context[contextName] = prevContextValue;\n            }\n        };\n    }\n\n    function createFastTraveralMap(iterators) {\n        return {\n            Atrule: {\n                StyleSheet: iterators.StyleSheet,\n                Atrule: iterators.Atrule,\n                Rule: iterators.Rule,\n                Block: iterators.Block\n            },\n            Rule: {\n                StyleSheet: iterators.StyleSheet,\n                Atrule: iterators.Atrule,\n                Rule: iterators.Rule,\n                Block: iterators.Block\n            },\n            Declaration: {\n                StyleSheet: iterators.StyleSheet,\n                Atrule: iterators.Atrule,\n                Rule: iterators.Rule,\n                Block: iterators.Block,\n                DeclarationList: iterators.DeclarationList\n            }\n        };\n    }\n\n    var create$3 = function createWalker(config) {\n        var types = getTypesFromConfig(config);\n        var iteratorsNatural = {};\n        var iteratorsReverse = {};\n\n        for (var name in types) {\n            if (hasOwnProperty$4.call(types, name) && types[name] !== null) {\n                iteratorsNatural[name] = createTypeIterator(types[name], false);\n                iteratorsReverse[name] = createTypeIterator(types[name], true);\n            }\n        }\n\n        var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n        var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n\n        var walk = function(root, options) {\n            function walkNode(node, item, list) {\n                enter.call(context, node, item, list);\n\n                if (iterators.hasOwnProperty(node.type)) {\n                    iterators[node.type](node, context, walkNode);\n                }\n\n                leave.call(context, node, item, list);\n            }\n\n            var enter = noop$3;\n            var leave = noop$3;\n            var iterators = iteratorsNatural;\n            var context = {\n                root: root,\n                stylesheet: null,\n                atrule: null,\n                atrulePrelude: null,\n                rule: null,\n                selector: null,\n                block: null,\n                declaration: null,\n                function: null\n            };\n\n            if (typeof options === 'function') {\n                enter = options;\n            } else if (options) {\n                enter = ensureFunction$1(options.enter);\n                leave = ensureFunction$1(options.leave);\n\n                if (options.reverse) {\n                    iterators = iteratorsReverse;\n                }\n\n                if (options.visit) {\n                    if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n                        iterators = options.reverse\n                            ? fastTraversalIteratorsReverse[options.visit]\n                            : fastTraversalIteratorsNatural[options.visit];\n                    } else if (!types.hasOwnProperty(options.visit)) {\n                        throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');\n                    }\n\n                    enter = invokeForType(enter, options.visit);\n                    leave = invokeForType(leave, options.visit);\n                }\n            }\n\n            if (enter === noop$3 && leave === noop$3) {\n                throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n            }\n\n            // swap handlers in reverse mode to invert visit order\n            if (options.reverse) {\n                var tmp = enter;\n                enter = leave;\n                leave = tmp;\n            }\n\n            walkNode(root);\n        };\n\n        walk.find = function(ast, fn) {\n            var found = null;\n\n            walk(ast, function(node, item, list) {\n                if (found === null && fn.call(this, node, item, list)) {\n                    found = node;\n                }\n            });\n\n            return found;\n        };\n\n        walk.findLast = function(ast, fn) {\n            var found = null;\n\n            walk(ast, {\n                reverse: true,\n                enter: function(node, item, list) {\n                    if (found === null && fn.call(this, node, item, list)) {\n                        found = node;\n                    }\n                }\n            });\n\n            return found;\n        };\n\n        walk.findAll = function(ast, fn) {\n            var found = [];\n\n            walk(ast, function(node, item, list) {\n                if (fn.call(this, node, item, list)) {\n                    found.push(node);\n                }\n            });\n\n            return found;\n        };\n\n        return walk;\n    };\n\n    var clone = function clone(node) {\n        var result = {};\n\n        for (var key in node) {\n            var value = node[key];\n\n            if (value) {\n                if (Array.isArray(value) || value instanceof List_1) {\n                    value = value.map(clone);\n                } else if (value.constructor === Object) {\n                    value = clone(value);\n                }\n            }\n\n            result[key] = value;\n        }\n\n        return result;\n    };\n\n    var hasOwnProperty$5 = Object.prototype.hasOwnProperty;\n    var shape = {\n        generic: true,\n        types: {},\n        atrules: {},\n        properties: {},\n        parseContext: {},\n        scope: {},\n        atrule: ['parse'],\n        pseudo: ['parse'],\n        node: ['name', 'structure', 'parse', 'generate', 'walkContext']\n    };\n\n    function isObject(value) {\n        return value && value.constructor === Object;\n    }\n\n    function copy(value) {\n        if (isObject(value)) {\n            return Object.assign({}, value);\n        } else {\n            return value;\n        }\n    }\n    function extend(dest, src) {\n        for (var key in src) {\n            if (hasOwnProperty$5.call(src, key)) {\n                if (isObject(dest[key])) {\n                    extend(dest[key], copy(src[key]));\n                } else {\n                    dest[key] = copy(src[key]);\n                }\n            }\n        }\n    }\n\n    function mix(dest, src, shape) {\n        for (var key in shape) {\n            if (hasOwnProperty$5.call(shape, key) === false) {\n                continue;\n            }\n\n            if (shape[key] === true) {\n                if (key in src) {\n                    if (hasOwnProperty$5.call(src, key)) {\n                        dest[key] = copy(src[key]);\n                    }\n                }\n            } else if (shape[key]) {\n                if (isObject(shape[key])) {\n                    var res = {};\n                    extend(res, dest[key]);\n                    extend(res, src[key]);\n                    dest[key] = res;\n                } else if (Array.isArray(shape[key])) {\n                    var res = {};\n                    var innerShape = shape[key].reduce(function(s, k) {\n                        s[k] = true;\n                        return s;\n                    }, {});\n                    for (var name in dest[key]) {\n                        if (hasOwnProperty$5.call(dest[key], name)) {\n                            res[name] = {};\n                            if (dest[key] && dest[key][name]) {\n                                mix(res[name], dest[key][name], innerShape);\n                            }\n                        }\n                    }\n                    for (var name in src[key]) {\n                        if (hasOwnProperty$5.call(src[key], name)) {\n                            if (!res[name]) {\n                                res[name] = {};\n                            }\n                            if (src[key] && src[key][name]) {\n                                mix(res[name], src[key][name], innerShape);\n                            }\n                        }\n                    }\n                    dest[key] = res;\n                }\n            }\n        }\n        return dest;\n    }\n\n    var mix_1 = function(dest, src) {\n        return mix(dest, src, shape);\n    };\n\n    function createSyntax(config) {\n        var parse = create(config);\n        var walk = create$3(config);\n        var generate = create$1(config);\n        var convert = create$2(walk);\n\n        var syntax = {\n            List: List_1,\n            SyntaxError: _SyntaxError,\n            TokenStream: TokenStream_1,\n            Lexer: Lexer_1,\n\n            vendorPrefix: names.vendorPrefix,\n            keyword: names.keyword,\n            property: names.property,\n            isCustomProperty: names.isCustomProperty,\n\n            definitionSyntax: definitionSyntax,\n            lexer: null,\n            createLexer: function(config) {\n                return new Lexer_1(config, syntax, syntax.lexer.structure);\n            },\n\n            tokenize: tokenizer,\n            parse: parse,\n            walk: walk,\n            generate: generate,\n\n            find: walk.find,\n            findLast: walk.findLast,\n            findAll: walk.findAll,\n\n            clone: clone,\n            fromPlainObject: convert.fromPlainObject,\n            toPlainObject: convert.toPlainObject,\n\n            createSyntax: function(config) {\n                return createSyntax(mix_1({}, config));\n            },\n            fork: function(extension) {\n                var base = mix_1({}, config); // copy of config\n                return createSyntax(\n                    typeof extension === 'function'\n                        ? extension(base, Object.assign)\n                        : mix_1(base, extension)\n                );\n            }\n        };\n\n        syntax.lexer = new Lexer_1({\n            generic: true,\n            types: config.types,\n            atrules: config.atrules,\n            properties: config.properties,\n            node: config.node\n        }, syntax);\n\n        return syntax;\n    }\n    var create_1 = function(config) {\n        return createSyntax(mix_1({}, config));\n    };\n\n    var create$4 = {\n    \tcreate: create_1\n    };\n\n    var generic$1 = true;\n    var types = {\n    \t\"absolute-size\": \"xx-small|x-small|small|medium|large|x-large|xx-large\",\n    \t\"alpha-value\": \"<number>|<percentage>\",\n    \t\"angle-percentage\": \"<angle>|<percentage>\",\n    \t\"angular-color-hint\": \"<angle-percentage>\",\n    \t\"angular-color-stop\": \"<color>&&<color-stop-angle>?\",\n    \t\"angular-color-stop-list\": \"[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>\",\n    \t\"animateable-feature\": \"scroll-position|contents|<custom-ident>\",\n    \tattachment: \"scroll|fixed|local\",\n    \t\"attr()\": \"attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )\",\n    \t\"attr-matcher\": \"['~'|'|'|'^'|'$'|'*']? '='\",\n    \t\"attr-modifier\": \"i|s\",\n    \t\"attribute-selector\": \"'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'\",\n    \t\"auto-repeat\": \"repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )\",\n    \t\"auto-track-list\": \"[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?\",\n    \t\"baseline-position\": \"[first|last]? baseline\",\n    \t\"basic-shape\": \"<inset()>|<circle()>|<ellipse()>|<polygon()>\",\n    \t\"bg-image\": \"none|<image>\",\n    \t\"bg-layer\": \"<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>\",\n    \t\"bg-position\": \"[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]\",\n    \t\"bg-size\": \"[<length-percentage>|auto]{1,2}|cover|contain\",\n    \t\"blur()\": \"blur( <length> )\",\n    \t\"blend-mode\": \"normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity\",\n    \tbox: \"border-box|padding-box|content-box\",\n    \t\"brightness()\": \"brightness( <number-percentage> )\",\n    \t\"calc()\": \"calc( <calc-sum> )\",\n    \t\"calc-sum\": \"<calc-product> [['+'|'-'] <calc-product>]*\",\n    \t\"calc-product\": \"<calc-value> ['*' <calc-value>|'/' <number>]*\",\n    \t\"calc-value\": \"<number>|<dimension>|<percentage>|( <calc-sum> )\",\n    \t\"cf-final-image\": \"<image>|<color>\",\n    \t\"cf-mixing-image\": \"<percentage>?&&<image>\",\n    \t\"circle()\": \"circle( [<shape-radius>]? [at <position>]? )\",\n    \t\"clamp()\": \"clamp( <calc-sum>#{3} )\",\n    \t\"class-selector\": \"'.' <ident-token>\",\n    \t\"clip-source\": \"<url>\",\n    \tcolor: \"<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>\",\n    \t\"color-stop\": \"<color-stop-length>|<color-stop-angle>\",\n    \t\"color-stop-angle\": \"<angle-percentage>{1,2}\",\n    \t\"color-stop-length\": \"<length-percentage>{1,2}\",\n    \t\"color-stop-list\": \"[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>\",\n    \tcombinator: \"'>'|'+'|'~'|['||']\",\n    \t\"common-lig-values\": \"[common-ligatures|no-common-ligatures]\",\n    \tcompat: \"searchfield|textarea|push-button|button-bevel|slider-horizontal|checkbox|radio|square-button|menulist|menulist-button|listbox|meter|progress-bar\",\n    \t\"composite-style\": \"clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor\",\n    \t\"compositing-operator\": \"add|subtract|intersect|exclude\",\n    \t\"compound-selector\": \"[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!\",\n    \t\"compound-selector-list\": \"<compound-selector>#\",\n    \t\"complex-selector\": \"<compound-selector> [<combinator>? <compound-selector>]*\",\n    \t\"complex-selector-list\": \"<complex-selector>#\",\n    \t\"conic-gradient()\": \"conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )\",\n    \t\"contextual-alt-values\": \"[contextual|no-contextual]\",\n    \t\"content-distribution\": \"space-between|space-around|space-evenly|stretch\",\n    \t\"content-list\": \"[<string>|contents|<url>|<quote>|<attr()>|counter( <ident> , <'list-style-type'>? )]+\",\n    \t\"content-position\": \"center|start|end|flex-start|flex-end\",\n    \t\"content-replacement\": \"<image>\",\n    \t\"contrast()\": \"contrast( [<number-percentage>] )\",\n    \t\"counter()\": \"counter( <custom-ident> , [<counter-style>|none]? )\",\n    \t\"counter-style\": \"<counter-style-name>|symbols( )\",\n    \t\"counter-style-name\": \"<custom-ident>\",\n    \t\"counters()\": \"counters( <custom-ident> , <string> , [<counter-style>|none]? )\",\n    \t\"cross-fade()\": \"cross-fade( <cf-mixing-image> , <cf-final-image>? )\",\n    \t\"cubic-bezier-timing-function\": \"ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number> , <number> , <number> , <number> )\",\n    \t\"deprecated-system-color\": \"ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText\",\n    \t\"discretionary-lig-values\": \"[discretionary-ligatures|no-discretionary-ligatures]\",\n    \t\"display-box\": \"contents|none\",\n    \t\"display-inside\": \"flow|flow-root|table|flex|grid|ruby\",\n    \t\"display-internal\": \"table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container\",\n    \t\"display-legacy\": \"inline-block|inline-list-item|inline-table|inline-flex|inline-grid\",\n    \t\"display-listitem\": \"<display-outside>?&&[flow|flow-root]?&&list-item\",\n    \t\"display-outside\": \"block|inline|run-in\",\n    \t\"drop-shadow()\": \"drop-shadow( <length>{2,3} <color>? )\",\n    \t\"east-asian-variant-values\": \"[jis78|jis83|jis90|jis04|simplified|traditional]\",\n    \t\"east-asian-width-values\": \"[full-width|proportional-width]\",\n    \t\"element()\": \"element( <id-selector> )\",\n    \t\"ellipse()\": \"ellipse( [<shape-radius>{2}]? [at <position>]? )\",\n    \t\"ending-shape\": \"circle|ellipse\",\n    \t\"env()\": \"env( <custom-ident> , <declaration-value>? )\",\n    \t\"explicit-track-list\": \"[<line-names>? <track-size>]+ <line-names>?\",\n    \t\"family-name\": \"<string>|<custom-ident>+\",\n    \t\"feature-tag-value\": \"<string> [<integer>|on|off]?\",\n    \t\"feature-type\": \"@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation\",\n    \t\"feature-value-block\": \"<feature-type> '{' <feature-value-declaration-list> '}'\",\n    \t\"feature-value-block-list\": \"<feature-value-block>+\",\n    \t\"feature-value-declaration\": \"<custom-ident> : <integer>+ ;\",\n    \t\"feature-value-declaration-list\": \"<feature-value-declaration>\",\n    \t\"feature-value-name\": \"<custom-ident>\",\n    \t\"fill-rule\": \"nonzero|evenodd\",\n    \t\"filter-function\": \"<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>\",\n    \t\"filter-function-list\": \"[<filter-function>|<url>]+\",\n    \t\"final-bg-layer\": \"<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>\",\n    \t\"fit-content()\": \"fit-content( [<length>|<percentage>] )\",\n    \t\"fixed-breadth\": \"<length-percentage>\",\n    \t\"fixed-repeat\": \"repeat( [<positive-integer>] , [<line-names>? <fixed-size>]+ <line-names>? )\",\n    \t\"fixed-size\": \"<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )\",\n    \t\"font-stretch-absolute\": \"normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>\",\n    \t\"font-variant-css21\": \"[normal|small-caps]\",\n    \t\"font-weight-absolute\": \"normal|bold|<number>\",\n    \t\"frequency-percentage\": \"<frequency>|<percentage>\",\n    \t\"general-enclosed\": \"[<function-token> <any-value> )]|( <ident> <any-value> )\",\n    \t\"generic-family\": \"serif|sans-serif|cursive|fantasy|monospace|-apple-system\",\n    \t\"generic-name\": \"serif|sans-serif|cursive|fantasy|monospace\",\n    \t\"geometry-box\": \"<shape-box>|fill-box|stroke-box|view-box\",\n    \tgradient: \"<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<-legacy-gradient>\",\n    \t\"grayscale()\": \"grayscale( <number-percentage> )\",\n    \t\"grid-line\": \"auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]\",\n    \t\"historical-lig-values\": \"[historical-ligatures|no-historical-ligatures]\",\n    \t\"hsl()\": \"hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )\",\n    \t\"hsla()\": \"hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )\",\n    \thue: \"<number>|<angle>\",\n    \t\"hue-rotate()\": \"hue-rotate( <angle> )\",\n    \timage: \"<url>|<image()>|<image-set()>|<element()>|<cross-fade()>|<gradient>\",\n    \t\"image()\": \"image( <image-tags>? [<image-src>? , <color>?]! )\",\n    \t\"image-set()\": \"image-set( <image-set-option># )\",\n    \t\"image-set-option\": \"[<image>|<string>] <resolution>\",\n    \t\"image-src\": \"<url>|<string>\",\n    \t\"image-tags\": \"ltr|rtl\",\n    \t\"inflexible-breadth\": \"<length>|<percentage>|min-content|max-content|auto\",\n    \t\"inset()\": \"inset( <length-percentage>{1,4} [round <'border-radius'>]? )\",\n    \t\"invert()\": \"invert( <number-percentage> )\",\n    \t\"keyframes-name\": \"<custom-ident>|<string>\",\n    \t\"keyframe-block\": \"<keyframe-selector># { <declaration-list> }\",\n    \t\"keyframe-block-list\": \"<keyframe-block>+\",\n    \t\"keyframe-selector\": \"from|to|<percentage>\",\n    \t\"leader()\": \"leader( <leader-type> )\",\n    \t\"leader-type\": \"dotted|solid|space|<string>\",\n    \t\"length-percentage\": \"<length>|<percentage>\",\n    \t\"line-names\": \"'[' <custom-ident>* ']'\",\n    \t\"line-name-list\": \"[<line-names>|<name-repeat>]+\",\n    \t\"line-style\": \"none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n    \t\"line-width\": \"<length>|thin|medium|thick\",\n    \t\"linear-color-hint\": \"<length-percentage>\",\n    \t\"linear-color-stop\": \"<color> <color-stop-length>?\",\n    \t\"linear-gradient()\": \"linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )\",\n    \t\"mask-layer\": \"<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>\",\n    \t\"mask-position\": \"[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?\",\n    \t\"mask-reference\": \"none|<image>|<mask-source>\",\n    \t\"mask-source\": \"<url>\",\n    \t\"masking-mode\": \"alpha|luminance|match-source\",\n    \t\"matrix()\": \"matrix( <number>#{6} )\",\n    \t\"matrix3d()\": \"matrix3d( <number>#{16} )\",\n    \t\"max()\": \"max( <calc-sum># )\",\n    \t\"media-and\": \"<media-in-parens> [and <media-in-parens>]+\",\n    \t\"media-condition\": \"<media-not>|<media-and>|<media-or>|<media-in-parens>\",\n    \t\"media-condition-without-or\": \"<media-not>|<media-and>|<media-in-parens>\",\n    \t\"media-feature\": \"( [<mf-plain>|<mf-boolean>|<mf-range>] )\",\n    \t\"media-in-parens\": \"( <media-condition> )|<media-feature>|<general-enclosed>\",\n    \t\"media-not\": \"not <media-in-parens>\",\n    \t\"media-or\": \"<media-in-parens> [or <media-in-parens>]+\",\n    \t\"media-query\": \"<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?\",\n    \t\"media-query-list\": \"<media-query>#\",\n    \t\"media-type\": \"<ident>\",\n    \t\"mf-boolean\": \"<mf-name>\",\n    \t\"mf-name\": \"<ident>\",\n    \t\"mf-plain\": \"<mf-name> : <mf-value>\",\n    \t\"mf-range\": \"<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>\",\n    \t\"mf-value\": \"<number>|<dimension>|<ident>|<ratio>\",\n    \t\"min()\": \"min( <calc-sum># )\",\n    \t\"minmax()\": \"minmax( [<length>|<percentage>|<flex>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )\",\n    \t\"named-color\": \"transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>\",\n    \t\"namespace-prefix\": \"<ident>\",\n    \t\"ns-prefix\": \"[<ident-token>|'*']? '|'\",\n    \t\"number-percentage\": \"<number>|<percentage>\",\n    \t\"numeric-figure-values\": \"[lining-nums|oldstyle-nums]\",\n    \t\"numeric-fraction-values\": \"[diagonal-fractions|stacked-fractions]\",\n    \t\"numeric-spacing-values\": \"[proportional-nums|tabular-nums]\",\n    \tnth: \"<an-plus-b>|even|odd\",\n    \t\"opacity()\": \"opacity( [<number-percentage>] )\",\n    \t\"overflow-position\": \"unsafe|safe\",\n    \t\"outline-radius\": \"<length>|<percentage>\",\n    \t\"page-body\": \"<declaration>? [; <page-body>]?|<page-margin-box> <page-body>\",\n    \t\"page-margin-box\": \"<page-margin-box-type> '{' <declaration-list> '}'\",\n    \t\"page-margin-box-type\": \"@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom\",\n    \t\"page-selector-list\": \"[<page-selector>#]?\",\n    \t\"page-selector\": \"<pseudo-page>+|<ident> <pseudo-page>*\",\n    \t\"perspective()\": \"perspective( <length> )\",\n    \t\"polygon()\": \"polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )\",\n    \tposition: \"[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]\",\n    \t\"pseudo-class-selector\": \"':' <ident-token>|':' <function-token> <any-value> ')'\",\n    \t\"pseudo-element-selector\": \"':' <pseudo-class-selector>\",\n    \t\"pseudo-page\": \": [left|right|first|blank]\",\n    \tquote: \"open-quote|close-quote|no-open-quote|no-close-quote\",\n    \t\"radial-gradient()\": \"radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )\",\n    \t\"relative-selector\": \"<combinator>? <complex-selector>\",\n    \t\"relative-selector-list\": \"<relative-selector>#\",\n    \t\"relative-size\": \"larger|smaller\",\n    \t\"repeat-style\": \"repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}\",\n    \t\"repeating-linear-gradient()\": \"repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )\",\n    \t\"repeating-radial-gradient()\": \"repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )\",\n    \t\"rgb()\": \"rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )\",\n    \t\"rgba()\": \"rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )\",\n    \t\"rotate()\": \"rotate( [<angle>|<zero>] )\",\n    \t\"rotate3d()\": \"rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )\",\n    \t\"rotateX()\": \"rotateX( [<angle>|<zero>] )\",\n    \t\"rotateY()\": \"rotateY( [<angle>|<zero>] )\",\n    \t\"rotateZ()\": \"rotateZ( [<angle>|<zero>] )\",\n    \t\"saturate()\": \"saturate( <number-percentage> )\",\n    \t\"scale()\": \"scale( <number> , <number>? )\",\n    \t\"scale3d()\": \"scale3d( <number> , <number> , <number> )\",\n    \t\"scaleX()\": \"scaleX( <number> )\",\n    \t\"scaleY()\": \"scaleY( <number> )\",\n    \t\"scaleZ()\": \"scaleZ( <number> )\",\n    \t\"self-position\": \"center|start|end|self-start|self-end|flex-start|flex-end\",\n    \t\"shape-radius\": \"<length-percentage>|closest-side|farthest-side\",\n    \t\"skew()\": \"skew( [<angle>|<zero>] , [<angle>|<zero>]? )\",\n    \t\"skewX()\": \"skewX( [<angle>|<zero>] )\",\n    \t\"skewY()\": \"skewY( [<angle>|<zero>] )\",\n    \t\"sepia()\": \"sepia( <number-percentage> )\",\n    \tshadow: \"inset?&&<length>{2,4}&&<color>?\",\n    \t\"shadow-t\": \"[<length>{2,3}&&<color>?]\",\n    \tshape: \"rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )\",\n    \t\"shape-box\": \"<box>|margin-box\",\n    \t\"side-or-corner\": \"[left|right]||[top|bottom]\",\n    \t\"single-animation\": \"<time>||<timing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]\",\n    \t\"single-animation-direction\": \"normal|reverse|alternate|alternate-reverse\",\n    \t\"single-animation-fill-mode\": \"none|forwards|backwards|both\",\n    \t\"single-animation-iteration-count\": \"infinite|<number>\",\n    \t\"single-animation-play-state\": \"running|paused\",\n    \t\"single-transition\": \"[none|<single-transition-property>]||<time>||<timing-function>||<time>\",\n    \t\"single-transition-property\": \"all|<custom-ident>\",\n    \tsize: \"closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}\",\n    \t\"step-position\": \"jump-start|jump-end|jump-none|jump-both|start|end\",\n    \t\"step-timing-function\": \"step-start|step-end|steps( <integer> [, <step-position>]? )\",\n    \t\"subclass-selector\": \"<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>\",\n    \t\"supports-condition\": \"not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*\",\n    \t\"supports-in-parens\": \"( <supports-condition> )|<supports-feature>|<general-enclosed>\",\n    \t\"supports-feature\": \"<supports-decl>|<supports-selector-fn>\",\n    \t\"supports-decl\": \"( <declaration> )\",\n    \t\"supports-selector-fn\": \"selector( <complex-selector> )\",\n    \tsymbol: \"<string>|<image>|<custom-ident>\",\n    \ttarget: \"<target-counter()>|<target-counters()>|<target-text()>\",\n    \t\"target-counter()\": \"target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )\",\n    \t\"target-counters()\": \"target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )\",\n    \t\"target-text()\": \"target-text( [<string>|<url>] , [content|before|after|first-letter]? )\",\n    \t\"time-percentage\": \"<time>|<percentage>\",\n    \t\"timing-function\": \"linear|<cubic-bezier-timing-function>|<step-timing-function>\",\n    \t\"track-breadth\": \"<length-percentage>|<flex>|min-content|max-content|auto\",\n    \t\"track-list\": \"[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?\",\n    \t\"track-repeat\": \"repeat( [<positive-integer>] , [<line-names>? <track-size>]+ <line-names>? )\",\n    \t\"track-size\": \"<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )\",\n    \t\"transform-function\": \"<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>\",\n    \t\"transform-list\": \"<transform-function>+\",\n    \t\"translate()\": \"translate( <length-percentage> , <length-percentage>? )\",\n    \t\"translate3d()\": \"translate3d( <length-percentage> , <length-percentage> , <length> )\",\n    \t\"translateX()\": \"translateX( <length-percentage> )\",\n    \t\"translateY()\": \"translateY( <length-percentage> )\",\n    \t\"translateZ()\": \"translateZ( <length> )\",\n    \t\"type-or-unit\": \"string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%\",\n    \t\"type-selector\": \"<wq-name>|<ns-prefix>? '*'\",\n    \t\"var()\": \"var( <custom-property-name> , <declaration-value>? )\",\n    \t\"viewport-length\": \"auto|<length-percentage>\",\n    \t\"wq-name\": \"<ns-prefix>? <ident-token>\",\n    \t\"-legacy-gradient\": \"<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>\",\n    \t\"-legacy-linear-gradient\": \"-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )\",\n    \t\"-legacy-repeating-linear-gradient\": \"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )\",\n    \t\"-legacy-linear-gradient-arguments\": \"[<angle>|<side-or-corner>]? , <color-stop-list>\",\n    \t\"-legacy-radial-gradient\": \"-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )\",\n    \t\"-legacy-repeating-radial-gradient\": \"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )\",\n    \t\"-legacy-radial-gradient-arguments\": \"[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>\",\n    \t\"-legacy-radial-gradient-size\": \"closest-side|closest-corner|farthest-side|farthest-corner|contain|cover\",\n    \t\"-legacy-radial-gradient-shape\": \"circle|ellipse\",\n    \t\"-non-standard-font\": \"-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body\",\n    \t\"-non-standard-color\": \"-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text\",\n    \t\"-non-standard-image-rendering\": \"optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast\",\n    \t\"-non-standard-overflow\": \"-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable\",\n    \t\"-non-standard-width\": \"min-intrinsic|intrinsic|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content\",\n    \t\"-webkit-gradient()\": \"-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )\",\n    \t\"-webkit-gradient-color-stop\": \"from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )\",\n    \t\"-webkit-gradient-point\": \"[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]\",\n    \t\"-webkit-gradient-radius\": \"<length>|<percentage>\",\n    \t\"-webkit-gradient-type\": \"linear|radial\",\n    \t\"-webkit-mask-box-repeat\": \"repeat|stretch|round\",\n    \t\"-webkit-mask-clip-style\": \"border|border-box|padding|padding-box|content|content-box|text\",\n    \t\"-ms-filter-function-list\": \"<-ms-filter-function>+\",\n    \t\"-ms-filter-function\": \"<-ms-filter-function-progid>|<-ms-filter-function-legacy>\",\n    \t\"-ms-filter-function-progid\": \"'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]\",\n    \t\"-ms-filter-function-legacy\": \"<ident-token>|<function-token> <any-value>? )\",\n    \t\"-ms-filter\": \"<string>\",\n    \tage: \"child|young|old\",\n    \t\"attr-name\": \"<wq-name>\",\n    \t\"attr-fallback\": \"<any-value>\",\n    \t\"border-radius\": \"<length-percentage>{1,2}\",\n    \tbottom: \"<length>|auto\",\n    \t\"generic-voice\": \"[<age>? <gender> <integer>?]\",\n    \tgender: \"male|female|neutral\",\n    \tleft: \"<length>|auto\",\n    \t\"mask-image\": \"<mask-reference>#\",\n    \t\"name-repeat\": \"repeat( [<positive-integer>|auto-fill] , <line-names>+ )\",\n    \tpaint: \"none|<color>|<url> [none|<color>]?|context-fill|context-stroke\",\n    \t\"path()\": \"path( <string> )\",\n    \tratio: \"<integer> / <integer>\",\n    \tright: \"<length>|auto\",\n    \t\"svg-length\": \"<percentage>|<length>|<number>\",\n    \t\"svg-writing-mode\": \"lr-tb|rl-tb|tb-rl|lr|rl|tb\",\n    \ttop: \"<length>|auto\",\n    \t\"track-group\": \"'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>\",\n    \t\"track-list-v0\": \"[<string>* <track-group> <string>*]+|none\",\n    \t\"track-minmax\": \"minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content\",\n    \tx: \"<number>\",\n    \ty: \"<number>\",\n    \tdeclaration: \"<ident-token> : <declaration-value>? ['!' important]?\",\n    \t\"declaration-list\": \"[<declaration>? ';']* <declaration>?\",\n    \turl: \"url( <string> <url-modifier>* )|<url-token>\",\n    \t\"url-modifier\": \"<ident>|<function-token> <any-value> )\",\n    \t\"number-zero-one\": \"<number [0,1]>\",\n    \t\"number-one-or-greater\": \"<number [1,∞]>\",\n    \t\"positive-integer\": \"<integer [0,∞]>\"\n    };\n    var properties$1 = {\n    \t\"--*\": \"<declaration-value>\",\n    \t\"-ms-accelerator\": \"false|true\",\n    \t\"-ms-block-progression\": \"tb|rl|bt|lr\",\n    \t\"-ms-content-zoom-chaining\": \"none|chained\",\n    \t\"-ms-content-zooming\": \"none|zoom\",\n    \t\"-ms-content-zoom-limit\": \"<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>\",\n    \t\"-ms-content-zoom-limit-max\": \"<percentage>\",\n    \t\"-ms-content-zoom-limit-min\": \"<percentage>\",\n    \t\"-ms-content-zoom-snap\": \"<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>\",\n    \t\"-ms-content-zoom-snap-points\": \"snapInterval( <percentage> , <percentage> )|snapList( <percentage># )\",\n    \t\"-ms-content-zoom-snap-type\": \"none|proximity|mandatory\",\n    \t\"-ms-filter\": \"<string>\",\n    \t\"-ms-flow-from\": \"[none|<custom-ident>]#\",\n    \t\"-ms-flow-into\": \"[none|<custom-ident>]#\",\n    \t\"-ms-high-contrast-adjust\": \"auto|none\",\n    \t\"-ms-hyphenate-limit-chars\": \"auto|<integer>{1,3}\",\n    \t\"-ms-hyphenate-limit-lines\": \"no-limit|<integer>\",\n    \t\"-ms-hyphenate-limit-zone\": \"<percentage>|<length>\",\n    \t\"-ms-ime-align\": \"auto|after\",\n    \t\"-ms-overflow-style\": \"auto|none|scrollbar|-ms-autohiding-scrollbar\",\n    \t\"-ms-scrollbar-3dlight-color\": \"<color>\",\n    \t\"-ms-scrollbar-arrow-color\": \"<color>\",\n    \t\"-ms-scrollbar-base-color\": \"<color>\",\n    \t\"-ms-scrollbar-darkshadow-color\": \"<color>\",\n    \t\"-ms-scrollbar-face-color\": \"<color>\",\n    \t\"-ms-scrollbar-highlight-color\": \"<color>\",\n    \t\"-ms-scrollbar-shadow-color\": \"<color>\",\n    \t\"-ms-scrollbar-track-color\": \"<color>\",\n    \t\"-ms-scroll-chaining\": \"chained|none\",\n    \t\"-ms-scroll-limit\": \"<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>\",\n    \t\"-ms-scroll-limit-x-max\": \"auto|<length>\",\n    \t\"-ms-scroll-limit-x-min\": \"<length>\",\n    \t\"-ms-scroll-limit-y-max\": \"auto|<length>\",\n    \t\"-ms-scroll-limit-y-min\": \"<length>\",\n    \t\"-ms-scroll-rails\": \"none|railed\",\n    \t\"-ms-scroll-snap-points-x\": \"snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )\",\n    \t\"-ms-scroll-snap-points-y\": \"snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )\",\n    \t\"-ms-scroll-snap-type\": \"none|proximity|mandatory\",\n    \t\"-ms-scroll-snap-x\": \"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>\",\n    \t\"-ms-scroll-snap-y\": \"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>\",\n    \t\"-ms-scroll-translation\": \"none|vertical-to-horizontal\",\n    \t\"-ms-text-autospace\": \"none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space\",\n    \t\"-ms-touch-select\": \"grippers|none\",\n    \t\"-ms-user-select\": \"none|element|text\",\n    \t\"-ms-wrap-flow\": \"auto|both|start|end|maximum|clear\",\n    \t\"-ms-wrap-margin\": \"<length>\",\n    \t\"-ms-wrap-through\": \"wrap|none\",\n    \t\"-moz-appearance\": \"none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized\",\n    \t\"-moz-binding\": \"<url>|none\",\n    \t\"-moz-border-bottom-colors\": \"<color>+|none\",\n    \t\"-moz-border-left-colors\": \"<color>+|none\",\n    \t\"-moz-border-right-colors\": \"<color>+|none\",\n    \t\"-moz-border-top-colors\": \"<color>+|none\",\n    \t\"-moz-context-properties\": \"none|[fill|fill-opacity|stroke|stroke-opacity]#\",\n    \t\"-moz-float-edge\": \"border-box|content-box|margin-box|padding-box\",\n    \t\"-moz-force-broken-image-icon\": \"<integer>\",\n    \t\"-moz-image-region\": \"<shape>|auto\",\n    \t\"-moz-orient\": \"inline|block|horizontal|vertical\",\n    \t\"-moz-outline-radius\": \"<outline-radius>{1,4} [/ <outline-radius>{1,4}]?\",\n    \t\"-moz-outline-radius-bottomleft\": \"<outline-radius>\",\n    \t\"-moz-outline-radius-bottomright\": \"<outline-radius>\",\n    \t\"-moz-outline-radius-topleft\": \"<outline-radius>\",\n    \t\"-moz-outline-radius-topright\": \"<outline-radius>\",\n    \t\"-moz-stack-sizing\": \"ignore|stretch-to-fit\",\n    \t\"-moz-text-blink\": \"none|blink\",\n    \t\"-moz-user-focus\": \"ignore|normal|select-after|select-before|select-menu|select-same|select-all|none\",\n    \t\"-moz-user-input\": \"auto|none|enabled|disabled\",\n    \t\"-moz-user-modify\": \"read-only|read-write|write-only\",\n    \t\"-moz-window-dragging\": \"drag|no-drag\",\n    \t\"-moz-window-shadow\": \"default|menu|tooltip|sheet|none\",\n    \t\"-webkit-appearance\": \"none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|listbox|listitem|media-fullscreen-button|media-mute-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield\",\n    \t\"-webkit-border-before\": \"<'border-width'>||<'border-style'>||<'color'>\",\n    \t\"-webkit-border-before-color\": \"<'color'>\",\n    \t\"-webkit-border-before-style\": \"<'border-style'>\",\n    \t\"-webkit-border-before-width\": \"<'border-width'>\",\n    \t\"-webkit-box-reflect\": \"[above|below|right|left]? <length>? <image>?\",\n    \t\"-webkit-line-clamp\": \"none|<integer>\",\n    \t\"-webkit-mask\": \"[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#\",\n    \t\"-webkit-mask-attachment\": \"<attachment>#\",\n    \t\"-webkit-mask-clip\": \"[<box>|border|padding|content|text]#\",\n    \t\"-webkit-mask-composite\": \"<composite-style>#\",\n    \t\"-webkit-mask-image\": \"<mask-reference>#\",\n    \t\"-webkit-mask-origin\": \"[<box>|border|padding|content]#\",\n    \t\"-webkit-mask-position\": \"<position>#\",\n    \t\"-webkit-mask-position-x\": \"[<length-percentage>|left|center|right]#\",\n    \t\"-webkit-mask-position-y\": \"[<length-percentage>|top|center|bottom]#\",\n    \t\"-webkit-mask-repeat\": \"<repeat-style>#\",\n    \t\"-webkit-mask-repeat-x\": \"repeat|no-repeat|space|round\",\n    \t\"-webkit-mask-repeat-y\": \"repeat|no-repeat|space|round\",\n    \t\"-webkit-mask-size\": \"<bg-size>#\",\n    \t\"-webkit-overflow-scrolling\": \"auto|touch\",\n    \t\"-webkit-tap-highlight-color\": \"<color>\",\n    \t\"-webkit-text-fill-color\": \"<color>\",\n    \t\"-webkit-text-stroke\": \"<length>||<color>\",\n    \t\"-webkit-text-stroke-color\": \"<color>\",\n    \t\"-webkit-text-stroke-width\": \"<length>\",\n    \t\"-webkit-touch-callout\": \"default|none\",\n    \t\"-webkit-user-modify\": \"read-only|read-write|read-write-plaintext-only\",\n    \t\"align-content\": \"normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>\",\n    \t\"align-items\": \"normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]\",\n    \t\"align-self\": \"auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>\",\n    \tall: \"initial|inherit|unset|revert\",\n    \tanimation: \"<single-animation>#\",\n    \t\"animation-delay\": \"<time>#\",\n    \t\"animation-direction\": \"<single-animation-direction>#\",\n    \t\"animation-duration\": \"<time>#\",\n    \t\"animation-fill-mode\": \"<single-animation-fill-mode>#\",\n    \t\"animation-iteration-count\": \"<single-animation-iteration-count>#\",\n    \t\"animation-name\": \"[none|<keyframes-name>]#\",\n    \t\"animation-play-state\": \"<single-animation-play-state>#\",\n    \t\"animation-timing-function\": \"<timing-function>#\",\n    \tappearance: \"none|auto|button|textfield|<compat>\",\n    \tazimuth: \"<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards\",\n    \t\"backdrop-filter\": \"none|<filter-function-list>\",\n    \t\"backface-visibility\": \"visible|hidden\",\n    \tbackground: \"[<bg-layer> ,]* <final-bg-layer>\",\n    \t\"background-attachment\": \"<attachment>#\",\n    \t\"background-blend-mode\": \"<blend-mode>#\",\n    \t\"background-clip\": \"<box>#\",\n    \t\"background-color\": \"<color>\",\n    \t\"background-image\": \"<bg-image>#\",\n    \t\"background-origin\": \"<box>#\",\n    \t\"background-position\": \"<bg-position>#\",\n    \t\"background-position-x\": \"[center|[left|right|x-start|x-end]? <length-percentage>?]#\",\n    \t\"background-position-y\": \"[center|[top|bottom|y-start|y-end]? <length-percentage>?]#\",\n    \t\"background-repeat\": \"<repeat-style>#\",\n    \t\"background-size\": \"<bg-size>#\",\n    \t\"block-overflow\": \"clip|ellipsis|<string>\",\n    \t\"block-size\": \"<'width'>\",\n    \tborder: \"<line-width>||<line-style>||<color>\",\n    \t\"border-block\": \"<'border-top-width'>||<'border-top-style'>||<'color'>\",\n    \t\"border-block-color\": \"<'border-top-color'>{1,2}\",\n    \t\"border-block-style\": \"<'border-top-style'>\",\n    \t\"border-block-width\": \"<'border-top-width'>\",\n    \t\"border-block-end\": \"<'border-top-width'>||<'border-top-style'>||<'color'>\",\n    \t\"border-block-end-color\": \"<'border-top-color'>\",\n    \t\"border-block-end-style\": \"<'border-top-style'>\",\n    \t\"border-block-end-width\": \"<'border-top-width'>\",\n    \t\"border-block-start\": \"<'border-top-width'>||<'border-top-style'>||<'color'>\",\n    \t\"border-block-start-color\": \"<'border-top-color'>\",\n    \t\"border-block-start-style\": \"<'border-top-style'>\",\n    \t\"border-block-start-width\": \"<'border-top-width'>\",\n    \t\"border-bottom\": \"<line-width>||<line-style>||<color>\",\n    \t\"border-bottom-color\": \"<'border-top-color'>\",\n    \t\"border-bottom-left-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-bottom-right-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-bottom-style\": \"<line-style>\",\n    \t\"border-bottom-width\": \"<line-width>\",\n    \t\"border-collapse\": \"collapse|separate\",\n    \t\"border-color\": \"<color>{1,4}\",\n    \t\"border-end-end-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-end-start-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-image\": \"<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>\",\n    \t\"border-image-outset\": \"[<length>|<number>]{1,4}\",\n    \t\"border-image-repeat\": \"[stretch|repeat|round|space]{1,2}\",\n    \t\"border-image-slice\": \"<number-percentage>{1,4}&&fill?\",\n    \t\"border-image-source\": \"none|<image>\",\n    \t\"border-image-width\": \"[<length-percentage>|<number>|auto]{1,4}\",\n    \t\"border-inline\": \"<'border-top-width'>||<'border-top-style'>||<'color'>\",\n    \t\"border-inline-end\": \"<'border-top-width'>||<'border-top-style'>||<'color'>\",\n    \t\"border-inline-color\": \"<'border-top-color'>{1,2}\",\n    \t\"border-inline-style\": \"<'border-top-style'>\",\n    \t\"border-inline-width\": \"<'border-top-width'>\",\n    \t\"border-inline-end-color\": \"<'border-top-color'>\",\n    \t\"border-inline-end-style\": \"<'border-top-style'>\",\n    \t\"border-inline-end-width\": \"<'border-top-width'>\",\n    \t\"border-inline-start\": \"<'border-top-width'>||<'border-top-style'>||<'color'>\",\n    \t\"border-inline-start-color\": \"<'border-top-color'>\",\n    \t\"border-inline-start-style\": \"<'border-top-style'>\",\n    \t\"border-inline-start-width\": \"<'border-top-width'>\",\n    \t\"border-left\": \"<line-width>||<line-style>||<color>\",\n    \t\"border-left-color\": \"<color>\",\n    \t\"border-left-style\": \"<line-style>\",\n    \t\"border-left-width\": \"<line-width>\",\n    \t\"border-radius\": \"<length-percentage>{1,4} [/ <length-percentage>{1,4}]?\",\n    \t\"border-right\": \"<line-width>||<line-style>||<color>\",\n    \t\"border-right-color\": \"<color>\",\n    \t\"border-right-style\": \"<line-style>\",\n    \t\"border-right-width\": \"<line-width>\",\n    \t\"border-spacing\": \"<length> <length>?\",\n    \t\"border-start-end-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-start-start-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-style\": \"<line-style>{1,4}\",\n    \t\"border-top\": \"<line-width>||<line-style>||<color>\",\n    \t\"border-top-color\": \"<color>\",\n    \t\"border-top-left-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-top-right-radius\": \"<length-percentage>{1,2}\",\n    \t\"border-top-style\": \"<line-style>\",\n    \t\"border-top-width\": \"<line-width>\",\n    \t\"border-width\": \"<line-width>{1,4}\",\n    \tbottom: \"<length>|<percentage>|auto\",\n    \t\"box-align\": \"start|center|end|baseline|stretch\",\n    \t\"box-decoration-break\": \"slice|clone\",\n    \t\"box-direction\": \"normal|reverse|inherit\",\n    \t\"box-flex\": \"<number>\",\n    \t\"box-flex-group\": \"<integer>\",\n    \t\"box-lines\": \"single|multiple\",\n    \t\"box-ordinal-group\": \"<integer>\",\n    \t\"box-orient\": \"horizontal|vertical|inline-axis|block-axis|inherit\",\n    \t\"box-pack\": \"start|center|end|justify\",\n    \t\"box-shadow\": \"none|<shadow>#\",\n    \t\"box-sizing\": \"content-box|border-box\",\n    \t\"break-after\": \"auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region\",\n    \t\"break-before\": \"auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region\",\n    \t\"break-inside\": \"auto|avoid|avoid-page|avoid-column|avoid-region\",\n    \t\"caption-side\": \"top|bottom|block-start|block-end|inline-start|inline-end\",\n    \t\"caret-color\": \"auto|<color>\",\n    \tclear: \"none|left|right|both|inline-start|inline-end\",\n    \tclip: \"<shape>|auto\",\n    \t\"clip-path\": \"<clip-source>|[<basic-shape>||<geometry-box>]|none\",\n    \tcolor: \"<color>\",\n    \t\"color-adjust\": \"economy|exact\",\n    \t\"column-count\": \"<integer>|auto\",\n    \t\"column-fill\": \"auto|balance|balance-all\",\n    \t\"column-gap\": \"normal|<length-percentage>\",\n    \t\"column-rule\": \"<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>\",\n    \t\"column-rule-color\": \"<color>\",\n    \t\"column-rule-style\": \"<'border-style'>\",\n    \t\"column-rule-width\": \"<'border-width'>\",\n    \t\"column-span\": \"none|all\",\n    \t\"column-width\": \"<length>|auto\",\n    \tcolumns: \"<'column-width'>||<'column-count'>\",\n    \tcontain: \"none|strict|content|[size||layout||style||paint]\",\n    \tcontent: \"normal|none|[<content-replacement>|<content-list>] [/ <string>]?\",\n    \t\"counter-increment\": \"[<custom-ident> <integer>?]+|none\",\n    \t\"counter-reset\": \"[<custom-ident> <integer>?]+|none\",\n    \t\"counter-set\": \"[<custom-ident> <integer>?]+|none\",\n    \tcursor: \"[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]\",\n    \tdirection: \"ltr|rtl\",\n    \tdisplay: \"block|contents|flex|flow|flow-root|grid|inline|inline-block|inline-flex|inline-grid|inline-list-item|inline-table|list-item|none|ruby|ruby-base|ruby-base-container|ruby-text|ruby-text-container|run-in|table|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|-ms-flexbox|-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box\",\n    \t\"empty-cells\": \"show|hide\",\n    \tfilter: \"none|<filter-function-list>|<-ms-filter-function-list>\",\n    \tflex: \"none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]\",\n    \t\"flex-basis\": \"content|<'width'>\",\n    \t\"flex-direction\": \"row|row-reverse|column|column-reverse\",\n    \t\"flex-flow\": \"<'flex-direction'>||<'flex-wrap'>\",\n    \t\"flex-grow\": \"<number>\",\n    \t\"flex-shrink\": \"<number>\",\n    \t\"flex-wrap\": \"nowrap|wrap|wrap-reverse\",\n    \tfloat: \"left|right|none|inline-start|inline-end\",\n    \tfont: \"[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar\",\n    \t\"font-family\": \"[<family-name>|<generic-family>]#\",\n    \t\"font-feature-settings\": \"normal|<feature-tag-value>#\",\n    \t\"font-kerning\": \"auto|normal|none\",\n    \t\"font-language-override\": \"normal|<string>\",\n    \t\"font-optical-sizing\": \"auto|none\",\n    \t\"font-variation-settings\": \"normal|[<string> <number>]#\",\n    \t\"font-size\": \"<absolute-size>|<relative-size>|<length-percentage>\",\n    \t\"font-size-adjust\": \"none|<number>\",\n    \t\"font-stretch\": \"<font-stretch-absolute>\",\n    \t\"font-style\": \"normal|italic|oblique <angle>?\",\n    \t\"font-synthesis\": \"none|[weight||style]\",\n    \t\"font-variant\": \"normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]\",\n    \t\"font-variant-alternates\": \"normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]\",\n    \t\"font-variant-caps\": \"normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps\",\n    \t\"font-variant-east-asian\": \"normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]\",\n    \t\"font-variant-ligatures\": \"normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]\",\n    \t\"font-variant-numeric\": \"normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]\",\n    \t\"font-variant-position\": \"normal|sub|super\",\n    \t\"font-weight\": \"<font-weight-absolute>|bolder|lighter\",\n    \tgap: \"<'row-gap'> <'column-gap'>?\",\n    \tgrid: \"<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>\",\n    \t\"grid-area\": \"<grid-line> [/ <grid-line>]{0,3}\",\n    \t\"grid-auto-columns\": \"<track-size>+\",\n    \t\"grid-auto-flow\": \"[row|column]||dense\",\n    \t\"grid-auto-rows\": \"<track-size>+\",\n    \t\"grid-column\": \"<grid-line> [/ <grid-line>]?\",\n    \t\"grid-column-end\": \"<grid-line>\",\n    \t\"grid-column-gap\": \"<length-percentage>\",\n    \t\"grid-column-start\": \"<grid-line>\",\n    \t\"grid-gap\": \"<'grid-row-gap'> <'grid-column-gap'>?\",\n    \t\"grid-row\": \"<grid-line> [/ <grid-line>]?\",\n    \t\"grid-row-end\": \"<grid-line>\",\n    \t\"grid-row-gap\": \"<length-percentage>\",\n    \t\"grid-row-start\": \"<grid-line>\",\n    \t\"grid-template\": \"none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?\",\n    \t\"grid-template-areas\": \"none|<string>+\",\n    \t\"grid-template-columns\": \"none|<track-list>|<auto-track-list>\",\n    \t\"grid-template-rows\": \"none|<track-list>|<auto-track-list>\",\n    \t\"hanging-punctuation\": \"none|[first||[force-end|allow-end]||last]\",\n    \theight: \"[<length>|<percentage>]&&[border-box|content-box]?|available|min-content|max-content|fit-content|auto\",\n    \thyphens: \"none|manual|auto\",\n    \t\"image-orientation\": \"from-image|<angle>|[<angle>? flip]\",\n    \t\"image-rendering\": \"auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>\",\n    \t\"image-resolution\": \"[from-image||<resolution>]&&snap?\",\n    \t\"ime-mode\": \"auto|normal|active|inactive|disabled\",\n    \t\"initial-letter\": \"normal|[<number> <integer>?]\",\n    \t\"initial-letter-align\": \"[auto|alphabetic|hanging|ideographic]\",\n    \t\"inline-size\": \"<'width'>\",\n    \tinset: \"<'top'>{1,4}\",\n    \t\"inset-block\": \"<'top'>{1,2}\",\n    \t\"inset-block-end\": \"<'top'>\",\n    \t\"inset-block-start\": \"<'top'>\",\n    \t\"inset-inline\": \"<'top'>{1,2}\",\n    \t\"inset-inline-end\": \"<'top'>\",\n    \t\"inset-inline-start\": \"<'top'>\",\n    \tisolation: \"auto|isolate\",\n    \t\"justify-content\": \"normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]\",\n    \t\"justify-items\": \"normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]\",\n    \t\"justify-self\": \"auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]\",\n    \tleft: \"<length>|<percentage>|auto\",\n    \t\"letter-spacing\": \"normal|<length-percentage>\",\n    \t\"line-break\": \"auto|loose|normal|strict\",\n    \t\"line-clamp\": \"none|<integer>\",\n    \t\"line-height\": \"normal|<number>|<length>|<percentage>\",\n    \t\"line-height-step\": \"<length>\",\n    \t\"list-style\": \"<'list-style-type'>||<'list-style-position'>||<'list-style-image'>\",\n    \t\"list-style-image\": \"<url>|none\",\n    \t\"list-style-position\": \"inside|outside\",\n    \t\"list-style-type\": \"<counter-style>|<string>|none\",\n    \tmargin: \"[<length>|<percentage>|auto]{1,4}\",\n    \t\"margin-block\": \"<'margin-left'>{1,2}\",\n    \t\"margin-block-end\": \"<'margin-left'>\",\n    \t\"margin-block-start\": \"<'margin-left'>\",\n    \t\"margin-bottom\": \"<length>|<percentage>|auto\",\n    \t\"margin-inline\": \"<'margin-left'>{1,2}\",\n    \t\"margin-inline-end\": \"<'margin-left'>\",\n    \t\"margin-inline-start\": \"<'margin-left'>\",\n    \t\"margin-left\": \"<length>|<percentage>|auto\",\n    \t\"margin-right\": \"<length>|<percentage>|auto\",\n    \t\"margin-top\": \"<length>|<percentage>|auto\",\n    \tmask: \"<mask-layer>#\",\n    \t\"mask-border\": \"<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>\",\n    \t\"mask-border-mode\": \"luminance|alpha\",\n    \t\"mask-border-outset\": \"[<length>|<number>]{1,4}\",\n    \t\"mask-border-repeat\": \"[stretch|repeat|round|space]{1,2}\",\n    \t\"mask-border-slice\": \"<number-percentage>{1,4} fill?\",\n    \t\"mask-border-source\": \"none|<image>\",\n    \t\"mask-border-width\": \"[<length-percentage>|<number>|auto]{1,4}\",\n    \t\"mask-clip\": \"[<geometry-box>|no-clip]#\",\n    \t\"mask-composite\": \"<compositing-operator>#\",\n    \t\"mask-image\": \"<mask-reference>#\",\n    \t\"mask-mode\": \"<masking-mode>#\",\n    \t\"mask-origin\": \"<geometry-box>#\",\n    \t\"mask-position\": \"<position>#\",\n    \t\"mask-repeat\": \"<repeat-style>#\",\n    \t\"mask-size\": \"<bg-size>#\",\n    \t\"mask-type\": \"luminance|alpha\",\n    \t\"max-block-size\": \"<'max-width'>\",\n    \t\"max-height\": \"<length>|<percentage>|none|max-content|min-content|fit-content|fill-available\",\n    \t\"max-inline-size\": \"<'max-width'>\",\n    \t\"max-lines\": \"none|<integer>\",\n    \t\"max-width\": \"<length>|<percentage>|none|max-content|min-content|fit-content|fill-available|<-non-standard-width>\",\n    \t\"min-block-size\": \"<'min-width'>\",\n    \t\"min-height\": \"<length>|<percentage>|auto|max-content|min-content|fit-content|fill-available\",\n    \t\"min-inline-size\": \"<'min-width'>\",\n    \t\"min-width\": \"<length>|<percentage>|auto|max-content|min-content|fit-content|fill-available|<-non-standard-width>\",\n    \t\"mix-blend-mode\": \"<blend-mode>\",\n    \t\"object-fit\": \"fill|contain|cover|none|scale-down\",\n    \t\"object-position\": \"<position>\",\n    \toffset: \"[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?\",\n    \t\"offset-anchor\": \"auto|<position>\",\n    \t\"offset-distance\": \"<length-percentage>\",\n    \t\"offset-path\": \"none|ray( [<angle>&&<size>?&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]\",\n    \t\"offset-position\": \"auto|<position>\",\n    \t\"offset-rotate\": \"[auto|reverse]||<angle>\",\n    \topacity: \"<number-zero-one>\",\n    \torder: \"<integer>\",\n    \torphans: \"<integer>\",\n    \toutline: \"[<'outline-color'>||<'outline-style'>||<'outline-width'>]\",\n    \t\"outline-color\": \"<color>|invert\",\n    \t\"outline-offset\": \"<length>\",\n    \t\"outline-style\": \"auto|<'border-style'>\",\n    \t\"outline-width\": \"<line-width>\",\n    \toverflow: \"[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>\",\n    \t\"overflow-anchor\": \"auto|none\",\n    \t\"overflow-block\": \"visible|hidden|clip|scroll|auto\",\n    \t\"overflow-clip-box\": \"padding-box|content-box\",\n    \t\"overflow-inline\": \"visible|hidden|clip|scroll|auto\",\n    \t\"overflow-wrap\": \"normal|break-word|anywhere\",\n    \t\"overflow-x\": \"visible|hidden|clip|scroll|auto\",\n    \t\"overflow-y\": \"visible|hidden|clip|scroll|auto\",\n    \t\"overscroll-behavior\": \"[contain|none|auto]{1,2}\",\n    \t\"overscroll-behavior-x\": \"contain|none|auto\",\n    \t\"overscroll-behavior-y\": \"contain|none|auto\",\n    \tpadding: \"[<length>|<percentage>]{1,4}\",\n    \t\"padding-block\": \"<'padding-left'>{1,2}\",\n    \t\"padding-block-end\": \"<'padding-left'>\",\n    \t\"padding-block-start\": \"<'padding-left'>\",\n    \t\"padding-bottom\": \"<length>|<percentage>\",\n    \t\"padding-inline\": \"<'padding-left'>{1,2}\",\n    \t\"padding-inline-end\": \"<'padding-left'>\",\n    \t\"padding-inline-start\": \"<'padding-left'>\",\n    \t\"padding-left\": \"<length>|<percentage>\",\n    \t\"padding-right\": \"<length>|<percentage>\",\n    \t\"padding-top\": \"<length>|<percentage>\",\n    \t\"page-break-after\": \"auto|always|avoid|left|right|recto|verso\",\n    \t\"page-break-before\": \"auto|always|avoid|left|right|recto|verso\",\n    \t\"page-break-inside\": \"auto|avoid\",\n    \t\"paint-order\": \"normal|[fill||stroke||markers]\",\n    \tperspective: \"none|<length>\",\n    \t\"perspective-origin\": \"<position>\",\n    \t\"place-content\": \"<'align-content'> <'justify-content'>?\",\n    \t\"place-items\": \"<'align-items'> <'justify-items'>?\",\n    \t\"place-self\": \"<'align-self'> <'justify-self'>?\",\n    \t\"pointer-events\": \"auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit\",\n    \tposition: \"static|relative|absolute|sticky|fixed|-webkit-sticky\",\n    \tquotes: \"none|[<string> <string>]+\",\n    \tresize: \"none|both|horizontal|vertical|block|inline\",\n    \tright: \"<length>|<percentage>|auto\",\n    \trotate: \"none|<angle>|[x|y|z|<number>{3}]&&<angle>\",\n    \t\"row-gap\": \"normal|<length-percentage>\",\n    \t\"ruby-align\": \"start|center|space-between|space-around\",\n    \t\"ruby-merge\": \"separate|collapse|auto\",\n    \t\"ruby-position\": \"over|under|inter-character\",\n    \tscale: \"none|<number>{1,3}\",\n    \t\"scrollbar-color\": \"auto|dark|light|<color>{2}\",\n    \t\"scrollbar-width\": \"auto|thin|none\",\n    \t\"scroll-behavior\": \"auto|smooth\",\n    \t\"scroll-margin\": \"<length>{1,4}\",\n    \t\"scroll-margin-block\": \"<length>{1,2}\",\n    \t\"scroll-margin-block-start\": \"<length>\",\n    \t\"scroll-margin-block-end\": \"<length>\",\n    \t\"scroll-margin-bottom\": \"<length>\",\n    \t\"scroll-margin-inline\": \"<length>{1,2}\",\n    \t\"scroll-margin-inline-start\": \"<length>\",\n    \t\"scroll-margin-inline-end\": \"<length>\",\n    \t\"scroll-margin-left\": \"<length>\",\n    \t\"scroll-margin-right\": \"<length>\",\n    \t\"scroll-margin-top\": \"<length>\",\n    \t\"scroll-padding\": \"[auto|<length-percentage>]{1,4}\",\n    \t\"scroll-padding-block\": \"[auto|<length-percentage>]{1,2}\",\n    \t\"scroll-padding-block-start\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-block-end\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-bottom\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-inline\": \"[auto|<length-percentage>]{1,2}\",\n    \t\"scroll-padding-inline-start\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-inline-end\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-left\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-right\": \"auto|<length-percentage>\",\n    \t\"scroll-padding-top\": \"auto|<length-percentage>\",\n    \t\"scroll-snap-align\": \"[none|start|end|center]{1,2}\",\n    \t\"scroll-snap-coordinate\": \"none|<position>#\",\n    \t\"scroll-snap-destination\": \"<position>\",\n    \t\"scroll-snap-points-x\": \"none|repeat( <length-percentage> )\",\n    \t\"scroll-snap-points-y\": \"none|repeat( <length-percentage> )\",\n    \t\"scroll-snap-stop\": \"normal|always\",\n    \t\"scroll-snap-type\": \"none|[x|y|block|inline|both] [mandatory|proximity]?\",\n    \t\"scroll-snap-type-x\": \"none|mandatory|proximity\",\n    \t\"scroll-snap-type-y\": \"none|mandatory|proximity\",\n    \t\"shape-image-threshold\": \"<number>\",\n    \t\"shape-margin\": \"<length-percentage>\",\n    \t\"shape-outside\": \"none|<shape-box>||<basic-shape>|<image>\",\n    \t\"tab-size\": \"<integer>|<length>\",\n    \t\"table-layout\": \"auto|fixed\",\n    \t\"text-align\": \"start|end|left|right|center|justify|match-parent\",\n    \t\"text-align-last\": \"auto|start|end|left|right|center|justify\",\n    \t\"text-combine-upright\": \"none|all|[digits <integer>?]\",\n    \t\"text-decoration\": \"<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>\",\n    \t\"text-decoration-color\": \"<color>\",\n    \t\"text-decoration-line\": \"none|[underline||overline||line-through||blink]\",\n    \t\"text-decoration-skip\": \"none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]\",\n    \t\"text-decoration-skip-ink\": \"auto|none\",\n    \t\"text-decoration-style\": \"solid|double|dotted|dashed|wavy\",\n    \t\"text-emphasis\": \"<'text-emphasis-style'>||<'text-emphasis-color'>\",\n    \t\"text-emphasis-color\": \"<color>\",\n    \t\"text-emphasis-position\": \"[over|under]&&[right|left]\",\n    \t\"text-emphasis-style\": \"none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>\",\n    \t\"text-indent\": \"<length-percentage>&&hanging?&&each-line?\",\n    \t\"text-justify\": \"auto|inter-character|inter-word|none\",\n    \t\"text-orientation\": \"mixed|upright|sideways\",\n    \t\"text-overflow\": \"[clip|ellipsis|<string>]{1,2}\",\n    \t\"text-rendering\": \"auto|optimizeSpeed|optimizeLegibility|geometricPrecision\",\n    \t\"text-shadow\": \"none|<shadow-t>#\",\n    \t\"text-size-adjust\": \"none|auto|<percentage>\",\n    \t\"text-transform\": \"none|capitalize|uppercase|lowercase|full-width|full-size-kana\",\n    \t\"text-underline-position\": \"auto|[under||[left|right]]\",\n    \ttop: \"<length>|<percentage>|auto\",\n    \t\"touch-action\": \"auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation\",\n    \ttransform: \"none|<transform-list>\",\n    \t\"transform-box\": \"border-box|fill-box|view-box\",\n    \t\"transform-origin\": \"[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?\",\n    \t\"transform-style\": \"flat|preserve-3d\",\n    \ttransition: \"<single-transition>#\",\n    \t\"transition-delay\": \"<time>#\",\n    \t\"transition-duration\": \"<time>#\",\n    \t\"transition-property\": \"none|<single-transition-property>#\",\n    \t\"transition-timing-function\": \"<timing-function>#\",\n    \ttranslate: \"none|<length-percentage> [<length-percentage> <length>?]?\",\n    \t\"unicode-bidi\": \"normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate\",\n    \t\"user-select\": \"auto|text|none|contain|all\",\n    \t\"vertical-align\": \"baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>\",\n    \tvisibility: \"visible|hidden|collapse\",\n    \t\"white-space\": \"normal|pre|nowrap|pre-wrap|pre-line\",\n    \twidows: \"<integer>\",\n    \twidth: \"[<length>|<percentage>]&&[border-box|content-box]?|available|min-content|max-content|fit-content|auto\",\n    \t\"will-change\": \"auto|<animateable-feature>#\",\n    \t\"word-break\": \"normal|break-all|keep-all|break-word\",\n    \t\"word-spacing\": \"normal|<length-percentage>\",\n    \t\"word-wrap\": \"normal|break-word\",\n    \t\"writing-mode\": \"horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>\",\n    \t\"z-index\": \"auto|<integer>\",\n    \tzoom: \"normal|reset|<number>|<percentage>\",\n    \t\"-moz-background-clip\": \"padding|border\",\n    \t\"-moz-border-radius-bottomleft\": \"<'border-bottom-left-radius'>\",\n    \t\"-moz-border-radius-bottomright\": \"<'border-bottom-right-radius'>\",\n    \t\"-moz-border-radius-topleft\": \"<'border-top-left-radius'>\",\n    \t\"-moz-border-radius-topright\": \"<'border-bottom-right-radius'>\",\n    \t\"-moz-control-character-visibility\": \"visible|hidden\",\n    \t\"-moz-osx-font-smoothing\": \"auto|grayscale\",\n    \t\"-moz-user-select\": \"none|text|all|-moz-none\",\n    \t\"-ms-flex-align\": \"start|end|center|baseline|stretch\",\n    \t\"-ms-flex-item-align\": \"auto|start|end|center|baseline|stretch\",\n    \t\"-ms-flex-line-pack\": \"start|end|center|justify|distribute|stretch\",\n    \t\"-ms-flex-negative\": \"<'flex-shrink'>\",\n    \t\"-ms-flex-pack\": \"start|end|center|justify|distribute\",\n    \t\"-ms-flex-order\": \"<integer>\",\n    \t\"-ms-flex-positive\": \"<'flex-grow'>\",\n    \t\"-ms-flex-preferred-size\": \"<'flex-basis'>\",\n    \t\"-ms-interpolation-mode\": \"nearest-neighbor|bicubic\",\n    \t\"-ms-grid-column-align\": \"start|end|center|stretch\",\n    \t\"-ms-grid-columns\": \"<track-list-v0>\",\n    \t\"-ms-grid-row-align\": \"start|end|center|stretch\",\n    \t\"-ms-grid-rows\": \"<track-list-v0>\",\n    \t\"-ms-hyphenate-limit-last\": \"none|always|column|page|spread\",\n    \t\"-webkit-background-clip\": \"[<box>|border|padding|content|text]#\",\n    \t\"-webkit-column-break-after\": \"always|auto|avoid\",\n    \t\"-webkit-column-break-before\": \"always|auto|avoid\",\n    \t\"-webkit-column-break-inside\": \"always|auto|avoid\",\n    \t\"-webkit-font-smoothing\": \"auto|none|antialiased|subpixel-antialiased\",\n    \t\"-webkit-mask-box-image\": \"[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?\",\n    \t\"-webkit-print-color-adjust\": \"economy|exact\",\n    \t\"-webkit-text-security\": \"none|circle|disc|square\",\n    \t\"-webkit-user-drag\": \"none|element|auto\",\n    \t\"-webkit-user-select\": \"auto|none|text|all\",\n    \t\"alignment-baseline\": \"auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical\",\n    \t\"baseline-shift\": \"baseline|sub|super|<svg-length>\",\n    \tbehavior: \"<url>+\",\n    \t\"clip-rule\": \"nonzero|evenodd\",\n    \tcue: \"<'cue-before'> <'cue-after'>?\",\n    \t\"cue-after\": \"<url> <decibel>?|none\",\n    \t\"cue-before\": \"<url> <decibel>?|none\",\n    \t\"dominant-baseline\": \"auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge\",\n    \tfill: \"<paint>\",\n    \t\"fill-opacity\": \"<number-zero-one>\",\n    \t\"fill-rule\": \"nonzero|evenodd\",\n    \t\"glyph-orientation-horizontal\": \"<angle>\",\n    \t\"glyph-orientation-vertical\": \"<angle>\",\n    \tkerning: \"auto|<svg-length>\",\n    \tmarker: \"none|<url>\",\n    \t\"marker-end\": \"none|<url>\",\n    \t\"marker-mid\": \"none|<url>\",\n    \t\"marker-start\": \"none|<url>\",\n    \tpause: \"<'pause-before'> <'pause-after'>?\",\n    \t\"pause-after\": \"<time>|none|x-weak|weak|medium|strong|x-strong\",\n    \t\"pause-before\": \"<time>|none|x-weak|weak|medium|strong|x-strong\",\n    \trest: \"<'rest-before'> <'rest-after'>?\",\n    \t\"rest-after\": \"<time>|none|x-weak|weak|medium|strong|x-strong\",\n    \t\"rest-before\": \"<time>|none|x-weak|weak|medium|strong|x-strong\",\n    \t\"shape-rendering\": \"auto|optimizeSpeed|crispEdges|geometricPrecision\",\n    \tsrc: \"[<url> [format( <string># )]?|local( <family-name> )]#\",\n    \tspeak: \"auto|none|normal\",\n    \t\"speak-as\": \"normal|spell-out||digits||[literal-punctuation|no-punctuation]\",\n    \tstroke: \"<paint>\",\n    \t\"stroke-dasharray\": \"none|[<svg-length>+]#\",\n    \t\"stroke-dashoffset\": \"<svg-length>\",\n    \t\"stroke-linecap\": \"butt|round|square\",\n    \t\"stroke-linejoin\": \"miter|round|bevel\",\n    \t\"stroke-miterlimit\": \"<number-one-or-greater>\",\n    \t\"stroke-opacity\": \"<number-zero-one>\",\n    \t\"stroke-width\": \"<svg-length>\",\n    \t\"text-anchor\": \"start|middle|end\",\n    \t\"unicode-range\": \"<urange>#\",\n    \t\"voice-balance\": \"<number>|left|center|right|leftwards|rightwards\",\n    \t\"voice-duration\": \"auto|<time>\",\n    \t\"voice-family\": \"[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve\",\n    \t\"voice-pitch\": \"<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]\",\n    \t\"voice-range\": \"<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]\",\n    \t\"voice-rate\": \"[normal|x-slow|slow|medium|fast|x-fast]||<percentage>\",\n    \t\"voice-stress\": \"normal|strong|moderate|none|reduced\",\n    \t\"voice-volume\": \"silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]\"\n    };\n    var defaultSyntax = {\n    \tgeneric: generic$1,\n    \ttypes: types,\n    \tproperties: properties$1\n    };\n\n    var defaultSyntax$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        generic: generic$1,\n        types: types,\n        properties: properties$1,\n        'default': defaultSyntax\n    });\n\n    var cmpChar$3 = tokenizer.cmpChar;\n    var isDigit$4 = tokenizer.isDigit;\n    var TYPE$9 = tokenizer.TYPE;\n\n    var WHITESPACE$4 = TYPE$9.WhiteSpace;\n    var COMMENT$3 = TYPE$9.Comment;\n    var IDENT$3 = TYPE$9.Ident;\n    var NUMBER$3 = TYPE$9.Number;\n    var DIMENSION$2 = TYPE$9.Dimension;\n    var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)\n    var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)\n    var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\n    var DISALLOW_SIGN$1 = true;\n    var ALLOW_SIGN$1 = false;\n\n    function checkInteger$1(offset, disallowSign) {\n        var pos = this.scanner.tokenStart + offset;\n        var code = this.scanner.source.charCodeAt(pos);\n\n        if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {\n            if (disallowSign) {\n                this.error('Number sign is not allowed');\n            }\n            pos++;\n        }\n\n        for (; pos < this.scanner.tokenEnd; pos++) {\n            if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {\n                this.error('Integer is expected', pos);\n            }\n        }\n    }\n\n    function checkTokenIsInteger(disallowSign) {\n        return checkInteger$1.call(this, 0, disallowSign);\n    }\n\n    function expectCharCode(offset, code) {\n        if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {\n            var msg = '';\n\n            switch (code) {\n                case N$4:\n                    msg = 'N is expected';\n                    break;\n                case HYPHENMINUS$3:\n                    msg = 'HyphenMinus is expected';\n                    break;\n            }\n\n            this.error(msg, this.scanner.tokenStart + offset);\n        }\n    }\n\n    // ... <signed-integer>\n    // ... ['+' | '-'] <signless-integer>\n    function consumeB$1() {\n        var offset = 0;\n        var sign = 0;\n        var type = this.scanner.tokenType;\n\n        while (type === WHITESPACE$4 || type === COMMENT$3) {\n            type = this.scanner.lookupType(++offset);\n        }\n\n        if (type !== NUMBER$3) {\n            if (this.scanner.isDelim(PLUSSIGN$3, offset) ||\n                this.scanner.isDelim(HYPHENMINUS$3, offset)) {\n                sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;\n\n                do {\n                    type = this.scanner.lookupType(++offset);\n                } while (type === WHITESPACE$4 || type === COMMENT$3);\n\n                if (type !== NUMBER$3) {\n                    this.scanner.skip(offset);\n                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);\n                }\n            } else {\n                return null;\n            }\n        }\n\n        if (offset > 0) {\n            this.scanner.skip(offset);\n        }\n\n        if (sign === 0) {\n            type = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n            if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {\n                this.error('Number sign is expected');\n            }\n        }\n\n        checkTokenIsInteger.call(this, sign !== 0);\n        return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);\n    }\n\n    // An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\n    var AnPlusB = {\n        name: 'AnPlusB',\n        structure: {\n            a: [String, null],\n            b: [String, null]\n        },\n        parse: function() {\n            /* eslint-disable brace-style*/\n            var start = this.scanner.tokenStart;\n            var a = null;\n            var b = null;\n\n            // <integer>\n            if (this.scanner.tokenType === NUMBER$3) {\n                checkTokenIsInteger.call(this, ALLOW_SIGN$1);\n                b = this.consume(NUMBER$3);\n            }\n\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            // -n- <signless-integer>\n            // <dashndashdigit-ident>\n            else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {\n                a = '-1';\n\n                expectCharCode.call(this, 1, N$4);\n\n                switch (this.scanner.getTokenLength()) {\n                    // -n\n                    // -n <signed-integer>\n                    // -n ['+' | '-'] <signless-integer>\n                    case 2:\n                        this.scanner.next();\n                        b = consumeB$1.call(this);\n                        break;\n\n                    // -n- <signless-integer>\n                    case 3:\n                        expectCharCode.call(this, 2, HYPHENMINUS$3);\n\n                        this.scanner.next();\n                        this.scanner.skipSC();\n\n                        checkTokenIsInteger.call(this, DISALLOW_SIGN$1);\n\n                        b = '-' + this.consume(NUMBER$3);\n                        break;\n\n                    // <dashndashdigit-ident>\n                    default:\n                        expectCharCode.call(this, 2, HYPHENMINUS$3);\n                        checkInteger$1.call(this, 3, DISALLOW_SIGN$1);\n                        this.scanner.next();\n\n                        b = this.scanner.substrToCursor(start + 2);\n                }\n            }\n\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            // '+'? n- <signless-integer>\n            // '+'? <ndashdigit-ident>\n            else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {\n                var sign = 0;\n                a = '1';\n\n                // just ignore a plus\n                if (this.scanner.isDelim(PLUSSIGN$3)) {\n                    sign = 1;\n                    this.scanner.next();\n                }\n\n                expectCharCode.call(this, 0, N$4);\n\n                switch (this.scanner.getTokenLength()) {\n                    // '+'? n\n                    // '+'? n <signed-integer>\n                    // '+'? n ['+' | '-'] <signless-integer>\n                    case 1:\n                        this.scanner.next();\n                        b = consumeB$1.call(this);\n                        break;\n\n                    // '+'? n- <signless-integer>\n                    case 2:\n                        expectCharCode.call(this, 1, HYPHENMINUS$3);\n\n                        this.scanner.next();\n                        this.scanner.skipSC();\n\n                        checkTokenIsInteger.call(this, DISALLOW_SIGN$1);\n\n                        b = '-' + this.consume(NUMBER$3);\n                        break;\n\n                    // '+'? <ndashdigit-ident>\n                    default:\n                        expectCharCode.call(this, 1, HYPHENMINUS$3);\n                        checkInteger$1.call(this, 2, DISALLOW_SIGN$1);\n                        this.scanner.next();\n\n                        b = this.scanner.substrToCursor(start + sign + 1);\n                }\n            }\n\n            // <ndashdigit-dimension>\n            // <ndash-dimension> <signless-integer>\n            // <n-dimension>\n            // <n-dimension> <signed-integer>\n            // <n-dimension> ['+' | '-'] <signless-integer>\n            else if (this.scanner.tokenType === DIMENSION$2) {\n                var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n                var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;\n\n                for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {\n                    if (!isDigit$4(this.scanner.source.charCodeAt(i))) {\n                        break;\n                    }\n                }\n\n                if (i === this.scanner.tokenStart + sign) {\n                    this.error('Integer is expected', this.scanner.tokenStart + sign);\n                }\n\n                expectCharCode.call(this, i - this.scanner.tokenStart, N$4);\n                a = this.scanner.source.substring(start, i);\n\n                // <n-dimension>\n                // <n-dimension> <signed-integer>\n                // <n-dimension> ['+' | '-'] <signless-integer>\n                if (i + 1 === this.scanner.tokenEnd) {\n                    this.scanner.next();\n                    b = consumeB$1.call(this);\n                } else {\n                    expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);\n\n                    // <ndash-dimension> <signless-integer>\n                    if (i + 2 === this.scanner.tokenEnd) {\n                        this.scanner.next();\n                        this.scanner.skipSC();\n                        checkTokenIsInteger.call(this, DISALLOW_SIGN$1);\n                        b = '-' + this.consume(NUMBER$3);\n                    }\n                    // <ndashdigit-dimension>\n                    else {\n                        checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);\n                        this.scanner.next();\n                        b = this.scanner.substrToCursor(i + 1);\n                    }\n                }\n            } else {\n                this.error();\n            }\n\n            if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {\n                a = a.substr(1);\n            }\n\n            if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {\n                b = b.substr(1);\n            }\n\n            return {\n                type: 'AnPlusB',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                a: a,\n                b: b\n            };\n        },\n        generate: function(node) {\n            var a = node.a !== null && node.a !== undefined;\n            var b = node.b !== null && node.b !== undefined;\n\n            if (a) {\n                this.chunk(\n                    node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent\n                    node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent\n                    node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent\n                    node.a + 'n'             // eslint-disable-line operator-linebreak, indent\n                );\n\n                if (b) {\n                    b = String(node.b);\n                    if (b.charAt(0) === '-' || b.charAt(0) === '+') {\n                        this.chunk(b.charAt(0));\n                        this.chunk(b.substr(1));\n                    } else {\n                        this.chunk('+');\n                        this.chunk(b);\n                    }\n                }\n            } else {\n                this.chunk(String(node.b));\n            }\n        }\n    };\n\n    var TYPE$a = tokenizer.TYPE;\n\n    var WhiteSpace = TYPE$a.WhiteSpace;\n    var Semicolon = TYPE$a.Semicolon;\n    var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;\n    var Delim = TYPE$a.Delim;\n    var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\n    function getOffsetExcludeWS() {\n        if (this.scanner.tokenIndex > 0) {\n            if (this.scanner.lookupType(-1) === WhiteSpace) {\n                return this.scanner.tokenIndex > 1\n                    ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)\n                    : this.scanner.firstCharOffset;\n            }\n        }\n\n        return this.scanner.tokenStart;\n    }\n\n    // 0, 0, false\n    function balanceEnd() {\n        return 0;\n    }\n\n    // LEFTCURLYBRACKET, 0, false\n    function leftCurlyBracket(tokenType) {\n        return tokenType === LeftCurlyBracket ? 1 : 0;\n    }\n\n    // LEFTCURLYBRACKET, SEMICOLON, false\n    function leftCurlyBracketOrSemicolon(tokenType) {\n        return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;\n    }\n\n    // EXCLAMATIONMARK, SEMICOLON, false\n    function exclamationMarkOrSemicolon(tokenType, source, offset) {\n        if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {\n            return 1;\n        }\n\n        return tokenType === Semicolon ? 1 : 0;\n    }\n\n    // 0, SEMICOLON, true\n    function semicolonIncluded(tokenType) {\n        return tokenType === Semicolon ? 2 : 0;\n    }\n\n    var Raw = {\n        name: 'Raw',\n        structure: {\n            value: String\n        },\n        parse: function(startToken, mode, excludeWhiteSpace) {\n            var startOffset = this.scanner.getTokenStart(startToken);\n            var endOffset;\n\n            this.scanner.skip(\n                this.scanner.getRawLength(startToken, mode || balanceEnd)\n            );\n\n            if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {\n                endOffset = getOffsetExcludeWS.call(this);\n            } else {\n                endOffset = this.scanner.tokenStart;\n            }\n\n            return {\n                type: 'Raw',\n                loc: this.getLocation(startOffset, endOffset),\n                value: this.scanner.source.substring(startOffset, endOffset)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n        },\n\n        mode: {\n            default: balanceEnd,\n            leftCurlyBracket: leftCurlyBracket,\n            leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,\n            exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,\n            semicolonIncluded: semicolonIncluded\n        }\n    };\n\n    var TYPE$b = tokenizer.TYPE;\n    var rawMode = Raw.mode;\n\n    var ATKEYWORD = TYPE$b.AtKeyword;\n    var SEMICOLON = TYPE$b.Semicolon;\n    var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;\n    var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;\n\n    function consumeRaw(startToken) {\n        return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);\n    }\n\n    function isDeclarationBlockAtrule() {\n        for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {\n            if (type === RIGHTCURLYBRACKET$1) {\n                return true;\n            }\n\n            if (type === LEFTCURLYBRACKET$1 ||\n                type === ATKEYWORD) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    var Atrule = {\n        name: 'Atrule',\n        structure: {\n            name: String,\n            prelude: ['AtrulePrelude', 'Raw', null],\n            block: ['Block', null]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var name;\n            var nameLowerCase;\n            var prelude = null;\n            var block = null;\n\n            this.eat(ATKEYWORD);\n\n            name = this.scanner.substrToCursor(start + 1);\n            nameLowerCase = name.toLowerCase();\n            this.scanner.skipSC();\n\n            // parse prelude\n            if (this.scanner.eof === false &&\n                this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&\n                this.scanner.tokenType !== SEMICOLON) {\n                if (this.parseAtrulePrelude) {\n                    prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);\n\n                    // turn empty AtrulePrelude into null\n                    if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {\n                        prelude = null;\n                    }\n                } else {\n                    prelude = consumeRaw.call(this, this.scanner.tokenIndex);\n                }\n\n                this.scanner.skipSC();\n            }\n\n            switch (this.scanner.tokenType) {\n                case SEMICOLON:\n                    this.scanner.next();\n                    break;\n\n                case LEFTCURLYBRACKET$1:\n                    if (this.atrule.hasOwnProperty(nameLowerCase) &&\n                        typeof this.atrule[nameLowerCase].block === 'function') {\n                        block = this.atrule[nameLowerCase].block.call(this);\n                    } else {\n                        // TODO: should consume block content as Raw?\n                        block = this.Block(isDeclarationBlockAtrule.call(this));\n                    }\n\n                    break;\n            }\n\n            return {\n                type: 'Atrule',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: name,\n                prelude: prelude,\n                block: block\n            };\n        },\n        generate: function(node) {\n            this.chunk('@');\n            this.chunk(node.name);\n\n            if (node.prelude !== null) {\n                this.chunk(' ');\n                this.node(node.prelude);\n            }\n\n            if (node.block) {\n                this.node(node.block);\n            } else {\n                this.chunk(';');\n            }\n        },\n        walkContext: 'atrule'\n    };\n\n    var TYPE$c = tokenizer.TYPE;\n\n    var SEMICOLON$1 = TYPE$c.Semicolon;\n    var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;\n\n    var AtrulePrelude = {\n        name: 'AtrulePrelude',\n        structure: {\n            children: [[]]\n        },\n        parse: function(name) {\n            var children = null;\n\n            if (name !== null) {\n                name = name.toLowerCase();\n            }\n\n            this.scanner.skipSC();\n\n            if (this.atrule.hasOwnProperty(name) &&\n                typeof this.atrule[name].prelude === 'function') {\n                // custom consumer\n                children = this.atrule[name].prelude.call(this);\n            } else {\n                // default consumer\n                children = this.readSequence(this.scope.AtrulePrelude);\n            }\n\n            this.scanner.skipSC();\n\n            if (this.scanner.eof !== true &&\n                this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&\n                this.scanner.tokenType !== SEMICOLON$1) {\n                this.error('Semicolon or block is expected');\n            }\n\n            if (children === null) {\n                children = this.createList();\n            }\n\n            return {\n                type: 'AtrulePrelude',\n                loc: this.getLocationFromList(children),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node);\n        },\n        walkContext: 'atrulePrelude'\n    };\n\n    var TYPE$d = tokenizer.TYPE;\n\n    var IDENT$4 = TYPE$d.Ident;\n    var STRING = TYPE$d.String;\n    var COLON = TYPE$d.Colon;\n    var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;\n    var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;\n    var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)\n    var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)\n    var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)\n    var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)\n    var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)\n    var TILDE = 0x007E;            // U+007E TILDE (~)\n\n    function getAttributeName() {\n        if (this.scanner.eof) {\n            this.error('Unexpected end of input');\n        }\n\n        var start = this.scanner.tokenStart;\n        var expectIdent = false;\n        var checkColon = true;\n\n        if (this.scanner.isDelim(ASTERISK$1)) {\n            expectIdent = true;\n            checkColon = false;\n            this.scanner.next();\n        } else if (!this.scanner.isDelim(VERTICALLINE$1)) {\n            this.eat(IDENT$4);\n        }\n\n        if (this.scanner.isDelim(VERTICALLINE$1)) {\n            if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {\n                this.scanner.next();\n                this.eat(IDENT$4);\n            } else if (expectIdent) {\n                this.error('Identifier is expected', this.scanner.tokenEnd);\n            }\n        } else if (expectIdent) {\n            this.error('Vertical line is expected');\n        }\n\n        if (checkColon && this.scanner.tokenType === COLON) {\n            this.scanner.next();\n            this.eat(IDENT$4);\n        }\n\n        return {\n            type: 'Identifier',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: this.scanner.substrToCursor(start)\n        };\n    }\n\n    function getOperator() {\n        var start = this.scanner.tokenStart;\n        var code = this.scanner.source.charCodeAt(start);\n\n        if (code !== EQUALSSIGN &&        // =\n            code !== TILDE &&             // ~=\n            code !== CIRCUMFLEXACCENT &&  // ^=\n            code !== DOLLARSIGN &&        // $=\n            code !== ASTERISK$1 &&          // *=\n            code !== VERTICALLINE$1         // |=\n        ) {\n            this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n        }\n\n        this.scanner.next();\n\n        if (code !== EQUALSSIGN) {\n            if (!this.scanner.isDelim(EQUALSSIGN)) {\n                this.error('Equal sign is expected');\n            }\n\n            this.scanner.next();\n        }\n\n        return this.scanner.substrToCursor(start);\n    }\n\n    // '[' <wq-name> ']'\n    // '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\n    var AttributeSelector = {\n        name: 'AttributeSelector',\n        structure: {\n            name: 'Identifier',\n            matcher: [String, null],\n            value: ['String', 'Identifier', null],\n            flags: [String, null]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var name;\n            var matcher = null;\n            var value = null;\n            var flags = null;\n\n            this.eat(LEFTSQUAREBRACKET$1);\n            this.scanner.skipSC();\n\n            name = getAttributeName.call(this);\n            this.scanner.skipSC();\n\n            if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {\n                // avoid case `[name i]`\n                if (this.scanner.tokenType !== IDENT$4) {\n                    matcher = getOperator.call(this);\n\n                    this.scanner.skipSC();\n\n                    value = this.scanner.tokenType === STRING\n                        ? this.String()\n                        : this.Identifier();\n\n                    this.scanner.skipSC();\n                }\n\n                // attribute flags\n                if (this.scanner.tokenType === IDENT$4) {\n                    flags = this.scanner.getTokenValue();\n                    this.scanner.next();\n\n                    this.scanner.skipSC();\n                }\n            }\n\n            this.eat(RIGHTSQUAREBRACKET$1);\n\n            return {\n                type: 'AttributeSelector',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: name,\n                matcher: matcher,\n                value: value,\n                flags: flags\n            };\n        },\n        generate: function(node) {\n            var flagsPrefix = ' ';\n\n            this.chunk('[');\n            this.node(node.name);\n\n            if (node.matcher !== null) {\n                this.chunk(node.matcher);\n\n                if (node.value !== null) {\n                    this.node(node.value);\n\n                    // space between string and flags is not required\n                    if (node.value.type === 'String') {\n                        flagsPrefix = '';\n                    }\n                }\n            }\n\n            if (node.flags !== null) {\n                this.chunk(flagsPrefix);\n                this.chunk(node.flags);\n            }\n\n            this.chunk(']');\n        }\n    };\n\n    var TYPE$e = tokenizer.TYPE;\n    var rawMode$1 = Raw.mode;\n\n    var WHITESPACE$5 = TYPE$e.WhiteSpace;\n    var COMMENT$4 = TYPE$e.Comment;\n    var SEMICOLON$2 = TYPE$e.Semicolon;\n    var ATKEYWORD$1 = TYPE$e.AtKeyword;\n    var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;\n    var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;\n\n    function consumeRaw$1(startToken) {\n        return this.Raw(startToken, null, true);\n    }\n    function consumeRule() {\n        return this.parseWithFallback(this.Rule, consumeRaw$1);\n    }\n    function consumeRawDeclaration(startToken) {\n        return this.Raw(startToken, rawMode$1.semicolonIncluded, true);\n    }\n    function consumeDeclaration() {\n        if (this.scanner.tokenType === SEMICOLON$2) {\n            return consumeRawDeclaration.call(this, this.scanner.tokenIndex);\n        }\n\n        var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);\n\n        if (this.scanner.tokenType === SEMICOLON$2) {\n            this.scanner.next();\n        }\n\n        return node;\n    }\n\n    var Block = {\n        name: 'Block',\n        structure: {\n            children: [[\n                'Atrule',\n                'Rule',\n                'Declaration'\n            ]]\n        },\n        parse: function(isDeclaration) {\n            var consumer = isDeclaration ? consumeDeclaration : consumeRule;\n\n            var start = this.scanner.tokenStart;\n            var children = this.createList();\n\n            this.eat(LEFTCURLYBRACKET$3);\n\n            scan:\n            while (!this.scanner.eof) {\n                switch (this.scanner.tokenType) {\n                    case RIGHTCURLYBRACKET$2:\n                        break scan;\n\n                    case WHITESPACE$5:\n                    case COMMENT$4:\n                        this.scanner.next();\n                        break;\n\n                    case ATKEYWORD$1:\n                        children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));\n                        break;\n\n                    default:\n                        children.push(consumer.call(this));\n                }\n            }\n\n            if (!this.scanner.eof) {\n                this.eat(RIGHTCURLYBRACKET$2);\n            }\n\n            return {\n                type: 'Block',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.chunk('{');\n            this.children(node, function(prev) {\n                if (prev.type === 'Declaration') {\n                    this.chunk(';');\n                }\n            });\n            this.chunk('}');\n        },\n        walkContext: 'block'\n    };\n\n    var TYPE$f = tokenizer.TYPE;\n\n    var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;\n    var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;\n\n    var Brackets = {\n        name: 'Brackets',\n        structure: {\n            children: [[]]\n        },\n        parse: function(readSequence, recognizer) {\n            var start = this.scanner.tokenStart;\n            var children = null;\n\n            this.eat(LEFTSQUAREBRACKET$2);\n\n            children = readSequence.call(this, recognizer);\n\n            if (!this.scanner.eof) {\n                this.eat(RIGHTSQUAREBRACKET$2);\n            }\n\n            return {\n                type: 'Brackets',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.chunk('[');\n            this.children(node);\n            this.chunk(']');\n        }\n    };\n\n    var CDC = tokenizer.TYPE.CDC;\n\n    var CDC_1 = {\n        name: 'CDC',\n        structure: [],\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            this.eat(CDC); // -->\n\n            return {\n                type: 'CDC',\n                loc: this.getLocation(start, this.scanner.tokenStart)\n            };\n        },\n        generate: function() {\n            this.chunk('-->');\n        }\n    };\n\n    var CDO = tokenizer.TYPE.CDO;\n\n    var CDO_1 = {\n        name: 'CDO',\n        structure: [],\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            this.eat(CDO); // <!--\n\n            return {\n                type: 'CDO',\n                loc: this.getLocation(start, this.scanner.tokenStart)\n            };\n        },\n        generate: function() {\n            this.chunk('<!--');\n        }\n    };\n\n    var TYPE$g = tokenizer.TYPE;\n\n    var IDENT$5 = TYPE$g.Ident;\n    var FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n    // '.' ident\n    var ClassSelector = {\n        name: 'ClassSelector',\n        structure: {\n            name: String\n        },\n        parse: function() {\n            if (!this.scanner.isDelim(FULLSTOP)) {\n                this.error('Full stop is expected');\n            }\n\n            this.scanner.next();\n\n            return {\n                type: 'ClassSelector',\n                loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),\n                name: this.consume(IDENT$5)\n            };\n        },\n        generate: function(node) {\n            this.chunk('.');\n            this.chunk(node.name);\n        }\n    };\n\n    var TYPE$h = tokenizer.TYPE;\n\n    var IDENT$6 = TYPE$h.Ident;\n    var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)\n    var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n    var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)\n    var TILDE$1 = 0x007E;           // U+007E TILDE (~)\n\n    // + | > | ~ | /deep/\n    var Combinator = {\n        name: 'Combinator',\n        structure: {\n            name: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n\n            switch (code) {\n                case GREATERTHANSIGN$1:\n                case PLUSSIGN$4:\n                case TILDE$1:\n                    this.scanner.next();\n                    break;\n\n                case SOLIDUS:\n                    this.scanner.next();\n\n                    if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {\n                        this.error('Identifier `deep` is expected');\n                    }\n\n                    this.scanner.next();\n\n                    if (!this.scanner.isDelim(SOLIDUS)) {\n                        this.error('Solidus is expected');\n                    }\n\n                    this.scanner.next();\n                    break;\n\n                default:\n                    this.error('Combinator is expected');\n            }\n\n            return {\n                type: 'Combinator',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: this.scanner.substrToCursor(start)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.name);\n        }\n    };\n\n    var TYPE$i = tokenizer.TYPE;\n\n    var COMMENT$5 = TYPE$i.Comment;\n    var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)\n    var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)\n\n    // '/*' .* '*/'\n    var Comment = {\n        name: 'Comment',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var end = this.scanner.tokenEnd;\n\n            this.eat(COMMENT$5);\n\n            if ((end - start + 2) >= 2 &&\n                this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&\n                this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {\n                end -= 2;\n            }\n\n            return {\n                type: 'Comment',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: this.scanner.source.substring(start + 2, end)\n            };\n        },\n        generate: function(node) {\n            this.chunk('/*');\n            this.chunk(node.value);\n            this.chunk('*/');\n        }\n    };\n\n    var isCustomProperty$1 = names.isCustomProperty;\n    var TYPE$j = tokenizer.TYPE;\n    var rawMode$2 = Raw.mode;\n\n    var IDENT$7 = TYPE$j.Ident;\n    var HASH$1 = TYPE$j.Hash;\n    var COLON$1 = TYPE$j.Colon;\n    var SEMICOLON$3 = TYPE$j.Semicolon;\n    var DELIM$2 = TYPE$j.Delim;\n    var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)\n    var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)\n    var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)\n    var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)\n    var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)\n    var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)\n    var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)\n\n    function consumeValueRaw(startToken) {\n        return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);\n    }\n\n    function consumeCustomPropertyRaw(startToken) {\n        return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);\n    }\n\n    function consumeValue() {\n        var startValueToken = this.scanner.tokenIndex;\n        var value = this.Value();\n\n        if (value.type !== 'Raw' &&\n            this.scanner.eof === false &&\n            this.scanner.tokenType !== SEMICOLON$3 &&\n            this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&\n            this.scanner.isBalanceEdge(startValueToken) === false) {\n            this.error();\n        }\n\n        return value;\n    }\n\n    var Declaration = {\n        name: 'Declaration',\n        structure: {\n            important: [Boolean, String],\n            property: String,\n            value: ['Value', 'Raw']\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var startToken = this.scanner.tokenIndex;\n            var property = readProperty$1.call(this);\n            var customProperty = isCustomProperty$1(property);\n            var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;\n            var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;\n            var important = false;\n            var value;\n\n            this.scanner.skipSC();\n            this.eat(COLON$1);\n\n            if (!customProperty) {\n                this.scanner.skipSC();\n            }\n\n            if (parseValue) {\n                value = this.parseWithFallback(consumeValue, consumeRaw);\n            } else {\n                value = consumeRaw.call(this, this.scanner.tokenIndex);\n            }\n\n            if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {\n                important = getImportant.call(this);\n                this.scanner.skipSC();\n            }\n\n            // Do not include semicolon to range per spec\n            // https://drafts.csswg.org/css-syntax/#declaration-diagram\n\n            if (this.scanner.eof === false &&\n                this.scanner.tokenType !== SEMICOLON$3 &&\n                this.scanner.isBalanceEdge(startToken) === false) {\n                this.error();\n            }\n\n            return {\n                type: 'Declaration',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                important: important,\n                property: property,\n                value: value\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.property);\n            this.chunk(':');\n            this.node(node.value);\n\n            if (node.important) {\n                this.chunk(node.important === true ? '!important' : '!' + node.important);\n            }\n        },\n        walkContext: 'declaration'\n    };\n\n    function readProperty$1() {\n        var start = this.scanner.tokenStart;\n\n        // hacks\n        if (this.scanner.tokenType === DELIM$2) {\n            switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {\n                case ASTERISK$3:\n                case DOLLARSIGN$1:\n                case PLUSSIGN$5:\n                case NUMBERSIGN$2:\n                case AMPERSAND$1:\n                    this.scanner.next();\n                    break;\n\n                // TODO: not sure we should support this hack\n                case SOLIDUS$2:\n                    this.scanner.next();\n                    if (this.scanner.isDelim(SOLIDUS$2)) {\n                        this.scanner.next();\n                    }\n                    break;\n            }\n        }\n\n        if (this.scanner.tokenType === HASH$1) {\n            this.eat(HASH$1);\n        } else {\n            this.eat(IDENT$7);\n        }\n\n        return this.scanner.substrToCursor(start);\n    }\n\n    // ! ws* important\n    function getImportant() {\n        this.eat(DELIM$2);\n        this.scanner.skipSC();\n\n        var important = this.consume(IDENT$7);\n\n        // store original value in case it differ from `important`\n        // for better original source restoring and hacks like `!ie` support\n        return important === 'important' ? true : important;\n    }\n\n    var TYPE$k = tokenizer.TYPE;\n    var rawMode$3 = Raw.mode;\n\n    var WHITESPACE$6 = TYPE$k.WhiteSpace;\n    var COMMENT$6 = TYPE$k.Comment;\n    var SEMICOLON$4 = TYPE$k.Semicolon;\n\n    function consumeRaw$2(startToken) {\n        return this.Raw(startToken, rawMode$3.semicolonIncluded, true);\n    }\n\n    var DeclarationList = {\n        name: 'DeclarationList',\n        structure: {\n            children: [[\n                'Declaration'\n            ]]\n        },\n        parse: function() {\n            var children = this.createList();\n\n            scan:\n            while (!this.scanner.eof) {\n                switch (this.scanner.tokenType) {\n                    case WHITESPACE$6:\n                    case COMMENT$6:\n                    case SEMICOLON$4:\n                        this.scanner.next();\n                        break;\n\n                    default:\n                        children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));\n                }\n            }\n\n            return {\n                type: 'DeclarationList',\n                loc: this.getLocationFromList(children),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node, function(prev) {\n                if (prev.type === 'Declaration') {\n                    this.chunk(';');\n                }\n            });\n        }\n    };\n\n    var consumeNumber$3 = utils.consumeNumber;\n    var TYPE$l = tokenizer.TYPE;\n\n    var DIMENSION$3 = TYPE$l.Dimension;\n\n    var Dimension = {\n        name: 'Dimension',\n        structure: {\n            value: String,\n            unit: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var numberEnd = consumeNumber$3(this.scanner.source, start);\n\n            this.eat(DIMENSION$3);\n\n            return {\n                type: 'Dimension',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: this.scanner.source.substring(start, numberEnd),\n                unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n            this.chunk(node.unit);\n        }\n    };\n\n    var TYPE$m = tokenizer.TYPE;\n\n    var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;\n\n    // <function-token> <sequence> )\n    var _Function = {\n        name: 'Function',\n        structure: {\n            name: String,\n            children: [[]]\n        },\n        parse: function(readSequence, recognizer) {\n            var start = this.scanner.tokenStart;\n            var name = this.consumeFunctionName();\n            var nameLowerCase = name.toLowerCase();\n            var children;\n\n            children = recognizer.hasOwnProperty(nameLowerCase)\n                ? recognizer[nameLowerCase].call(this, recognizer)\n                : readSequence.call(this, recognizer);\n\n            if (!this.scanner.eof) {\n                this.eat(RIGHTPARENTHESIS$2);\n            }\n\n            return {\n                type: 'Function',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: name,\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.name);\n            this.chunk('(');\n            this.children(node);\n            this.chunk(')');\n        },\n        walkContext: 'function'\n    };\n\n    var TYPE$n = tokenizer.TYPE;\n\n    var HASH$2 = TYPE$n.Hash;\n\n    // '#' ident\n    var HexColor = {\n        name: 'HexColor',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            this.eat(HASH$2);\n\n            return {\n                type: 'HexColor',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: this.scanner.substrToCursor(start + 1)\n            };\n        },\n        generate: function(node) {\n            this.chunk('#');\n            this.chunk(node.value);\n        }\n    };\n\n    var TYPE$o = tokenizer.TYPE;\n\n    var IDENT$8 = TYPE$o.Ident;\n\n    var Identifier = {\n        name: 'Identifier',\n        structure: {\n            name: String\n        },\n        parse: function() {\n            return {\n                type: 'Identifier',\n                loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n                name: this.consume(IDENT$8)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.name);\n        }\n    };\n\n    var TYPE$p = tokenizer.TYPE;\n\n    var HASH$3 = TYPE$p.Hash;\n\n    // <hash-token>\n    var IdSelector = {\n        name: 'IdSelector',\n        structure: {\n            name: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            // TODO: check value is an ident\n            this.eat(HASH$3);\n\n            return {\n                type: 'IdSelector',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: this.scanner.substrToCursor(start + 1)\n            };\n        },\n        generate: function(node) {\n            this.chunk('#');\n            this.chunk(node.name);\n        }\n    };\n\n    var TYPE$q = tokenizer.TYPE;\n\n    var IDENT$9 = TYPE$q.Ident;\n    var NUMBER$4 = TYPE$q.Number;\n    var DIMENSION$4 = TYPE$q.Dimension;\n    var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;\n    var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;\n    var COLON$2 = TYPE$q.Colon;\n    var DELIM$3 = TYPE$q.Delim;\n\n    var MediaFeature = {\n        name: 'MediaFeature',\n        structure: {\n            name: String,\n            value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var name;\n            var value = null;\n\n            this.eat(LEFTPARENTHESIS$2);\n            this.scanner.skipSC();\n\n            name = this.consume(IDENT$9);\n            this.scanner.skipSC();\n\n            if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {\n                this.eat(COLON$2);\n                this.scanner.skipSC();\n\n                switch (this.scanner.tokenType) {\n                    case NUMBER$4:\n                        if (this.lookupNonWSType(1) === DELIM$3) {\n                            value = this.Ratio();\n                        } else {\n                            value = this.Number();\n                        }\n\n                        break;\n\n                    case DIMENSION$4:\n                        value = this.Dimension();\n                        break;\n\n                    case IDENT$9:\n                        value = this.Identifier();\n\n                        break;\n\n                    default:\n                        this.error('Number, dimension, ratio or identifier is expected');\n                }\n\n                this.scanner.skipSC();\n            }\n\n            this.eat(RIGHTPARENTHESIS$3);\n\n            return {\n                type: 'MediaFeature',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: name,\n                value: value\n            };\n        },\n        generate: function(node) {\n            this.chunk('(');\n            this.chunk(node.name);\n            if (node.value !== null) {\n                this.chunk(':');\n                this.node(node.value);\n            }\n            this.chunk(')');\n        }\n    };\n\n    var TYPE$r = tokenizer.TYPE;\n\n    var WHITESPACE$7 = TYPE$r.WhiteSpace;\n    var COMMENT$7 = TYPE$r.Comment;\n    var IDENT$a = TYPE$r.Ident;\n    var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;\n\n    var MediaQuery = {\n        name: 'MediaQuery',\n        structure: {\n            children: [[\n                'Identifier',\n                'MediaFeature',\n                'WhiteSpace'\n            ]]\n        },\n        parse: function() {\n            this.scanner.skipSC();\n\n            var children = this.createList();\n            var child = null;\n            var space = null;\n\n            scan:\n            while (!this.scanner.eof) {\n                switch (this.scanner.tokenType) {\n                    case COMMENT$7:\n                        this.scanner.next();\n                        continue;\n\n                    case WHITESPACE$7:\n                        space = this.WhiteSpace();\n                        continue;\n\n                    case IDENT$a:\n                        child = this.Identifier();\n                        break;\n\n                    case LEFTPARENTHESIS$3:\n                        child = this.MediaFeature();\n                        break;\n\n                    default:\n                        break scan;\n                }\n\n                if (space !== null) {\n                    children.push(space);\n                    space = null;\n                }\n\n                children.push(child);\n            }\n\n            if (child === null) {\n                this.error('Identifier or parenthesis is expected');\n            }\n\n            return {\n                type: 'MediaQuery',\n                loc: this.getLocationFromList(children),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node);\n        }\n    };\n\n    var COMMA$1 = tokenizer.TYPE.Comma;\n\n    var MediaQueryList = {\n        name: 'MediaQueryList',\n        structure: {\n            children: [[\n                'MediaQuery'\n            ]]\n        },\n        parse: function(relative) {\n            var children = this.createList();\n\n            this.scanner.skipSC();\n\n            while (!this.scanner.eof) {\n                children.push(this.MediaQuery(relative));\n\n                if (this.scanner.tokenType !== COMMA$1) {\n                    break;\n                }\n\n                this.scanner.next();\n            }\n\n            return {\n                type: 'MediaQueryList',\n                loc: this.getLocationFromList(children),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node, function() {\n                this.chunk(',');\n            });\n        }\n    };\n\n    var Nth = {\n        name: 'Nth',\n        structure: {\n            nth: ['AnPlusB', 'Identifier'],\n            selector: ['SelectorList', null]\n        },\n        parse: function(allowOfClause) {\n            this.scanner.skipSC();\n\n            var start = this.scanner.tokenStart;\n            var end = start;\n            var selector = null;\n            var query;\n\n            if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {\n                query = this.Identifier();\n            } else {\n                query = this.AnPlusB();\n            }\n\n            this.scanner.skipSC();\n\n            if (allowOfClause && this.scanner.lookupValue(0, 'of')) {\n                this.scanner.next();\n\n                selector = this.SelectorList();\n\n                if (this.needPositions) {\n                    end = this.getLastListNode(selector.children).loc.end.offset;\n                }\n            } else {\n                if (this.needPositions) {\n                    end = query.loc.end.offset;\n                }\n            }\n\n            return {\n                type: 'Nth',\n                loc: this.getLocation(start, end),\n                nth: query,\n                selector: selector\n            };\n        },\n        generate: function(node) {\n            this.node(node.nth);\n            if (node.selector !== null) {\n                this.chunk(' of ');\n                this.node(node.selector);\n            }\n        }\n    };\n\n    var NUMBER$5 = tokenizer.TYPE.Number;\n\n    var _Number = {\n        name: 'Number',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            return {\n                type: 'Number',\n                loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n                value: this.consume(NUMBER$5)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n        }\n    };\n\n    // '/' | '*' | ',' | ':' | '+' | '-'\n    var Operator = {\n        name: 'Operator',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            this.scanner.next();\n\n            return {\n                type: 'Operator',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: this.scanner.substrToCursor(start)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n        }\n    };\n\n    var TYPE$s = tokenizer.TYPE;\n\n    var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;\n    var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;\n\n    var Parentheses = {\n        name: 'Parentheses',\n        structure: {\n            children: [[]]\n        },\n        parse: function(readSequence, recognizer) {\n            var start = this.scanner.tokenStart;\n            var children = null;\n\n            this.eat(LEFTPARENTHESIS$4);\n\n            children = readSequence.call(this, recognizer);\n\n            if (!this.scanner.eof) {\n                this.eat(RIGHTPARENTHESIS$4);\n            }\n\n            return {\n                type: 'Parentheses',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.chunk('(');\n            this.children(node);\n            this.chunk(')');\n        }\n    };\n\n    var consumeNumber$4 = utils.consumeNumber;\n    var TYPE$t = tokenizer.TYPE;\n\n    var PERCENTAGE$1 = TYPE$t.Percentage;\n\n    var Percentage = {\n        name: 'Percentage',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var numberEnd = consumeNumber$4(this.scanner.source, start);\n\n            this.eat(PERCENTAGE$1);\n\n            return {\n                type: 'Percentage',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: this.scanner.source.substring(start, numberEnd)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n            this.chunk('%');\n        }\n    };\n\n    var TYPE$u = tokenizer.TYPE;\n\n    var IDENT$b = TYPE$u.Ident;\n    var FUNCTION$1 = TYPE$u.Function;\n    var COLON$3 = TYPE$u.Colon;\n    var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;\n\n    // : [ <ident> | <function-token> <any-value>? ) ]\n    var PseudoClassSelector = {\n        name: 'PseudoClassSelector',\n        structure: {\n            name: String,\n            children: [['Raw'], null]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var children = null;\n            var name;\n            var nameLowerCase;\n\n            this.eat(COLON$3);\n\n            if (this.scanner.tokenType === FUNCTION$1) {\n                name = this.consumeFunctionName();\n                nameLowerCase = name.toLowerCase();\n\n                if (this.pseudo.hasOwnProperty(nameLowerCase)) {\n                    this.scanner.skipSC();\n                    children = this.pseudo[nameLowerCase].call(this);\n                    this.scanner.skipSC();\n                } else {\n                    children = this.createList();\n                    children.push(\n                        this.Raw(this.scanner.tokenIndex, null, false)\n                    );\n                }\n\n                this.eat(RIGHTPARENTHESIS$5);\n            } else {\n                name = this.consume(IDENT$b);\n            }\n\n            return {\n                type: 'PseudoClassSelector',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: name,\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.chunk(':');\n            this.chunk(node.name);\n\n            if (node.children !== null) {\n                this.chunk('(');\n                this.children(node);\n                this.chunk(')');\n            }\n        },\n        walkContext: 'function'\n    };\n\n    var TYPE$v = tokenizer.TYPE;\n\n    var IDENT$c = TYPE$v.Ident;\n    var FUNCTION$2 = TYPE$v.Function;\n    var COLON$4 = TYPE$v.Colon;\n    var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;\n\n    // :: [ <ident> | <function-token> <any-value>? ) ]\n    var PseudoElementSelector = {\n        name: 'PseudoElementSelector',\n        structure: {\n            name: String,\n            children: [['Raw'], null]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var children = null;\n            var name;\n            var nameLowerCase;\n\n            this.eat(COLON$4);\n            this.eat(COLON$4);\n\n            if (this.scanner.tokenType === FUNCTION$2) {\n                name = this.consumeFunctionName();\n                nameLowerCase = name.toLowerCase();\n\n                if (this.pseudo.hasOwnProperty(nameLowerCase)) {\n                    this.scanner.skipSC();\n                    children = this.pseudo[nameLowerCase].call(this);\n                    this.scanner.skipSC();\n                } else {\n                    children = this.createList();\n                    children.push(\n                        this.Raw(this.scanner.tokenIndex, null, false)\n                    );\n                }\n\n                this.eat(RIGHTPARENTHESIS$6);\n            } else {\n                name = this.consume(IDENT$c);\n            }\n\n            return {\n                type: 'PseudoElementSelector',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: name,\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.chunk('::');\n            this.chunk(node.name);\n\n            if (node.children !== null) {\n                this.chunk('(');\n                this.children(node);\n                this.chunk(')');\n            }\n        },\n        walkContext: 'function'\n    };\n\n    var isDigit$5 = tokenizer.isDigit;\n    var TYPE$w = tokenizer.TYPE;\n\n    var NUMBER$6 = TYPE$w.Number;\n    var DELIM$4 = TYPE$w.Delim;\n    var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)\n    var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)\n\n    // Terms of <ratio> should be a positive numbers (not zero or negative)\n    // (see https://drafts.csswg.org/mediaqueries-3/#values)\n    // However, -o-min-device-pixel-ratio takes fractional values as a ratio's term\n    // and this is using by various sites. Therefore we relax checking on parse\n    // to test a term is unsigned number without an exponent part.\n    // Additional checking may be applied on lexer validation.\n    function consumeNumber$5() {\n        this.scanner.skipWS();\n\n        var value = this.consume(NUMBER$6);\n\n        for (var i = 0; i < value.length; i++) {\n            var code = value.charCodeAt(i);\n            if (!isDigit$5(code) && code !== FULLSTOP$1) {\n                this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);\n            }\n        }\n\n        if (Number(value) === 0) {\n            this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);\n        }\n\n        return value;\n    }\n\n    // <positive-integer> S* '/' S* <positive-integer>\n    var Ratio = {\n        name: 'Ratio',\n        structure: {\n            left: String,\n            right: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var left = consumeNumber$5.call(this);\n            var right;\n\n            this.scanner.skipWS();\n\n            if (!this.scanner.isDelim(SOLIDUS$3)) {\n                this.error('Solidus is expected');\n            }\n            this.eat(DELIM$4);\n            right = consumeNumber$5.call(this);\n\n            return {\n                type: 'Ratio',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                left: left,\n                right: right\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.left);\n            this.chunk('/');\n            this.chunk(node.right);\n        }\n    };\n\n    var TYPE$x = tokenizer.TYPE;\n    var rawMode$4 = Raw.mode;\n\n    var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;\n\n    function consumeRaw$3(startToken) {\n        return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);\n    }\n\n    function consumePrelude() {\n        var prelude = this.SelectorList();\n\n        if (prelude.type !== 'Raw' &&\n            this.scanner.eof === false &&\n            this.scanner.tokenType !== LEFTCURLYBRACKET$4) {\n            this.error();\n        }\n\n        return prelude;\n    }\n\n    var Rule = {\n        name: 'Rule',\n        structure: {\n            prelude: ['SelectorList', 'Raw'],\n            block: ['Block']\n        },\n        parse: function() {\n            var startToken = this.scanner.tokenIndex;\n            var startOffset = this.scanner.tokenStart;\n            var prelude;\n            var block;\n\n            if (this.parseRulePrelude) {\n                prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);\n            } else {\n                prelude = consumeRaw$3.call(this, startToken);\n            }\n\n            block = this.Block(true);\n\n            return {\n                type: 'Rule',\n                loc: this.getLocation(startOffset, this.scanner.tokenStart),\n                prelude: prelude,\n                block: block\n            };\n        },\n        generate: function(node) {\n            this.node(node.prelude);\n            this.node(node.block);\n        },\n        walkContext: 'rule'\n    };\n\n    var Selector = {\n        name: 'Selector',\n        structure: {\n            children: [[\n                'TypeSelector',\n                'IdSelector',\n                'ClassSelector',\n                'AttributeSelector',\n                'PseudoClassSelector',\n                'PseudoElementSelector',\n                'Combinator',\n                'WhiteSpace'\n            ]]\n        },\n        parse: function() {\n            var children = this.readSequence(this.scope.Selector);\n\n            // nothing were consumed\n            if (this.getFirstListNode(children) === null) {\n                this.error('Selector is expected');\n            }\n\n            return {\n                type: 'Selector',\n                loc: this.getLocationFromList(children),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node);\n        }\n    };\n\n    var TYPE$y = tokenizer.TYPE;\n\n    var COMMA$2 = TYPE$y.Comma;\n\n    var SelectorList = {\n        name: 'SelectorList',\n        structure: {\n            children: [[\n                'Selector',\n                'Raw'\n            ]]\n        },\n        parse: function() {\n            var children = this.createList();\n\n            while (!this.scanner.eof) {\n                children.push(this.Selector());\n\n                if (this.scanner.tokenType === COMMA$2) {\n                    this.scanner.next();\n                    continue;\n                }\n\n                break;\n            }\n\n            return {\n                type: 'SelectorList',\n                loc: this.getLocationFromList(children),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node, function() {\n                this.chunk(',');\n            });\n        },\n        walkContext: 'selector'\n    };\n\n    var STRING$1 = tokenizer.TYPE.String;\n\n    var _String = {\n        name: 'String',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            return {\n                type: 'String',\n                loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n                value: this.consume(STRING$1)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n        }\n    };\n\n    var TYPE$z = tokenizer.TYPE;\n\n    var WHITESPACE$8 = TYPE$z.WhiteSpace;\n    var COMMENT$8 = TYPE$z.Comment;\n    var ATKEYWORD$2 = TYPE$z.AtKeyword;\n    var CDO$1 = TYPE$z.CDO;\n    var CDC$1 = TYPE$z.CDC;\n    var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\n    function consumeRaw$4(startToken) {\n        return this.Raw(startToken, null, false);\n    }\n\n    var StyleSheet = {\n        name: 'StyleSheet',\n        structure: {\n            children: [[\n                'Comment',\n                'CDO',\n                'CDC',\n                'Atrule',\n                'Rule',\n                'Raw'\n            ]]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var children = this.createList();\n            var child;\n\n            scan:\n            while (!this.scanner.eof) {\n                switch (this.scanner.tokenType) {\n                    case WHITESPACE$8:\n                        this.scanner.next();\n                        continue;\n\n                    case COMMENT$8:\n                        // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {\n                            this.scanner.next();\n                            continue;\n                        }\n\n                        child = this.Comment();\n                        break;\n\n                    case CDO$1: // <!--\n                        child = this.CDO();\n                        break;\n\n                    case CDC$1: // -->\n                        child = this.CDC();\n                        break;\n\n                    // CSS Syntax Module Level 3\n                    // §2.2 Error handling\n                    // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n                    case ATKEYWORD$2:\n                        child = this.parseWithFallback(this.Atrule, consumeRaw$4);\n                        break;\n\n                    // Anything else starts a qualified rule ...\n                    default:\n                        child = this.parseWithFallback(this.Rule, consumeRaw$4);\n                }\n\n                children.push(child);\n            }\n\n            return {\n                type: 'StyleSheet',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node);\n        },\n        walkContext: 'stylesheet'\n    };\n\n    var TYPE$A = tokenizer.TYPE;\n\n    var IDENT$d = TYPE$A.Ident;\n    var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)\n    var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)\n\n    function eatIdentifierOrAsterisk() {\n        if (this.scanner.tokenType !== IDENT$d &&\n            this.scanner.isDelim(ASTERISK$4) === false) {\n            this.error('Identifier or asterisk is expected');\n        }\n\n        this.scanner.next();\n    }\n\n    // ident\n    // ident|ident\n    // ident|*\n    // *\n    // *|ident\n    // *|*\n    // |ident\n    // |*\n    var TypeSelector = {\n        name: 'TypeSelector',\n        structure: {\n            name: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            if (this.scanner.isDelim(VERTICALLINE$2)) {\n                this.scanner.next();\n                eatIdentifierOrAsterisk.call(this);\n            } else {\n                eatIdentifierOrAsterisk.call(this);\n\n                if (this.scanner.isDelim(VERTICALLINE$2)) {\n                    this.scanner.next();\n                    eatIdentifierOrAsterisk.call(this);\n                }\n            }\n\n            return {\n                type: 'TypeSelector',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                name: this.scanner.substrToCursor(start)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.name);\n        }\n    };\n\n    var isHexDigit$4 = tokenizer.isHexDigit;\n    var cmpChar$4 = tokenizer.cmpChar;\n    var TYPE$B = tokenizer.TYPE;\n    var NAME$3 = tokenizer.NAME;\n\n    var IDENT$e = TYPE$B.Ident;\n    var NUMBER$7 = TYPE$B.Number;\n    var DIMENSION$5 = TYPE$B.Dimension;\n    var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)\n    var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)\n    var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)\n    var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)\n\n    function eatHexSequence(offset, allowDash) {\n        for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {\n            var code = this.scanner.source.charCodeAt(pos);\n\n            if (code === HYPHENMINUS$4 && allowDash && len !== 0) {\n                if (eatHexSequence.call(this, offset + len + 1, false) === 0) {\n                    this.error();\n                }\n\n                return -1;\n            }\n\n            if (!isHexDigit$4(code)) {\n                this.error(\n                    allowDash && len !== 0\n                        ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'\n                        : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),\n                    pos\n                );\n            }\n\n            if (++len > 6) {\n                this.error('Too many hex digits', pos);\n            }    }\n\n        this.scanner.next();\n        return len;\n    }\n\n    function eatQuestionMarkSequence(max) {\n        var count = 0;\n\n        while (this.scanner.isDelim(QUESTIONMARK$2)) {\n            if (++count > max) {\n                this.error('Too many question marks');\n            }\n\n            this.scanner.next();\n        }\n    }\n\n    function startsWith$1(code) {\n        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {\n            this.error(NAME$3[code] + ' is expected');\n        }\n    }\n\n    // https://drafts.csswg.org/css-syntax/#urange\n    // Informally, the <urange> production has three forms:\n    // U+0001\n    //      Defines a range consisting of a single code point, in this case the code point \"1\".\n    // U+0001-00ff\n    //      Defines a range of codepoints between the first and the second value, in this case\n    //      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n    // U+00??\n    //      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n    //      in this case defining the same as the value U+0000-00ff.\n    // In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n    //\n    // <urange> =\n    //   u '+' <ident-token> '?'* |\n    //   u <dimension-token> '?'* |\n    //   u <number-token> '?'* |\n    //   u <number-token> <dimension-token> |\n    //   u <number-token> <number-token> |\n    //   u '+' '?'+\n    function scanUnicodeRange() {\n        var hexLength = 0;\n\n        // u '+' <ident-token> '?'*\n        // u '+' '?'+\n        if (this.scanner.isDelim(PLUSSIGN$6)) {\n            this.scanner.next();\n\n            if (this.scanner.tokenType === IDENT$e) {\n                hexLength = eatHexSequence.call(this, 0, true);\n                if (hexLength > 0) {\n                    eatQuestionMarkSequence.call(this, 6 - hexLength);\n                }\n                return;\n            }\n\n            if (this.scanner.isDelim(QUESTIONMARK$2)) {\n                this.scanner.next();\n                eatQuestionMarkSequence.call(this, 5);\n                return;\n            }\n\n            this.error('Hex digit or question mark is expected');\n            return;\n        }\n\n        // u <number-token> '?'*\n        // u <number-token> <dimension-token>\n        // u <number-token> <number-token>\n        if (this.scanner.tokenType === NUMBER$7) {\n            startsWith$1.call(this, PLUSSIGN$6);\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (this.scanner.isDelim(QUESTIONMARK$2)) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n                return;\n            }\n\n            if (this.scanner.tokenType === DIMENSION$5 ||\n                this.scanner.tokenType === NUMBER$7) {\n                startsWith$1.call(this, HYPHENMINUS$4);\n                eatHexSequence.call(this, 1, false);\n                return;\n            }\n\n            return;\n        }\n\n        // u <dimension-token> '?'*\n        if (this.scanner.tokenType === DIMENSION$5) {\n            startsWith$1.call(this, PLUSSIGN$6);\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (hexLength > 0) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n            }\n\n            return;\n        }\n\n        this.error();\n    }\n\n    var UnicodeRange = {\n        name: 'UnicodeRange',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n\n            // U or u\n            if (!cmpChar$4(this.scanner.source, start, U$1)) {\n                this.error('U is expected');\n            }\n\n            if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {\n                this.error('Plus sign is expected');\n            }\n\n            this.scanner.next();\n            scanUnicodeRange.call(this);\n\n            return {\n                type: 'UnicodeRange',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: this.scanner.substrToCursor(start)\n            };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n        }\n    };\n\n    var isWhiteSpace$2 = tokenizer.isWhiteSpace;\n    var cmpStr$4 = tokenizer.cmpStr;\n    var TYPE$C = tokenizer.TYPE;\n\n    var FUNCTION$3 = TYPE$C.Function;\n    var URL$1 = TYPE$C.Url;\n    var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;\n\n    // <url-token> | <function-token> <string> )\n    var Url = {\n        name: 'Url',\n        structure: {\n            value: ['String', 'Raw']\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var value;\n\n            switch (this.scanner.tokenType) {\n                case URL$1:\n                    var rawStart = start + 4;\n                    var rawEnd = this.scanner.tokenEnd - 1;\n\n                    while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {\n                        rawStart++;\n                    }\n\n                    while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {\n                        rawEnd--;\n                    }\n\n                    value = {\n                        type: 'Raw',\n                        loc: this.getLocation(rawStart, rawEnd),\n                        value: this.scanner.source.substring(rawStart, rawEnd)\n                    };\n\n                    this.eat(URL$1);\n                    break;\n\n                case FUNCTION$3:\n                    if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {\n                        this.error('Function name must be `url`');\n                    }\n\n                    this.eat(FUNCTION$3);\n                    this.scanner.skipSC();\n                    value = this.String();\n                    this.scanner.skipSC();\n                    this.eat(RIGHTPARENTHESIS$7);\n                    break;\n\n                default:\n                    this.error('Url or Function is expected');\n            }\n\n            return {\n                type: 'Url',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                value: value\n            };\n        },\n        generate: function(node) {\n            this.chunk('url');\n            this.chunk('(');\n            this.node(node.value);\n            this.chunk(')');\n        }\n    };\n\n    var Value = {\n        name: 'Value',\n        structure: {\n            children: [[]]\n        },\n        parse: function() {\n            var start = this.scanner.tokenStart;\n            var children = this.readSequence(this.scope.Value);\n\n            return {\n                type: 'Value',\n                loc: this.getLocation(start, this.scanner.tokenStart),\n                children: children\n            };\n        },\n        generate: function(node) {\n            this.children(node);\n        }\n    };\n\n    var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;\n    var SPACE$2 = Object.freeze({\n        type: 'WhiteSpace',\n        loc: null,\n        value: ' '\n    });\n\n    var WhiteSpace$1 = {\n        name: 'WhiteSpace',\n        structure: {\n            value: String\n        },\n        parse: function() {\n            this.eat(WHITESPACE$9);\n            return SPACE$2;\n\n            // return {\n            //     type: 'WhiteSpace',\n            //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n            //     value: this.consume(WHITESPACE)\n            // };\n        },\n        generate: function(node) {\n            this.chunk(node.value);\n        }\n    };\n\n    var node = {\n        AnPlusB: AnPlusB,\n        Atrule: Atrule,\n        AtrulePrelude: AtrulePrelude,\n        AttributeSelector: AttributeSelector,\n        Block: Block,\n        Brackets: Brackets,\n        CDC: CDC_1,\n        CDO: CDO_1,\n        ClassSelector: ClassSelector,\n        Combinator: Combinator,\n        Comment: Comment,\n        Declaration: Declaration,\n        DeclarationList: DeclarationList,\n        Dimension: Dimension,\n        Function: _Function,\n        HexColor: HexColor,\n        Identifier: Identifier,\n        IdSelector: IdSelector,\n        MediaFeature: MediaFeature,\n        MediaQuery: MediaQuery,\n        MediaQueryList: MediaQueryList,\n        Nth: Nth,\n        Number: _Number,\n        Operator: Operator,\n        Parentheses: Parentheses,\n        Percentage: Percentage,\n        PseudoClassSelector: PseudoClassSelector,\n        PseudoElementSelector: PseudoElementSelector,\n        Ratio: Ratio,\n        Raw: Raw,\n        Rule: Rule,\n        Selector: Selector,\n        SelectorList: SelectorList,\n        String: _String,\n        StyleSheet: StyleSheet,\n        TypeSelector: TypeSelector,\n        UnicodeRange: UnicodeRange,\n        Url: Url,\n        Value: Value,\n        WhiteSpace: WhiteSpace$1\n    };\n\n    var data = getCjsExportFromNamespace(defaultSyntax$1);\n\n    var lexer = {\n        generic: true,\n        types: data.types,\n        atrules: data.atrules,\n        properties: data.properties,\n        node: node\n    };\n\n    var cmpChar$5 = tokenizer.cmpChar;\n    var cmpStr$5 = tokenizer.cmpStr;\n    var TYPE$D = tokenizer.TYPE;\n\n    var IDENT$f = TYPE$D.Ident;\n    var STRING$2 = TYPE$D.String;\n    var NUMBER$8 = TYPE$D.Number;\n    var FUNCTION$4 = TYPE$D.Function;\n    var URL$2 = TYPE$D.Url;\n    var HASH$4 = TYPE$D.Hash;\n    var DIMENSION$6 = TYPE$D.Dimension;\n    var PERCENTAGE$2 = TYPE$D.Percentage;\n    var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;\n    var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;\n    var COMMA$3 = TYPE$D.Comma;\n    var DELIM$5 = TYPE$D.Delim;\n    var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)\n    var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)\n    var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)\n    var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)\n    var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)\n    var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)\n\n    var _default = function defaultRecognizer(context) {\n        switch (this.scanner.tokenType) {\n            case HASH$4:\n                return this.HexColor();\n\n            case COMMA$3:\n                context.space = null;\n                context.ignoreWSAfter = true;\n                return this.Operator();\n\n            case LEFTPARENTHESIS$5:\n                return this.Parentheses(this.readSequence, context.recognizer);\n\n            case LEFTSQUAREBRACKET$3:\n                return this.Brackets(this.readSequence, context.recognizer);\n\n            case STRING$2:\n                return this.String();\n\n            case DIMENSION$6:\n                return this.Dimension();\n\n            case PERCENTAGE$2:\n                return this.Percentage();\n\n            case NUMBER$8:\n                return this.Number();\n\n            case FUNCTION$4:\n                return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')\n                    ? this.Url()\n                    : this.Function(this.readSequence, context.recognizer);\n\n            case URL$2:\n                return this.Url();\n\n            case IDENT$f:\n                // check for unicode range, it should start with u+ or U+\n                if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&\n                    cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {\n                    return this.UnicodeRange();\n                } else {\n                    return this.Identifier();\n                }\n\n            case DELIM$5:\n                var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n\n                if (code === SOLIDUS$4 ||\n                    code === ASTERISK$5 ||\n                    code === PLUSSIGN$7 ||\n                    code === HYPHENMINUS$5) {\n                    return this.Operator(); // TODO: replace with Delim\n                }\n\n                // TODO: produce a node with Delim node type\n\n                if (code === NUMBERSIGN$3) {\n                    this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);\n                }\n\n                break;\n        }\n    };\n\n    var atrulePrelude = {\n        getNode: _default\n    };\n\n    var TYPE$E = tokenizer.TYPE;\n\n    var DELIM$6 = TYPE$E.Delim;\n    var IDENT$g = TYPE$E.Ident;\n    var DIMENSION$7 = TYPE$E.Dimension;\n    var PERCENTAGE$3 = TYPE$E.Percentage;\n    var NUMBER$9 = TYPE$E.Number;\n    var HASH$5 = TYPE$E.Hash;\n    var COLON$5 = TYPE$E.Colon;\n    var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;\n    var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)\n    var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)\n    var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)\n    var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)\n    var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)\n    var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)\n    var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)\n    var TILDE$2 = 0x007E;           // U+007E TILDE (~)\n\n    function getNode(context) {\n        switch (this.scanner.tokenType) {\n            case LEFTSQUAREBRACKET$4:\n                return this.AttributeSelector();\n\n            case HASH$5:\n                return this.IdSelector();\n\n            case COLON$5:\n                if (this.scanner.lookupType(1) === COLON$5) {\n                    return this.PseudoElementSelector();\n                } else {\n                    return this.PseudoClassSelector();\n                }\n\n            case IDENT$g:\n                return this.TypeSelector();\n\n            case NUMBER$9:\n            case PERCENTAGE$3:\n                return this.Percentage();\n\n            case DIMENSION$7:\n                // throws when .123ident\n                if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {\n                    this.error('Identifier is expected', this.scanner.tokenStart + 1);\n                }\n                break;\n\n            case DELIM$6:\n                var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n\n                switch (code) {\n                    case PLUSSIGN$8:\n                    case GREATERTHANSIGN$2:\n                    case TILDE$2:\n                        context.space = null;\n                        context.ignoreWSAfter = true;\n                        return this.Combinator();\n\n                    case SOLIDUS$5:  // /deep/\n                        return this.Combinator();\n\n                    case FULLSTOP$2:\n                        return this.ClassSelector();\n\n                    case ASTERISK$6:\n                    case VERTICALLINE$3:\n                        return this.TypeSelector();\n\n                    case NUMBERSIGN$4:\n                        return this.IdSelector();\n                }\n\n                break;\n        }\n    }\n    var selector = {\n        getNode: getNode\n    };\n\n    // https://drafts.csswg.org/css-images-4/#element-notation\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/element\n    var element = function() {\n        this.scanner.skipSC();\n\n        var children = this.createSingleNodeList(\n            this.IdSelector()\n        );\n\n        this.scanner.skipSC();\n\n        return children;\n    };\n\n    // legacy IE function\n    // expression( <any-value> )\n    var expression = function() {\n        return this.createSingleNodeList(\n            this.Raw(this.scanner.tokenIndex, null, false)\n        );\n    };\n\n    var TYPE$F = tokenizer.TYPE;\n    var rawMode$5 = Raw.mode;\n\n    var COMMA$4 = TYPE$F.Comma;\n\n    // var( <ident> , <value>? )\n    var _var = function() {\n        var children = this.createList();\n\n        this.scanner.skipSC();\n\n        // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer\n        children.push(this.Identifier());\n\n        this.scanner.skipSC();\n\n        if (this.scanner.tokenType === COMMA$4) {\n            children.push(this.Operator());\n            children.push(this.parseCustomProperty\n                ? this.Value(null)\n                : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)\n            );\n        }\n\n        return children;\n    };\n\n    var value = {\n        getNode: _default,\n        '-moz-element': element,\n        'element': element,\n        'expression': expression,\n        'var': _var\n    };\n\n    var scope = {\n        AtrulePrelude: atrulePrelude,\n        Selector: selector,\n        Value: value\n    };\n\n    var fontFace = {\n        parse: {\n            prelude: null,\n            block: function() {\n                return this.Block(true);\n            }\n        }\n    };\n\n    var TYPE$G = tokenizer.TYPE;\n\n    var STRING$3 = TYPE$G.String;\n    var IDENT$h = TYPE$G.Ident;\n    var URL$3 = TYPE$G.Url;\n    var FUNCTION$5 = TYPE$G.Function;\n    var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;\n\n    var _import = {\n        parse: {\n            prelude: function() {\n                var children = this.createList();\n\n                this.scanner.skipSC();\n\n                switch (this.scanner.tokenType) {\n                    case STRING$3:\n                        children.push(this.String());\n                        break;\n\n                    case URL$3:\n                    case FUNCTION$5:\n                        children.push(this.Url());\n                        break;\n\n                    default:\n                        this.error('String or url() is expected');\n                }\n\n                if (this.lookupNonWSType(0) === IDENT$h ||\n                    this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {\n                    children.push(this.WhiteSpace());\n                    children.push(this.MediaQueryList());\n                }\n\n                return children;\n            },\n            block: null\n        }\n    };\n\n    var media = {\n        parse: {\n            prelude: function() {\n                return this.createSingleNodeList(\n                    this.MediaQueryList()\n                );\n            },\n            block: function() {\n                return this.Block(false);\n            }\n        }\n    };\n\n    var page = {\n        parse: {\n            prelude: function() {\n                return this.createSingleNodeList(\n                    this.SelectorList()\n                );\n            },\n            block: function() {\n                return this.Block(true);\n            }\n        }\n    };\n\n    var TYPE$H = tokenizer.TYPE;\n\n    var WHITESPACE$a = TYPE$H.WhiteSpace;\n    var COMMENT$9 = TYPE$H.Comment;\n    var IDENT$i = TYPE$H.Ident;\n    var FUNCTION$6 = TYPE$H.Function;\n    var COLON$6 = TYPE$H.Colon;\n    var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;\n\n    function consumeRaw$5() {\n        return this.createSingleNodeList(\n            this.Raw(this.scanner.tokenIndex, null, false)\n        );\n    }\n\n    function parentheses() {\n        this.scanner.skipSC();\n\n        if (this.scanner.tokenType === IDENT$i &&\n            this.lookupNonWSType(1) === COLON$6) {\n            return this.createSingleNodeList(\n                this.Declaration()\n            );\n        }\n\n        return readSequence.call(this);\n    }\n\n    function readSequence() {\n        var children = this.createList();\n        var space = null;\n        var child;\n\n        this.scanner.skipSC();\n\n        scan:\n        while (!this.scanner.eof) {\n            switch (this.scanner.tokenType) {\n                case WHITESPACE$a:\n                    space = this.WhiteSpace();\n                    continue;\n\n                case COMMENT$9:\n                    this.scanner.next();\n                    continue;\n\n                case FUNCTION$6:\n                    child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);\n                    break;\n\n                case IDENT$i:\n                    child = this.Identifier();\n                    break;\n\n                case LEFTPARENTHESIS$7:\n                    child = this.Parentheses(parentheses, this.scope.AtrulePrelude);\n                    break;\n\n                default:\n                    break scan;\n            }\n\n            if (space !== null) {\n                children.push(space);\n                space = null;\n            }\n\n            children.push(child);\n        }\n\n        return children;\n    }\n\n    var supports = {\n        parse: {\n            prelude: function() {\n                var children = readSequence.call(this);\n\n                if (this.getFirstListNode(children) === null) {\n                    this.error('Condition is expected');\n                }\n\n                return children;\n            },\n            block: function() {\n                return this.Block(false);\n            }\n        }\n    };\n\n    var atrule = {\n        'font-face': fontFace,\n        'import': _import,\n        'media': media,\n        'page': page,\n        'supports': supports\n    };\n\n    var dir = {\n        parse: function() {\n            return this.createSingleNodeList(\n                this.Identifier()\n            );\n        }\n    };\n\n    var has$1 = {\n        parse: function() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        }\n    };\n\n    var lang = {\n        parse: function() {\n            return this.createSingleNodeList(\n                this.Identifier()\n            );\n        }\n    };\n\n    var selectorList = {\n        parse: function selectorList() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        }\n    };\n\n    var matches = selectorList;\n\n    var not = selectorList;\n\n    var ALLOW_OF_CLAUSE = true;\n\n    var nthWithOfClause = {\n        parse: function nthWithOfClause() {\n            return this.createSingleNodeList(\n                this.Nth(ALLOW_OF_CLAUSE)\n            );\n        }\n    };\n\n    var nthChild = nthWithOfClause;\n\n    var nthLastChild = nthWithOfClause;\n\n    var DISALLOW_OF_CLAUSE = false;\n\n    var nth = {\n        parse: function nth() {\n            return this.createSingleNodeList(\n                this.Nth(DISALLOW_OF_CLAUSE)\n            );\n        }\n    };\n\n    var nthLastOfType = nth;\n\n    var nthOfType = nth;\n\n    var slotted = {\n        parse: function compoundSelector() {\n            return this.createSingleNodeList(\n                this.Selector()\n            );\n        }\n    };\n\n    var pseudo = {\n        'dir': dir,\n        'has': has$1,\n        'lang': lang,\n        'matches': matches,\n        'not': not,\n        'nth-child': nthChild,\n        'nth-last-child': nthLastChild,\n        'nth-last-of-type': nthLastOfType,\n        'nth-of-type': nthOfType,\n        'slotted': slotted\n    };\n\n    var parser = {\n        parseContext: {\n            default: 'StyleSheet',\n            stylesheet: 'StyleSheet',\n            atrule: 'Atrule',\n            atrulePrelude: function(options) {\n                return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);\n            },\n            mediaQueryList: 'MediaQueryList',\n            mediaQuery: 'MediaQuery',\n            rule: 'Rule',\n            selectorList: 'SelectorList',\n            selector: 'Selector',\n            block: function() {\n                return this.Block(true);\n            },\n            declarationList: 'DeclarationList',\n            declaration: 'Declaration',\n            value: 'Value'\n        },\n        scope: scope,\n        atrule: atrule,\n        pseudo: pseudo,\n        node: node\n    };\n\n    var walker = {\n        node: node\n    };\n\n    function merge() {\n        var dest = {};\n\n        for (var i = 0; i < arguments.length; i++) {\n            var src = arguments[i];\n            for (var key in src) {\n                dest[key] = src[key];\n            }\n        }\n\n        return dest;\n    }\n\n    var syntax = create$4.create(\n        merge(\n            lexer,\n            parser,\n            walker\n        )\n    );\n\n    var lib = syntax;\n\n    return lib;\n\n}));\n\n\n//# sourceURL=webpack://window.Diff/./node_modules/css-tree/dist/csstree.js?");

/***/ })

/******/ });